# Общие вопросы программирования

<details>

<summary><strong>Рекурсия</strong></summary>

Рекурсия – это термин/приём в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Классические примеры рекурсии:

* возведение в степень
* числа Фибоначчи
* \-факториал

**Возведение в степень**

```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert(pow(2, 3)); // 8
```

**Числа Фибоначчи**

```js
// Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.

function fib(n) {
  // return n <= 1 ? n : fib(n - 1) + fib(n - 2);
  if (n <= 1) {
    return n
  } else {
    return fib(n - 1) + fib(n - 2);
  }
}

alert(fib(3)); // 2
alert(fib(7)); // 13
```

**Рекурсивная структура данных**

Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя. Например дерево HTML-элементов\
рекурсивные функции могут быть использованы для прохода по ним.

**Замена циклом** Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.

Любая рекурсия может быть сведена к циклу, по сути это следует из тезиса Черча-Тьюринга любая функция, которая может быть вычислена физическим устройством, может быть вычислена машиной Тьюринга; Принципиальное отличие рекурсии от цикла состоит в наличии стека вызова - все локальные переменные и аргументы складываются в стек при каждом вызове рекурсивной функции, а в цикле локальные переменные остаются "на месте".

Обычно рекурсивный алгоритм может быть заменён циклом и, если необходимо, вспомогательной структурой данных, чаще всего стеком.

**Ссылки**

* [learn.javascript.ru - Рекурсия и стек](https://learn.javascript.ru/recursion)
* [Habr - Превращаем рекурсию в цикл](https://habr.com/ru/post/533034/)
* [learn.javascript.ru - Задачка на числа Фибоначчи](https://learn.javascript.ru/task/fibonacci-numbers)
* [code.tutsplus.com - Рекурсия в JavaScript](https://code.tutsplus.com/ru/tutorials/understanding-recursion-with-javascript--cms-30346)

\


</details>

<details>

<summary><strong>Чистые функции</strong></summary>

Детерминированная функция, которая не производит побочных эффектов.

Чистые функции — не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

Чистая функция:

* `идемпотента` - при повторении операции даст тот же эффект
* `детерминирована` - для одних и тех же данных всегда выдаёт тот же результат
* `иммутабельна` - неизменяема. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
* без `сайд-эффектов` - без побочных эффектов. Например: какой-то внешний объект изменился, функция от него зависела, и при тех же входящих данных (которые мы напрямую передали при вызове функции) мы получили новый результат (т.к. она ещё взаимодействует с каким-то внешним объектом, который тоже меняется). Например, нельзя делать AJAX-запросы

**Почему важна `иммутабельность`**\
У нас ссылочный тип данных - функция изменит входящие данные, и они изменятся в объекте где хранятся (например объект в памяти). Соответственно эти изменения могут вылезти где-то ещё. Один метод компонента случайно изменил данные, а другой метод потом взял уже изменённые (хотя ему нужны были оригинальные)...

**Функция должна что-то возвращать**\
Функция не меняет никакие данные которые в ней пришли, и не меняет ничего во внешнем мире.\
Чтоб в такой функции был какой-то смысл - она должна что-то возвращать, делать return().

**Мутирующие и немутирующие методы**\
В JS особенно внимательно нужно относиться к массивам.\
Есть методы `мутирующие` и `немутирующие`.\


Примеры мутирующих методов:

* `push`
* `reverse`
* `splice`

Примеры немутирующих методов:

* `slice`

**Side-effect**\
Побочными эффектами называют любые взаимодействия с внешней средой. К ним относятся файловые операции, такие как запись в файл, чтение файла, отправка или приём данных по сети и даже вывод в консоль.\
Кроме того, побочными эффектами считаются изменения внешних переменных (например, глобальных) и входных параметров в случае, когда они передаются по ссылке.\
Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет логику кода и тестирование. Приводит к возникновению огромного числа ошибок. Только при работе с файлами количество возможных ошибок измеряется сотней: начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из несуществующего файла. Для их предотвращения код обрастает большим числом проверок и защитных механизмов.\
Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически приводит нас к побочным эффектам. В реальных же приложениях, обычно, все сводится к взаимодействию с базой данных или отправкой запросов по сети.\
Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как правило, в типичной программе побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в самом начале и в конце.\
Например, программа, которая конвертирует файл из текстового формата в PDF, в идеале выполняет ровно два побочных эффекта:

* Читает файл в самом начале работы программы.
* Записывает результат работы программы в новый файл.\
  Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Побочные эффекты в таком случае будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу, останется чистым от них.\
  Инкремент и декремент — единственные базовые арифметические операции в JS, которые обладают побочными эффектами ( изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут приводить к таким сложноотлавливаемым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python их нет). В JS стандарты кодирования предписывают их не использовать.

Примеры:

* Видоизменение входных параметров
* console.log
* HTTP вызовы (AJAX/fetch)
* Изменение в файловой системе
* Запросы DOM

**В ReactJS / Redux**\
Чистыми функциями должны быть:

* компоненты
* редьюсеры
* селекторы\


Пример чистой функции

```js
function sum(a, b) {
  return a + b;
}
```

Пример нечистой функции (записывает данные в свои же аргументы)

```js
function withdraw(account, amount) {
  account.total -= amount;
}
```

**Ссылки**

* [IT-Kamasutra #88 - pure function (чистая функция)](https://youtu.be/KU81NnNcjmw)
* [Hexlet - Чистые функции](https://ru.hexlet.io/courses/js-functions/lessons/pure-functions/theory\_unit)
* Смотри также в разделе «[React — Компоненты. Компоненты = чистые функции](../js/react.md)»

\


</details>

<details>

<summary><strong>Инкапсуляция</strong></summary>

Сокрытие лишних деталей.

\


</details>

<details>

<summary><strong>Идемпотентность</strong></summary>

Повторное применение операции к объекту дает тот же результат, что и первое.\
Свойство объекта или операции.

\


</details>

<details>

<summary><strong>Детерминированность</strong></summary>

Результат однозначно определяется исходными данными.\
Для одних и тех же исходных данных алгоритм выдаёт тот же результат.

\


</details>

<details>

<summary><strong>Иммутабельность</strong></summary>

Неизменяемость.\
Функция не меняет входящие данные. Делает копию, и работает уже с ней.

**Ссылки**

* [Неизменяемость в JavaScript](https://techrocks.ru/2020/11/13/immutability-in-javascript-explained/)

\


</details>

<details>

<summary><strong>Интерфейс</strong></summary>

Как мы взаимодействуем с чем-то.\
Интерфейс объекта - какие свойства и методы у него есть.\
Интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...

\


</details>

<details>

<summary><strong>Декоратор</strong></summary>

Микропаттерн оптимизации функции — позволяет добавить дополнительное поведение функции, не изменяя ее.

**Ссылки**

* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [learn JS - Декораторы и переадресация вызова, call/apply](https://learn.javascript.ru/call-apply-decorators)

\


</details>

<details>

<summary><strong>Debounce (Дебаунс)</strong></summary>

"Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.\
Превращает несколько вызовов функции в течение определенного времени в один вызов.\
Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова.

Если дословно переводить — «устранение дребезга».

Возможны два варианта:

* Реальный вызов происходит только в случае, если с момента последней попытки прошло время, большее или равное задержке.
* Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет время, большее или равное задержке, отсчитанной от времени последней попытки.

**Зачем?**\
Обычно debounce используют, если исходная функция вызывается чаще, чем это требуется.\
Например, DOM-события mousemove, resize, scroll генерируют очень частые вызовы обработчиков, поэтому в ряде случаев было бы полезно обернуть такие обработчики в debounce.\
Другое применение – контроль пользовательского ввода текста: если при изменении поля INPUT требуется передавать на сервер текущее введенное значение, это может создать большое количество однотипных запросов, особенно если пользователь печатает очень быстро. В этом случае тоже весьма кстати будет ограничить число вызовов обработчика с помощью debounce.\
Функция debounce крайне полезна, когда дело доходит до производительности обработчиков событий.

Ссылки:

* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [Для чего нужна функция debounce и как она работает](http://gdrw.ru/reviews/tech/debounce-function-in-javascript)
* [learn.javascript.ru - реализация на js](https://learn.javascript.ru/task/debounce)
* [7 важных функций JavaScript](https://getinstance.info/articles/javascript/essential-javascript-functions/)

<!---->

* [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)
* [learn.javascript.ru - Сделать Debounce](https://learn.javascript.ru/task/debounce)
* [doka - Сделать Debounce на примере формы поиска](https://doka.guide/js/debounce/)
* [Habr - Debouncing с помощью React Hooks](https://habr.com/ru/post/492248/)
* [Habr - Debouncing с помощью React Hooks: хук для функций](https://habr.com/ru/company/domclick/blog/510616/)

\


</details>

<details>

<summary><strong>Throttling (Тротлинг)</strong></summary>

Данный декоратор позволяет «затормозить» функцию — функция будет выполняться не чаще одного раза в указанный период, даже если она будет вызвана много раз в течение этого периода. Т.е. все промежуточные вызовы будут игнорироваться.

Ссылки:

* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)

\


</details>

<details>

<summary><strong>Мемоизация</strong></summary>

Разновидность кэширования.\
Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша

Для того чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, всегда возвращать одни и те же значения в ответ на одни и те же аргументы.

Мемоизация — это компромисс между производительностью и потреблением памяти. Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.

Может показаться, что собственные реализации мемоизации стоит применять, например, при обращениях к неким API из браузерного кода. Однако, делать этого не нужно, так как браузер автоматически кэширует их, используя, в частности, HTTP-кэш.

Если вы работаете с React/Redux, можете взглянуть на **reselect**. Тут используется селектор с мемоизацией. Это позволяет выполнять вычисления только в том случае, если в соответствующей части дерева состояний произошли изменения.

Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления. Здесь данная техника может значительно повысить производительность решения. Надо отметить, что нечто вроде вычисления факториала или чисел Фибоначчи — это хорошие учебные примеры, но в реальном мире всё гораздо интереснее и сложнее.

**Ссылки**

* [https://habr.com/ru/company/ruvds/blog/332384/](https://habr.com/ru/company/ruvds/blog/332384/)

\


</details>

<details>

<summary><strong>Анаморфизмы и катаморфизмы</strong></summary>

**Анаморфизмы**

Функции, с помощью которых объекты разворачиваются в более сложные структуры, содержащие объекты того же типа.

```js
// Преобразование целого числа в ряд чисел:
function downToOne(n) {
  const list = [];

  for (let i = n; i > 0; --i) {
    list.push(i);
  }

  return list;
}

downToOne(5) // [ 5, 4, 3, 2, 1 ]
```

\
\


**Катаморфизмы**

Противоположность анаморфизмов: сворачивают объекты с более сложной структурой в простые.

```js
// Преобразование ряда чисел в одно
function product(list) {
  let product = 1;

  for (const n of list) {
    product = product * n;
  }

  return product;
}

product(downToOne(5)) // 120
```

\
\


Ссылки:

* [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#amrphcatmrph)

\


</details>

<details>

<summary><strong>Мемоизация</strong></summary>

`Профилирование` — сбор характеристик работоспособности программы.\
Чтобы оценить, насколько эффективно она работает, выявить ее «слабые» участки.

`Профилировщик` — программа, которая следит за другими программами, во время их исполнения.\
не анализирует, только собирает информацию «как работает программа».

В языках программирования обычно есть спец. методы дл помощи в профилировании.\
Также есть специальные плагины/программы, например в отладчиках в браузерах

**Какая информация обычно собирается**

* измерение времени, затраченного на ту или иную функцию;
* измерение потраченных системных ресурсов на ту или иную функцию;
* изменения программы в зависимости от воздействия на нее со стороны пользователей;
* как запустилась и как прекратила работать программа;
* были ли «зависания» в программе и из-за чего;
* ...

**Ссылки**

* [Профилирование в программировании: какой профилировщик выбрать](https://codernet.ru/articles/drugoe/profilirovanie\_v\_programmirovanii\_kakoj\_profilirovshhik\_vyibrat/)

\


</details>

<details>

<summary><strong>Парадигмы программирования (методологии)</strong></summary>

Набор приёмов и понятий, которые определяют «как писать» называют парадигмой.

**Кратко**

* Императивное
  * ООП
  * Процедурное
* Декларативное
  * Функциональное
  * Логическое
* Прочие
  * Реактивное - ориентированное на потоки данных и распространение изменений. Можно реализовать в **ООП**, в **чистом императивном** стиле и т.д. Естественнее всего реализуется в **функциональном**
  * Структурное
  * Модульное
  * Обобщённое
  * всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное.
* **Императивное** — описываем вычисления в виде инструкций, шаг за шагом изменяющих состояние программы. В деталях описывает _как_ добраться до нужного места.
  * **Процедурное** - исходная задача разбивается на меньшие (с помощью процедур) и это происходит до тех пор, пока решение всех конкретных процедур не окажется тривиальным.
  * **ООП** - сущности в программе представляются в виде объектов. Каждый объект — экземпляр какого-то класса, некой абстрактной сущности, в которой описано поведение.
* **Декларативное** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями. Объясняет _что_ мы должны получить в итоге.
  * **Функциональное** - всё есть чистая функция, даже числа. Важно "отсутствие состояния". На его основе хорошо работать в **реактивном** стиле (см. ниже).
  * **Логическое** - скорее математика, чем программирование. Используя математические доказательства и законы логики, решать бизнес-задачи. Часто используется для моделирования процессов.

**Ещё есть**

* **Реактивное** - ориентированное на потоки данных и распространение изменений. Должна существовать возможность легко выражать статические и динамические потоки данных, а также нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных. Можно реализовать в **ООП**, в **чистом императивном** стиле и т.д. Естественнее всего реализуется в **функциональном**
* **Структурное** - декомпозиция. По-прежнему оперируем состоянием и инструкциями, однако вводится понятие составной инструкции (блока), инструкций ветвления и цикла.
* **Модульное** - разделение функциональности на законченные блоки. Программа описанная в стиле модульного программирования — это набор модулей. Что внутри, классы, императивный код или чистые функции — не важно. Благодаря модулям впервые в программировании появилась серьезная инкапсуляция — возможно использовать какие-либо сущности внутри модуля, но не показывать их внешнему миру.
* **Обобщённое** - разделение на шаблоны
* всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное...\
  Немного подробнее: [«Забытые» парадигмы программирования](https://habr.com/ru/post/223253/) ...

**Прочее**

Декларативный подход читается в среднем легче, хотя на написание в обоих стилях времени может уходить одинаковое количество. (Но это тоже зависит от конкретных разработчиков, потому что кто-то мог привыкнуть к конкретному стилю.)

Человеческий мозг может держать одновременно в памяти ограниченное количество объектов. Если мы работаем с какой-то сложной системой, нам будет трудно одновременно помнить и о том, что она делает, и о том, как она устроена.

Императивный стиль смешивает назначение программы и детали её реализации, в то время как декларативный старается описывать только назначение.

Плюсы и минусы зависят от контекста:

* Если вам нужно детально описать какое-то действие — например при разработке конкретного алгоритма — то больше подходит императивный подход.
* Если вы работаете на уровне бизнес-логики, то лучше писать декларативно, а детали реализации скрыть в более низком уровне абстракций.

**Мультипарадигменные языки**

Для большой части задач так мы вовсе можем использовать и ФП, и ООП, и процедурное, и логическое программирование. И есть языки, которые не привязаны к конкретной парадигме. JavaScript как раз один из таких языков. (Именно поэтому мы могли описать пример для каждой парадигмы на нём.)

**Ссылки**

* [Парадигмы программирования](https://doka.guide/js/programming-paradigms/)
* [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
* [Habr - Чистая архитектура. Часть II — Парадигмы программирования](https://habr.com/ru/post/554474/)
* [Парадигмы программирования](https://pikabu.ru/story/paradigmyi\_programmirovaniya\_7584307)
* [tproger.ru - Функциональное программирование с примерами на JavaScript. Часть 1. Основные техники функционального программирования](https://tproger.ru/translations/functional-js-1/)
* [tproger.ru - Функциональное программирование с примерами на JavaScript. Часть 2. Аппликативные функторы, curryN и валидации](https://tproger.ru/translations/functional-js-2/)

\


</details>

<details>

<summary><strong>Некоторые принципы программирования</strong></summary>

* `DRY` - Don't repeat yourself (Не повторяйся)
* `KISS` - Keep it simple, stupid (Делай проще, тупица)
* `YAGNI` - You aren't gonna need it (Вам это не понадобится)
* `SOLID`
  * (см выше - ООП)
  * Single Responsibility Principle («Принцип единой ответственности», SRP)
  * Open-Closed Principle («Принцип открытости-закрытости», OCP)
  * Liskov Substitution Principle («Принцип подстановки Барбары Лисков», LSP)
  * Interface Segregation Principle («Принцип разделения интерфейса», ISP)
  * Dependency Inversion Principle («Принцип инверсии зависимостей», DIP)
* `GRASP` - Gneral responsibility assignment software patterns (общие шаблоны распределения ответственностей, паттерны проектирования) ООП
  * Информационный эксперт (Information Expert)
  * Создатель (Creator)
  * Контроллер (Controller)
  * Слабое зацепление (Low Coupling)
  * Высокая связность (High Cohesion)
  * Полиморфизм (Polymorphism)
  * Чистое изготовление (Pure Fabrication)
  * Перенаправление (Indirection)
  * Устойчивость к изменениям (Protected Variations)
* `CQS` - Command-query Separation (Разделение ответственности команд и запросов)
* `Law of Demeter` - Закон Деметры (см ООП)
* `SLAP` - Single level of Abstraction Principle (Принцип единого уровня абстракций)

**Интересные идеи на тему**

* [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

**Некоторые принципы Объектно Ориентированнаого Дизайна**

* **Закон Деметры** (англ. Law of Demeter, LoD) - каждый программный модуль:
  * должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.
  * должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
  * обращаться только к непосредственным «друзьям». **Ссылки**
  * [Habr](https://habr.com/ru/post/319652/)
  * [wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD\_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
*   **GRASP** (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей

    * Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения. Постоянно используешь в объекте какой-то внешний метод? Скорее всего, этот метод должен быть в этом объекте
    * высокое сцепление - код выполняющий одну задачу, должне быть в одном месте
    * низкая связность - модули не должны зависеть друг от друга (если они ссылаются друг на друга - это то же самое что у вас один большой модуль)
    * ... (всего 9 принципов)
    * [Wikipedia](https://ru.wikipedia.org/wiki/GRASP)
    * **CQS** (Command Query Separation)
      * метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно.
      * Другими словами, задавание вопроса не должно менять ответ.
      * Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов.
      * Другими словами: если я спрашиваю у объекта "Ты админ?", он должен вернуть только tru или false. И не должен внутри заниматься изменением состояния
      * [Wikipediz](https://ru.wikipedia.org/wiki/CQRS)
      * **Single level of Abstraction** (один уровень абстракции)
        * Каждый метод должен быть написан на одном уровне абстракции.
        * [Single level of abstraction (en)](https://medium.com/@yukas/single-level-of-abstraction-1e2bb6a645d7)

    См видео "[Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)"

\


</details>

**Прочие ссылки**

* [Doka - Что такое код-ревью](https://doka.guide/tools/code-review/)
* [Doka - Что такое технический долг](https://doka.guide/js/technical-debt/)
* [Wikipedia - Дональд Кнут «Искусство программирования»](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%BE\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

\
\


[_Legmo, 2019-2022_](https://github.com/Legmo/notes/)
