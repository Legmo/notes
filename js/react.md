# Шпаргалка по React JS

<details>

<summary><strong>Что нового?</strong></summary>

* **React 18** (апрель 2022)
  * `Параллельный рендеринг` (Concurrent Rendering)
    * В обычном поведении, если React начал перерисовывать DOM, все остальные обновления в очереди блокируются и дожидаются окончания обновления. Concurrent rendering должен решить эту проблему. В конкурентном режиме рендеринг не блокируется. Он прерывается. Это улучшает UX и открывает новые возможности.
  * `automatic batching` (“автоматическое пакетирование”) - улучшение производительности, меняет способ пакетной обработки обновлений React для автоматического выполнения большей пакетной обработки.
    * До версии 18, React уже объединял/группировал (batched) несколько обновлений состояния в одно, чтобы уменьшить количество ненужных повторных отрисовок. Однако это происходило только в обработчиках событий DOM, поэтому промисы, тайм-ауты или другие обработчики этим не могли воспользоваться.
    * ранее каждый вызов useState (установка нового значения) приводил к перерисовке компонентов. Чуть позже движок оптимизировали и такие вызовы начали группироваться и выполняться за один раз, что должно было сократить количество перерисовок. Теперь данный функционал еще больше оптимизировали.
  * Изменения в `Strict Mode`
    * режим был добавлен в React 16.3 — позволяет React производить доп. проверки, что бы исключить возможные проблемы приложения.
    * Более строгий «строгий режим»
    * Добавление `<StrictMode>` в приложение React добавляет особое поведение (только в режиме DEV) ко всем компонентам, вокруг которых оно выполняется. Например, при работе в «строгом режиме» React намеренно выполняет двойной рендеринг компонентов, чтобы избавиться от небезопасных побочных эффектов.
    * в будущем React предоставит функцию, позволяющую компонентам сохранять состояние между анмаунтами. Чтобы подготовиться к этому, React 18 вводит новую проверку только для разработки в строгом режиме. React автоматически анмаунтит и маунтит каждый компонент всякий раз, когда компонент создаётся в первый раз, восстанавливая предыдущее состояние при втором маунте.
  * `Offscreen API`
    * обеспечивает лучшую производительность, скрывая компоненты вместо их размонтирования, сохраняя состояние и по-прежнему вызывая эффекты монтирования/размонтирования.
    * Это сыграет решающую роль в оптимизации таких компонентов, как вкладки, виртуализированные списки и т. д.
  * `Root API` (React DOM Client)
    * Функция рендеринга (render) — та, которая находится в корне каждого приложения React, будет заменена на createRoot.
    * Новый API — это шлюз для доступа к новым функциям React 18. createRoot предоставляется вместе с устаревшим API, чтобы способствовать постепенному внедрению и упрощению возможных сравнений производительности.
    * `createRoot` — новый метод создания корня для рендеринга или анмаунта. Используйте его вместо ReactDOM.render. Без него новые функции в React 18 не работают.
    * `hydrateRoot` — новый метод гидратации приложения, отображаемого на сервере. Заменяет `hydrate()`. Используется в сочетании с новыми API-интерфейсами React DOM Server. Без него новые функции в React 18 не работают.
  * React DOM Server API
    * имеет полную поддержку потоковой передачи Suspense на сервере:
    * `renderToPipeableStream` — для потоковой передачи в среде Node.
    * `renderToReadableStream` — для современных сред выполнения, таких как Deno и Cloudflare.
    * Существующий метод `renderToString` продолжает работать, но не рекомендуется его использовать.
  * Хуки
    * `useId` — создание уникальных ID как на клиенте, так и на сервере, избегая hydration несоответствий.
      * Наиболее полезно для библиотек компонентов, интегрирующихся с API, для которых требуются уникальные ID.
      * Особенно актуально в React 18 т.к. новый рендер сервера доставляет HTML не по порядку.
    * `startTransition` и `useTransition` — позволяют помечать некоторые обновления состояния как несрочные
      * Другие обновления состояния по умолчанию считаются срочными. React позволит срочным обновлениям состояния ( например, обновлению ввода текста) прерывать несрочные обновления состояния (например, отображение списка результатов поиска).
    * `useDeferredValue` - позволяет отложить повторный рендеринг несрочной части дерева.
      * Похож на `debouncing`, но имеет несколько преимуществ по сравнению с ним.
      * Фиксированной задержки по времени нет, поэтому React попытается выполнить отложенный рендеринг сразу после того, как первый рендер отобразится на экране.
      * Отложенный рендеринг может быть прерван и не будет блокировать ввод данных пользователем.
    * `useSyncExternalStore` — позволяет внешним хранилищам поддерживать параллельное чтение. Заставляет обновления в хранилище быть синхронными.
      * Устраняет необходимость в useEffect при реализации подписок на внешние источники данных
      * Рекомендуется для любой библиотеки, которая интегрируется со сторонним состоянием по отношению к React.
    * `useInsertionEffect` — позволяет библиотекам CSS-in-JS решать проблемы с производительностью при внедрении стилей во время рендеринга.
      * Если вы не планируете создавать библиотеку CSS-in-JS, мы не ожидаем, что вы когда-либо будете это использовать.
      * Запустится после изменения DOM, но до того, как эффекты лейаута узнают об этом.
      * Особенно актуален в React 18, поскольку React уступает браузеру во время одновременного рендеринга, давая ему возможность пересчитать лейаут.
  * `Согласованное время useEffect` —
    * React теперь всегда синхронно сбрасывает функции эффектов, если обновление было запущено во время дискретного события пользовательского ввода, такого как щелчок или событие нажатия клавиши.
    * Раньше поведение не всегда было предсказуемым или последовательным.
  * `Более строгие ошибки гидратации`
    * несоответствия гидратации из-за отсутствующего или дополнительного текстового содержимого теперь обрабатываются как ошибки, а не как предупреждения. React больше не будет пытаться «исправлять» отдельные узлы, вставляя или удаляя узел на клиенте в попытке сопоставить разметку сервера, и вернется к рендерингу клиента до ближайшей границы в дереве.
    * Это гарантирует согласованность гидратированного дерева и позволяет избежать потенциальных дыр в конфиденциальности и безопасности, которые могут быть вызваны несоответствием гидратации.
  * `Эффекты лейаута с задержкой`
    * когда дерево повторно приостанавливается и возвращается к резервному варианту, React теперь очищает эффекты лейаута, а затем воссоздает их, когда содержимое внутри границы снова отображается.
    * Это устраняет проблему, из-за которой библиотеки компонентов не могли правильно измерить лейаут при использовании с Suspense.
  * `Новые требования к среде JS`
    * React теперь зависит от современных функций браузеров, включая `Promise`, `Symbol` и `Object.assign`.
    * Если вы поддерживаете более старые браузеры и устройства, такие как Internet Explorer, которые изначально не предоставляют современные функции браузера или имеют несовместимые реализации, рассмотрите возможность включения глобального полифилла в приложение.
  * [Medium - React 18 вышел! Это то, что вам нужно знать](https://medium.com/@hydrock/react-18-%D0%B2%D1%8B%D1%88%D0%B5%D0%BB-%D1%8D%D1%82%D0%BE-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%B2%D0%B0%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-b2bc675761f1)
  * [Habr - React 18. Что нового?](https://habr.com/ru/post/660333/)
* **React 17** (2020)
  * Прославился малым количеством изменений
  * Изменение в `делегировании событий` — теперь все обработчики привязываются к `корневому элементу`, а не `document`
    * Реакт использует особый способ привязки событий (onClick и т.д.) к DOM-элементам. Для повышения производительности.
    * Использует прием «делегирования событий» и привязывает все события к объекту `document`.
    * Теперь все обработчики крепятся к `корневому элементу`, а не `document`.
    * Это решает ряд проблем если: на странице используется N версий React, есть микрофронтенды или используется jQuery
  * Убран костыль с Синтетическим Событием (`SyntheticEvent Even Pooling`) — убрана оптимизация событий, которая более не актуальна в современных браузерах.
  * Небольшие изменения на сближение поведения React с браузера
    * Событие `onScroll` — больше не всплывает, чтобы избежать текущей путаницы;
    * События `onFocus` и `onBlur` — изменены "под капотом" на нативные focusin и focusout;
    * `onClickCapture` и другие `Capture`-события — теперь используют браузерные обработчики событий. Типо onClick? Иил что-то про всплытие/погружение событий?
  * `useEffect()` теперь полностью асинхронный
    * раньше только функция эффекта запускалась асинхронно, тогда как возвращаемая функция для очистки подписок запускалась синхронно, так же как и метод componentWillUnmount(), то теперь и эта функция работает асинхронно, что улучшает производительность в случае перерисовки большого количества элементов, например, когда на сайте присутствуют вкладки, или при переходе со страницы на страницу.
    * Для синхронной работы, можно по-прежнему использовать useLayoutEffect(), который остался незатронутым.
  * Ошибки при возвращении \`
  * undefined\`
    * Если раньше нельзя было возвращать undefined только в обычных компонентах, то теперь такая ошибка будет выбрасываться еще и в React.forwardRef и React.memo.
  * Улучшенный `стек вызовов при ошибках`
    * Когда выбрасывается ошибка, браузер показывает stack trace с названиями функций и их местоположения.
    * Теперь используется новый механизм генерации стека вызовов => позволяет увидеть дерево React-компонентов, которое привело к ошибке, даже в production-среде.
  * `Удаление приватных экспортов` — это удаление некоторых внутренних экспортов, которые ранее были открыты наружу.
    * Например, React Native for Web ранее зависела на некоторых внутренностях системы событий, но эта зависимость не была надежной. В 17-м React эти приватные экспорты были удалены. По большей части из-за того, что только вышеупомянутый проект их использовал, а миграция на более надежные методы уже была произведена.
  * [Habr - React 17: Ничего нового?](https://habr.com/ru/post/519824/)

**Ссылки**

* http://bogdanov-blog.ru/react-router-v4-notes/
* https://habrahabr.ru/post/329996/

\


</details>

<details>

<summary><strong>Базовые понятия</strong></summary>

***

***

\


</details>

<details>

<summary><strong>Как работает React</strong></summary>

***

***

\


</details>

<details>

<summary><strong>Компоненты</strong></summary>

***

\


</details>

<details>

<summary><strong>Жизненный цикл</strong></summary>

***

***

**1. Монтирование**\
_Когда экземпляр компонента создаётся и монтируется в DOM_

***

**2. Обновление**\
_Когда компонент перерисовывается. Может быть вызвано изменениями в state или props_

***

**3 Демонтирование**\
_Когда компонент удаляется из DOM_

***

**4 Обработка ошибок**\
_При возникновении ошибки_

***

**Устаревшие методы. Избегайте их:**

**I. Другие API (есть у каждого компонента)**\


* setState()
* forceUpdate()

**II. Свойства класса**

* defaultProps
* displayName

**III. Свойства экземпляра**

* props
* state

***

\


</details>

<details>

<summary><strong>Другие API классовых компонентов</strong></summary>

***

***

\


</details>

<details>

<summary><strong>Хуки</strong></summary>

***

\
\
\
\


**Ссылки**

* [Habr - React Hooks простыми словами](https://habr.com/ru/company/simbirsoft/blog/652321)
* [Matanit.com - Хуки. Управление функциональными компонентами](https://metanit.com/web/react/6.1.php)
* [Оф. документация](https://ru.reactjs.org/docs/hooks-intro.html)
* [Оф. документация - список хуков](https://ru.reactjs.org/docs/hooks-reference.html)
* [Дэн Абрамов - Полное руководство по useEffect (!)](https://habr.com/ru/company/ruvds/blog/445276/)
* [IT-Kamasutra #84 - hook, useState, хуки](https://youtu.be/EbqQg0K4wbo)
* [WebDev - React видеокаст #2. Полное введение в хуки](https://youtu.be/X6j7Y7tp3\_c)
* [WebDev - React видеокаст #3. Релиз хуков](https://youtu.be/19EmLE2mZ1Q)
* [Демистификация хуков React: useCallback, useMemo и все-все-все](https://proglib.io/p/demistifikaciya-hukov-react-usecallback-usememo-i-vse-vse-vse-2021-02-28)

***

\


</details>

\
\


<details>

<summary><strong>React.memo HOC</strong></summary>

***

HOC для пропуска повторных рендеров.\
Использует мемоизацию (кэширование).\
Принимает react компонент, а возвращает react компонент, который будет обновляться только если его props изменились.

Если обернуть компонента в `React.memo` — React будет использовать последнюю отрисованную версию этого компонента (если props не изменились).

`HOC` (high order component, компонент высшего порядка) — функция, которая принимает компонент и возвращает его улучшенную версию.

`Мемоизация` — хранение результатов дорогостоящих вызовов функций и возврата кэшированного результата вычислений при повторном использовании тех же входных данных.

React.memo затрагивает только изменения пропсов.\
Если функциональный компонент обёрнут в React.memo и использует useState, useReducer или useContext, он будет повторно рендериться при изменении состояния или контекста.

В идеале мемоизированные компоненты должны быть чистыми.\
Рекомендуется добавлять в такой компонент только те свойства, которые редко меняются.

Этот метод предназначен только для оптимизации производительности.\
Не полагайтесь на него, чтобы «предотвратить» рендер, так как это может привести к ошибкам.

Memo принимает 2 аргумента: компонент и функцию propsAreEqual (пропсы равны?).

По умолчанию он поверхностно сравнивает вложенные объекты в объекте props. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.\
\


**Ссылки**

* [Оф. документация — React.memo](https://ru.reactjs.org/docs/react-api.html#reactmemo)
* [Medium — Что такое React.memo и как он работает](https://medium.com/nuances-of-programming/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-react-memo-%D0%B8-%D0%BA%D0%B0%D0%BA-%D0%BE%D0%BD-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-d18cb0eabb4e)

***

\


</details>

<details>

<summary><strong>Context API</strong></summary>

***

**Ссылки**

* [Оф. документация - Контекст](https://ru.reactjs.org/docs/context.html)
* [https://habr.com/ru/post/419449/](https://habr.com/ru/post/419449/)

\


</details>

<details>

<summary><strong>Error Boundaries</strong></summary>

Классовые компоненты, которые

* отлавливают ошибки JS в любом месте деревьев их дочерних компонентов (при помощи спец. методов жизн. цикла)
* сохраняют их в журнале ошибок
* выводят запасной UI вместо рухнувшего дерева компонентов.

Отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов, расположенных «под ними».\
Аналог `catch` в js-конструкции `try ... catch`, но только для компонентов

Классовый компонент является «предохранителем», если включает хотя бы один из следующих методов жизненного цикла:

* `static getDerivedStateFromError()` — для рендеринга запасного UI в случае отлова ошибки.
* `componentDidCatch()` — для журналирования информации об отловленной ошибке.\


\


**Предохранители не поймают ошибки в:**

* обработчиках событий (подробнее);
* асинхронном коде (например колбэках из setTimeout или requestAnimationFrame);
* серверном рендеринге (Server-side rendering);
* самом предохранителе (а не в его дочерних компонентах).\


\


**Заметки**

* Не могут быть адекватно заменены функциональными компонентами (на осень 2022).
  * Подвижки на эту тему: [GitHub discussion](https://github.com/reactwg/react-18/discussions/81)
* На практике чаще всего целесообразным будет один раз описать предохранитель и дальше использовать его по всему приложению.
* Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, будут приводить к размонтированию всего дерева компонентов React.\
  \


**Не «ловят» ошибки внутри себЯ**

Предохранители отлавливают ошибки исключительно в своих дочерних компонентах.\
Предохранитель не сможет отловить ошибку внутри самого себя. Если предохранителю не удаётся отрендерить сообщение об ошибке, то ошибка всплывает до ближайшего предохранителя, расположенного над ним в дереве компонентов. Этот аспект их поведения тоже напоминает работу блоков catch {} в JavaScript.\
\


**Где размещать предохранители**

* Степень охвата кода предохранителями остаётся на ваше усмотрение.
* Например, вы можете защитить им навигационные (route) компоненты верхнего уровня, чтобы выводить пользователю сообщение «Что-то пошло не так», как это часто делают при обработке ошибок серверные фреймворки.
* Или вы можете охватить индивидуальными предохранителями отдельные виджеты, чтобы помешать им уронить всё приложение.\
  \


**А как насчёт try/catch?**

* `try / catch` — отличная конструкция, но она работает исключительно в императивном коде:
* Компоненты React являются декларативными, указывая что должно быть отрендерено: `<Button />`
* Предохранители сохраняют декларативную природу React и ведут себя так, как вы уже привыкли ожидать от компонентов React. Например, если ошибка, произошедшая в методе componentDidUpdate, будет вызвана setState где-то в глубине дерева компонентов, она всё равно корректно всплывёт к ближайшему предохранителю.\
  \


**А что насчёт обработчиков событий?**

Предохранители не отлавливают ошибки, произошедшие в обработчиках событий.

React не нуждается в предохранителях, чтобы корректно обработать ошибки в обработчиках событий. В отличие от метода render и методов жизненного цикла, обработчики событий не выполняются во время рендеринга. Таким образом, даже если они сгенерируют ошибку, React всё равно знает, что нужно выводить на экран.

Чтобы отловить ошибку в обработчике событий, пользуйтесь обычной JavaScript-конструкцией try / catch:

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    try {      // Делаем что-то, что сгенерирует ошибку    
    } 
    catch (error) {
        this.setState({ error });
    }
  }

  render() {
    if (this.state.error) {      
        return <h1>Отловил ошибку.</h1>    
    }    
    return <button onClick={this.handleClick}>Нажми на меня</button>  
  }
}
```

\
\


**Пример**

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {// Обновить состояние с тем, чтобы следующий рендер показал запасной UI.    
    return { hasError: true };  
  }
  componentDidCatch(error, errorInfo) {// Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок    
    logErrorToMyService(error, errorInfo);  
  }
  render() {
    if (this.state.hasError) {      // Можно отрендерить запасной UI произвольного вида      
        return <h1>Что-то пошло не так.</h1>;    
    }
    return this.props.children; 
  }
}

//И можно дальше им пользоваться, как обыкновенным компонентом:

<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

**Ссылки**

* [Оф. документация — Предохранители](https://ru.reactjs.org/docs/error-boundaries.html)
* [Habr - Error Boundaries в React: препарируем лягушку](https://habr.com/ru/company/2gis/blog/583894/)

\


</details>

<details>

<summary><strong>События (events)*</strong></summary>

При обработке событий важно понимать, что все атрибуты элементов React именуются с помощью camelCase. Т.е. `onClick` а не `onclick`.\
При работе с функциями, мы передаем фактическую ссылку на функцию, а не строку.

React.js создает для DOM-события обертку в виде собственного объекта, чтобы оптимизировать производительность работы с событиями. Внутри обработчика все так же возможно получить доступ ко всем методам, доступным для документа.

При использовании React вам обычно не нужно вызывать addEventListener, чтобы добавить обработчиков событий в элемент DOM после его создания. Вместо этого просто предоставьте обработчик, когда элемент изначально отрисовывается.

**Ссылки**

* [Оф.документация — Обработка событий](https://ru.react.js.org/docs/handling-events.html)
* [Оф.документация — SyntheticEvent](https://ru.reactjs.org/docs/events.html)
* [Mentanit - События](https://metanit.com/web/react/2.5.php)

\


</details>

<details>

<summary><strong>JSX</strong></summary>

***

\


</details>

<details>

<summary><strong>Порталы</strong></summary>

Способ отображения дочерних компонентов в узел DOM вне DOM-иерархии родительского компонента.\
Если надо, чтобы дочерние компоненты визуально вырывались из родительского контейнера.

Примеры:

* Модальные окна
* Всплывающие подсказки
* Загрузчики
* ...

Т.е. у меня компонент, который выводит что-то внутри `body.div#root.div#component`.\
А я хочу вывести из него модальное окно, которое будет отображаться в `body`

```
<html>
  <body>
    <div id="root">
      <div id="component">Компонент здесь</div>
    </div>
    <div id="modal">Модальное окно должно быть здесь</div>
  </body>
</html>
```

Синтаксис:

```jsx
ReactDOM.createPortal(child, container)
```

```jsx
return ReactDOM.createPortal(
  <div className="modal">
    <span>{message}</span>
    <button onClick={onClose}>Close</button>
  </div>,
  document.body
);
```

```jsx
const Modal =({ message, isOpen, onClose, children })=> {
  if (!isOpen) return null;
  
  return ReactDOM.createPortal(
    <div className="modal">
      <span>{message}</span>
      <button onClick={onClose}>Close</button>
    </div>,
    document.body
  );
}

function Component() {
  const [open, setOpen] = useState(false)

  return (
    <div className="component">
      <button onClick={() => setOpen(true)}>Open Modal</button>
      <Modal 
       message="Hello World!" 
       isOpen={open} 
       onClose={() => setOpen(false)}
      />
    </div>
  )
}
```

**Ссылки**

* [Оф. документация - Порталы](https://ru.reactjs.org/docs/portals.html)
* [Medium - Понятие о порталах в React с примерами использования](https://medium.com/nuances-of-programming/%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-%D0%BE-%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D0%BB%D0%B0%D1%85-%D0%B2-react-%D1%81-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D0%BC%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-9184c95a54d7)

\


</details>

<details>

<summary><strong>Роутинг</strong></summary>

***

**Ссылки**

* http://bogdanov-blog.ru/react-router-v4-notes/
* https://habrahabr.ru/post/329996/

\


</details>

<details>

<summary><strong>StrictMode (Строгий режим)</strong></summary>

`StrictMode` — инструмент для выделения потенциальных проблем в приложении.\
Активирует дополнительные проверки и предупреждения.\
Появился в React 16.3 в марте 2018.

Не отображает ничего визуального (похожего на Fragment), но обнаруживает потенциальные проблемы в коде и даёт полезные предупреждения.\
Строгий режим работает только в режиме разработки (development), никак не влияет на продакшен-сборку.

С появлением Hooks и Concurrent Mode (параллельный режим), который не за горами, строгий режим становится всё более важным инструментом для обнаружения плохих практик (параллельный режим, вероятно, не будет работать, пока не исправишь предупреждения, выдаваемые в строгом режиме).

**Зачем**

* Обнаружение небезопасных методов жизненного цикла
* Предупреждение об использовании устаревшего API строковых реф
* Предупреждение об использовании устаревшего метода findDOMNode
* Обнаружение неожиданных побочных эффектов
* Обнаружение устаревшего API контекста
* Обеспечение переиспользованного состояния
* Дополнительные проверки будут включены в будущих релизах React

**Использование**

* Обычно в `index.js` оборачивают весь компонент приложения в `<React.StrictMode> </React.StrictMode>`:
  * ```jsx
    import React from "react";
    import ReactDOM from "react-dom";

    ReactDOM.render(
    <React.StrictMode>
    <App />
    </React.StrictMode>,
    document.getElementById("root")
    );
    ```
* Можно обернуть один/несколько компонентов в код

**Ссылки**

* [Оф. документация - React StrictMode](https://ru.reactjs.org/docs/strict-mode.html)
* [Что такое React StrictMode и как его использовать](https://frontend-stuff.com/blog/react-strictmode/)

\


</details>

<details>

<summary><strong>CSS</strong></summary>

***

\


</details>

<details>

<summary><strong>Формы</strong></summary>

**Популярные библиотеки**

* [Redux-Form](https://redux-form.com) - популярный, старый. Есть ряд проблем - см Final Form. Автор рекомендует сейчас использовать Final Form или Formik
  * По словам Дэна Абрамова, состояние формы по своей сути является эфемерным и локальным, поэтому отслеживание его в Redux (или любой другой библиотеке Flux) не требуется.
  * Redux-Form вызывает весь редуктор Redux верхнего уровня несколько раз НА КАЖДОМ ОДНО НАЖАТИЕ. Это нормально для небольших приложений, но по мере роста вашего приложения Redux задержка ввода будет продолжать увеличиваться, если вы используете Redux-Form.
  * Redux-Form имеет размер 22,5 КБ в сжатом виде (формат Formik составляет 12,7 КБ)
* [Final Form](https://github.com/erikras/final-form#-final-form) - улучшенная версия от создателей Redux-Form.
  * Меньший размер
  * Не только для React
  * Не имеет зависимостей,
  * Можно использовать встроенные функции рендеринга.
  * Поддерживает хуки
  * Использует свой стэйт (не Redux).
  * Не лагает на больших формах (т.к. использует Redux).
    * В форме очень много данных постоянно меняется, там же не только текущие значения инпутов, а еще много разной доп. информации, и на каждое изменение у тебя перерисовывается вся форма.
    * форма принимает функционального чилдрена, и он будет перерисован на любое изменение стейта формы
    * филды тоже перерисовывают переданную им компоненту постоянно. в final-form ввели механизм подписок, ты можешь гибко управлять перерисовками.
  * В чем разница между redux-form и final-form - redux-form дает возможность управлять формой извне, если быть точным из любого уголка твоего приложения, т.к. ты можешь диспатчить экшены редакс-формы. И ситуация, когда тебе, в каком-то рядовом проекте, нужно залезть в потроха формы не из формы, мне кажется уже выглядит криво. Нжно из двух зол выбрать наименьшее:
    * с одной стороны final-form, который не позволяет лезть в форму извне (читать стейт формы мы можем без проблем), но при этом решает проблемы производительности redux-form
    * с другой стороны redux-form, который дает больше гибкости по управлению формами извне (что мне кажется приводит к увеличению кол-ва говнокода на проекте), но при этом есть проблемы с производительностью, о которых нужно постоянно думать и закрывать какими-то костылями оптимизациями рендера.
  * Что значит потроха? Нужен доступ к стейту формы за пределами формы. Регулярно такие требования возникают. Ничего кривого не вижу: у тебя могут возникать моменты в которых тебе необходимо заполнить форму из других частей приложения. Требования нахреновертить идут от бизнес-требований. Если есть требование ткнуть в одно место и заполнить форму или засабмитить форму совершенно в другом месте то redux-form тут ни в чём не виноват. Наоборот, позволяет легче сделать
* [Formik](https://formik.org/) - популярный. Рекомендуется разработчиками React
  * есть хуки
  * хранит стэйт в компонентах формы
  * поддерживает тесную интеграцию с Yup — библиотекой для валидации.
  * есть 3 метода создания форм: через компоненты и другие, через хук useFormik (лдя простых случаев), через HOC withFormik
* [React Hook Form](https://react-hook-form.com/) - простой и на хуках.
  * Без зависимостей.
  * Заметно меньше ререндера чем у Formik (3 против 30 в 2021)
  * Есть визуальный конструктор простых фор - https://react-hook-form.com/form-builder
* Работа с формами при помощи кастомных хуков - useState, useCallback

**Ссылки**

* [Erik Rasmussen - Final Form: Дорога к клетчатому флагу](https://medium.com/devschacht/final-form-%D0%B4%D0%BE%D1%80%D0%BE%D0%B3%D0%B0-%D0%BA-%D0%BA%D0%BB%D0%B5%D1%82%D1%87%D0%B0%D1%82%D0%BE%D0%BC%D1%83-%D1%84%D0%BB%D0%B0%D0%B3%D1%83-e49e5b822bcf)
* [Обсуждение - Выпилить react-final-form. Вернуть redux-form](https://github.com/fullstack-development/react-redux-starter-kit/issues/144)
* [Habr - React.js — формошлепство или работа с формами при помощи пользовательских хуков](https://habr.com/ru/post/523256/)
* [Как с легкостью создавать формы на React с помощью react-hook-form](https://medium.com/nuances-of-programming/%D0%BA%D0%B0%D0%BA-%D0%BB%D0%B5%D0%B3%D0%BA%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D1%82%D1%8C-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BD%D0%B0-react-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-react-hook-form-9749c8cb3387)
* [Оф. документация React - Формы. Управляемые компоненты. Тэги форм в React](https://ru.reactjs.org/docs/forms.html)

\


</details>

<details>

<summary><strong>Графики, визуализация данных</strong></summary>

**Популярные библиотеки**

* [D3.js](https://d3js.org/) - библиотека графики для JavaScript.
  * Позволяет привязывать произвольные данные к объектной модели документа (DOM), а затем изменять этот документ на основе данных.
  * Включает в себя много более мелких технических модулей, таких как оси, цвета, иерархии, контуры, многоугольники и проч.
  * Если вы хотите углубиться в детали и иметь полный контроль над каждым элементом, эта библиотека – лучший выбор для вас. Но если вы вам нужно сделать визуализацию данных в вашем проекте, а сроки поджимают, это вряд ли лучший вариант.
  * Попытка создать простую диаграмму может быть довольно трудоемкой задачей. Все элементы, включая оси и прочие детали, должны задаваться явно.
* [Victory](https://github.com/FormidableLabs/victory) - высокопрофессиональную экосистему компонентов с полностью изменяемыми стилями и поведением
  * хороший баланс между простотой использования и высокой настраиваемостью.
  * У этой библиотеки есть практически идентичные API для ReactJS и React Native — эту важную особенность стоит иметь в виду.
* [Nivo](https://github.com/plouc/nivo) - красиво, просто в использовании(на основе D3js)
  * красивый UI,
  * просто невероятную «интерактивную документацию». Nivo предлагает вам не читать длинные тексты с описанием функционала, а воспользоваться ее потрясающим пользовательским интерфейсом для испытания и настройки компонентов ваших графиков. Когда сочтете, что все готово, просто скопируйте код вашего графика. (Со временем, конечно, вы сможете работать с кодом напрямую — этот подход предпочтительнее).
* [Chart.js](https://www.chartjs.org/) - библиотека с открытым исходным кодом, поддерживает 8 типов диаграмм.
  * Отличается малым весом – всего 60kb.
  * Использует элементы canvas для рендеринга, диаграммы отзывчивы к изменению размеров окна.
  * Анимация при первой отрисовке.
* [Google Charts](https://developers.google.com/chart/) - просты в использовании и при этом являются достаточно мощным инструментом

**Также имеются**

* [Rechart](https://github.com/recharts/recharts) - создавать обычные графики
* [Vis](https://github.com/uber/react-vis) — напоминает Recharts в том, что касается попыток сделать экосистемы компонентов как можно проще и модульнее.
  * Лейтмотив этой библиотеки — если вы знаете React, то вы знаете и Vis.
  * созданная Uber
  * графики выглядят про
* [VX](https://github.com/hshoff/vx) - для тех, у кого есть четкое понимание того, как должны выглядеть и работать их графики, но еще нет достаточно знаний, чтобы построить собственную экосистему компонентов на базе D3
  * отличается гибкостью и спроектирован таким образом, чтобы служить в качестве надстройки
* [WebDataRocks](https://www.webdatarocks.com/?r=m7) - компонент сводной таблицы JavaScript, который совместим с React и другими фреймворками.
  * Поддерживает подключение к удаленным/ локальным источникам данных JSON и CSV.
  * бесплатный и настраиваемый.
* [Flexmonster](https://www.flexmonster.com/?r=m7) — это более продвинутый компонент сводной таблицы и расширенная версия WebDataRocks.
* [JSCharting](https://jscharting.com/) - поддерживает большое количество видов диаграмм. Можно создавать богатый интерактивные диаграммы
  * включая картодиаграммы, диаграммы Гантта, биржевые диаграммы и другие, для использования которых часто требуются отдельные библиотеки.
  * Содержит встроенные карты всех стран мира и библиотеку SVG-значков.
  * Набор отдельных микро-диаграмм может отображаться в любом элементе div на странице.
  * Элементы управления (UiItems) позволяют создавать более богатые интерактивные диаграммы.
  * Библиотеку отличает простота управления данными или переменными визуализации в режиме реального времени.
  * Готовые диаграммы можно экспортировать в форматы SVG, PNG, PDF и JPG.
* [Highcharts](https://www.highcharts.com/) - популярная библиотека JavaScript для создания диаграмм, которую используют многие из самых крупных компаний мира.
  * Диаграммы генерируются с использованием SVG. Откат к VML обеспечивает обратную совместимость вплоть до IE6/IE8.
  * Довольно богатый функционал,
  * Примеры на сайте визуально особого восхищения не вызывают.
* [AmCharts](https://www.amcharts.com/)
  * включен сильный движок SVG-анимации, позволяющий создавать сцены, напоминающие кино.
  * Примеры диаграмм выглядят очень красиво. Для большинства демок есть несколько палитр и слайдер UI для регулировки переменных диаграммы в режиме реального времени.
  * Для настройки применяется декларативный API (не подход на основе конфигурации, как у других). Для настройки диаграмм требуется немного больше кода.
* [ZingChart](https://www.zingchart.com/) - много видов диаграмм. Хороший набор функций со многими настройками.
* [FusionCharts](https://www.fusioncharts.com/) - старая надежная библиотека для визуализации.
  * Поддерживает много форматов данных, включая XML, JSON и JavaScript, работает в современных браузерах и имеет обратную совместимость с IE6.
  * Галерея диаграмм включает большое количество примеров, которые выглядят безупречно.
* [KoolChart](https://www.koolchart.com/) - для создания диаграмм на основе HTML5 Canvas.
  * Использование canvas предлагает лучшую производительность за счет растровой основы.

**Ссылки**

* [Топ-5 React-библиотек для создания графиков и диаграмм в 2020 году](https://techrocks.ru/2019/11/18/top-5-react-chart-libraries/)
* [Лучшие библиотеки JavaScript для создания диаграмм (2019)](https://techrocks.ru/2019/05/22/best-javascript-chart-libraries/)
* [Habr - Актуальные библиотеки визуализации данных для react-разработчиков](https://habr.com/ru/post/478750/)
* [Создавайте диаграммы на React с помощью библиотеки chart.js](https://proglib.io/p/sozdavayte-diagrammy-na-react-s-pomoshchyu-biblioteki-chart-js)

\


</details>

<details>

<summary><strong>Lazy и Suspense. Разделение кода (code splitting)</strong></summary>

«Ленивые» (lazy) компоненты - их смысл заключается в разделении приложения на небольшие фрагменты кода. Загрузка этих фрагментов выполняется только тогда, когда они нужны.

Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: `import()`. Когда Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения.

Функция `React.lazy` позволяет рендерить динамический импорт как обычный компонент. React.lazy принимает функцию, которая должна вызвать динамический import(). Результатом возвращённого Promise является модуль, который экспортирует по умолчанию React-компонент (export default).

Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.

**Ссылки**

* [Оф. докуменатция - Разделение кода](https://ru.reactjs.org/docs/code-splitting.html)
* [Mentanit - Хуки в React](https://metanit.com/web/react/6.1.php)
* [Habr = Уменьшение размеров бандлов с помощью Webpack Analyzer и React Lazy/Suspense](https://habr.com/ru/company/ruvds/blog/468225/)

\


</details>

<details>

<summary><strong>Параллельный рендер в React (Concurrent rendering)</strong></summary>

`Concurrent rendering` — скрытый механизм работы React. Фундаментальное обновление базовой модели рендеринга React.\
Позволяет React одновременно подготавливать N версий пользовательского интерфейса.\
Включается только при использовании параллельных функций.\
Появился в React 18 в 2022.

Для реализации `Concurrent rendering` React использует внутри сложные методы, например приоритетные очереди и множественную буферизацию.

Поскольку одновременный рендеринг прерываем, компоненты ведут себя немного по-другому, когда он включен.

Например, используется при:

* при использовании `startTransition` (переход между экранами без блокировки пользовательского ввода).
* при использовании `DeferredValue` (ограничении дорогостоящих повторных рендеров).

**Общая идея**

* В обычном поведении:
  * если React начал перерисовывать DOM, все остальные обновления в очереди блокируются и дожидаются окончания обновления.
  * Как только начался рендер обновления ничто не может прервать его, пока пользователь не увидит результат на экране.
* В режиме `Concurrent rendering`
  * рендеринг не всегда блокируется, а может прерваться.
  * React может начать рендеринг обновления, сделать паузу в середине, а затем продолжить позже.
  * Может даже полностью отказаться от незавершенного рендеринга. React гарантирует, что пользовательский интерфейс будет выглядеть согласованным, даже если рендеринг будет прерван. Для этого он ожидает выполнения мутаций DOM до конца, как только все дерево будет оценено.
  * Благодаря этой возможности React может подготавливать новые экраны в фоновом режиме, не блокируя основной поток => пользовательский интерфейс может немедленно реагировать на действия пользователя, даже если React находится в середине большой задачи рендеринга => плавный пользовательский интерфейс.
  * Это улучшает UX и открывает новые возможности.

Другой пример — `повторно используемое состояние` (reusable state).\
`Concurrent React` может удалять разделы пользовательского интерфейса с экрана, а затем добавлять их обратно, повторно используя предыдущий state.\
Например:

* пользователь уходит с экрана, а потом возвращается — React должен иметь возможность восстановить предыдущий экран в том же состоянии, в котором он был.
* возможность подготовить новый пользовательский интерфейс в фоновом режиме. Чтобы он был готов до того, как показать пользователю (эту возможность планируют добавить позже, с компонентом `<Offscreen>`).

**StrictMode и поиск ошибок**

Можно использовать `StrictMode` чтобы обнаружить ошибки, связанные с параллелизмом, во время разработки.\
`StrictMode` не влияет на продакшен-сборку, но во время разработки он будет регистрировать дополнительные предупреждения и функции двойного вызова, которые, как ожидается, будут идемпотентными.\
Он не поймает все, но эффективно предотвращает наиболее распространенные типы ошибок.

**Ссылки**

* [Оф. документация - React 18 (en)](https://reactjs.org/blog/2022/03/29/react-v18.html)

\


</details>

<details>

<summary><strong>Рендер: на клиенте, на сервере, прогрессивный. Гидратация</strong></summary>

**Рендер, отрисовка**

`Рендер` — отрисовка кода веб-документа в интерактивную веб-страницу, которую пользователь видит в браузере.\
Процесс выполнения всех правил, прописанных в HTML-коде, JS-скриптах и CSS-стилях.

Одна из самых долгих и «дорогих» (по времени) операций в работе сайта. Чем она быстрее — тем лучше.\
Задержка в отрисовке страницы на 1 сек, снижает конверсию на 7%.\
Т.е. чем дольше грузится страница тем больше людей уйдёт не дождавшись.

**3 основных подхода**:

* `Рендеринг на клиенте` (Client Side Render, CSR) — браузер скачивает почти пустой HTML, потом выкачивает большой JS ( возможно разбыиты на «бандлы»), только потом страница отображается.\

  * Пока качается JS - отображается только малая часть страницы или прелоадер. Информации на странице почти нет и взаимодействовать с ней нельзя.
  * [YouTube — Animated Client Side Rendering (Fruits)](https://www.youtube.com/watch?v=4-Lel1oaV7M)
* `Рендеринг на сервере` (Server Side Render, SSR) — весь HTML готовится на сервере. Браузер скачивает этот HTML и показывает пользователю. Потом докачивает скрипты.\

  * Пока пользователь разглядывает это HTML - скачиваются скрипты + дополнительный (не критичный HTML). Когда подгурзятся и подключатся JS-скрипты — страница становится интерактивной.
  * Первая отрисовка страницы заметно быстрее чем в SSR — пользователь сразу видит какой-то осмысленный контент, хоть и без интерактивности.
  * [YouTube — Animated Server Side Rendering (Fruits)](https://www.youtube.com/watch?v=0bvo6UKkNDA)
* `Прогрессивный рендеринг` на стороне сервера (Progressive Server Side Render) — мин. необходимый HTML готовится на сервере. Браузер скачивает этот HTML и показывает пользователю. Потом подгружаются скрипты и остальной HTML.\

  * Также называется `прогрессивная гидратация`
  * Основан на концепции потоковой передачи HTML.
  * Страницы делятся на осмысленные части-компонента, эти части подгружаются отдельно. Рендер компонента не происходит, пока он не появится в поле зрения (scroll) или не понадобится для взаимодействия с пользователем.
  * Быстрее `CSR` и `SSR`. Особенно медленном соединении
  * Чтоб ещё ускорить — применяют оптимизацию критических этапов рендеринга.

**Гидратация. Регидратация**

`Гидратация` или `регидратация` (hydration / re-hydration) — процесс, когда JS преобразует статический HTML в динамическую веб-страницу (присоединяет обработчики событий к элементам HTML). Происходит в браузере после получения HTMl с сервера.

Когда мы используем CSR/PSSR мы получаем с сервера HTML с контентом, и отображаем его пользователю.\
В это время JS работает над созданием полноценного клиентского приложения (Virtual DOM и binding интерфейса управления им). Здесь не надо заново рендерить весь DOM на клиенте, но необходимо добавить недостающие события, методы, а иногда и элементы, которые не рендерились на сервере.\
Этот процесс называется `гидратацией` или `регидратацией`.

**React hydrate() / hydrateRoot()**

`hydrate()` — отдельный метод для рендеринга на клиентской стороне.\
Используется когда рендеринг на клиенте основан на результатах серверного рендеринга.\
Ввели в 16 версии React (2017)

`hydrateRoot()` — заменил метод `hydrate()`, начиная с React 18 (2022).

**Ссылки**

* [Habr - Прогрессивный рендеринг для лучшей производительности веб-приложений](https://habr.com/ru/company/skillfactory/blog/540294/)
* [Habr - Что, черт возьми, такое гидратация и регидратация?](https://habr.com/ru/post/515100/)
* [Серверный или клиентский рендеринг на вебе: что лучше использовать у себя в проекте и почему](https://tproger.ru/translations/rendering-on-the-web/)
* [Как интегрировать серверный рендеринг в React-приложение, и зачем он вообще там нужен](https://highload.today/kak-integrirovat-servernyj-rendering-v-react-prilozhenie-i-zachem-on-voobshhe-tam-nuzhen/)
* [Прогрессивный рендеринг для повышения производительности веб-приложений](https://webformyself.com/progressivnyj-rendering-dlya-povysheniya-proizvoditelnosti-veb-prilozhenij/)
* [Wikipedia - Hydration (web development)](https://en.wikipedia.org/wiki/Hydration\_\(web\_development\))
* [Оф. документация — метод `hydrate()`](https://ru.reactjs.org/docs/react-dom.html#hydrate)
* [Видео - Server Side Rendering с использованием NextJS (ru, «Andersen»)](https://nextcloud.andersenlab.dev/index.php/s/xgi2n8HGprmbaNK)
* [Дока - Виды веб-приложений](https://doka.guide/js/web-app-types/)
* [IT-Kamasutra — FullStack Web архитектура - Server Side Rendering - 01](https://youtu.be/rn-fJ-m8WOY)
* [IT-Kamasutra — FullStack Web архитектура - Server Side Rendering сегодня - 02,](https://youtu.be/7knzkScHzJg)

\


</details>

<details>

<summary><strong>Статическая типизация React</strong></summary>

***

**Ссылки:**

* https://ru.reactjs.org/docs/static-type-checking.html

\


</details>

<details>

<summary><strong>Тестирование React-component</strong></summary>

Есть `unit-тестирование`(проверка работы отдельных модулей самих по себе) и `e2e тестирование` (проверка всей системы целиком).\
В первую очередь, все говорят про unit-тесты

**Что тестировать**

* значения приходящие в компонент через `props` должно быть доступно ей изнутри, например в её стэйте
* при рендере компонента в ней есть нужные html-тэги. Например, у компонента есть два режима - «Edit mode» и «Normal», переключатся по пропсам или стэйту. В одном случае выводится , в другом . Проверяем, есть ли в разметке при таком-то выводе
* в пропсах закинули статус, он должен отобразиться в . Проверяем что в придёт именно этот текст.
* кнопки нажимаются
* проверить работу Callback - что он вызывается и делает что надо....
* имитировать клики, хэндеры, разные пропсы... - что произойдёт

**Популярные технологии**

* [Jest](https://facebook.github.io/jest/) - delightful JavaScript testing used by Facebook to test all JavaScript code including React applications. Разрабатывается Facebook
* [Enzyme](https://github.com/airbnb/enzyme/) - a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components’ output.
* [Mocha](https://mochajs.org/)

**На оф. сайте также упоминаются**

* [react-testing-library](https://github.com/kentcdodds/react-testing-library) - Simple and complete React DOM testing utilities that encourage good testing practices.
* [React-unit](https://github.com/pzavolinsky/react-unit) - a lightweight unit test library for ReactJS with very few ( js-only) dependencies.
* [Skin-deep](https://github.com/glenjamin/skin-deep) - Testing helpers for use with React’s shallowRender test utils.
* [Unexpected-react](https://github.com/bruderstein/unexpected-react/) - Plugin for the unexpected assertion library that makes it easy to assert over your React Components and trigger events.

**Ссылки**

* [Википедия - модульное тестирование](https://ru.m.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5\_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
* [Оф. документация - инструменты тестирования (en)](https://ru.reactjs.org/community/testing.html)
* [Habr - Тестирование React-Redux приложения (Jest)](https://habr.com/ru/post/340514/)
* [Тестирование компонентов в React с использованием Jest: основы](https://code.tutsplus.com/ru/articles/testing-components-in-react-using-jest-the-basics--cms-28934)
* [Habr - React: тестируем компоненты с помощью Jest и Testing Library (2022)](https://habr.com/ru/company/timeweb/blog/670480/)
* [Hexlet - Тестирование JSReact (платный доступ)](https://ru.hexlet.io/courses/js-react/lessons/tests/theory\_unit)
* [Пацианский М - Тестирование React компонентов с помощью jest и enzyme](https://maxpfrontend.ru/vebinary/testirovanie-komponentov-s-pomoschyu-jest-enzyme/)
* [Medium - Модульное тестирование React-приложения с помощью Jest и Enzyme](https://medium.com/devschacht/berry-de-witte-unit-testing-your-react-application-with-jest-and-enzyme-6ef3658fdc93)
* [Medium - Что и как тестировать с помощью Jest и Enzyme. Полная инструкция по тестированию React-компонентов](https://medium.com/devschacht/what-and-how-to-test-with-jest-and-enzyme-full-instruction-on-react-components-testing-d3504f3fbc54)
* [learn.javascript.ru - Автоматические тесты при помощи chai и mocha](https://learn.javascript.ru/testing)
* [Знакомство с разработкой через тестирование в JavaScript (Mocha)](https://tproger.ru/translations/unit-testing-in-javascript/)
* [IT-Kamasutra #92 - тестируем компоненты, тесты, react-test-renderer - React JS](https://youtu.be/Kyc\_Z\_2b2Hc)

\


</details>

<details>

<summary><strong>Методы отладки React</strong></summary>

* React devtools поставляется в двух видах
  * отдельным пакетами
  * расширением для популярных браузеров. В расширении можно увидеть изменения состояний приложения и узлы виртуального DOM-дерева.
* console.log() Иногда хочется отлаживать по старинке, с помощью console.log(). Можно получить значение переменной внутри JSX прямо в точке её применения. \<img src={console.log('logo', logo) || logo} /> Как это работает: console.log() вернет undefined и код выполнится дальше по условию "||", а в консоли браузера мы увидим искомое значение, например: "/static/media/logo.5d5d9eef.svg".
* (() => { debugger })() || // anything
* Отладка внутри IDE WebStorm
  * Установите расширение Chrome — JetBrains IDE Support.
  * Добавьте Run/Debug-конфигурацию.
  * Запустите create-react-app через терминал командой: $ yarn start
  * Выберите конфигурацию Debug и нажмите кнопку с иконкой жука (в правом верхнем углу IDE)
  * Откроется браузер с предупреждением "JetBrains IDE Support отлаживает этот браузер". Замечено, что если теперь открыть Chrome DevTools по \[F12], то отладка в WebStorm завершится — не надо этого делать)
  * можно отметить нужную строчку кода, как точку останова, затем перегрузить страницу браузера по \[F5], и получить желаемое — инструмент отладки внутри WebStorm.

**Ссылки**

* [IT-Kamasutra #91 - chrome extensions для react и redux - React JS](https://youtu.be/K2DB3B9PU9Q)

\


</details>

<details>

<summary><strong>Быстродействие и оптимизация React</strong></summary>

**Как оптимизировать рендер компонента**

* shouldComponentUpdate — метод жизненного цикла классового компонента, если он вернет false то рендер не будет запущен
* React.PureComponent — класс, реализующий типовой shouldComponentUpdate.
* React.memo — HOC, который предотвращает повторный рендер, если входные props не изменились
* useMemo() — чтобы в функциональном компоненте сохранить ссылки на объекты между рендерами
* useCallback() — чтобы в функциональном компоненте сохранить ссылки на объекты между рендерами
* аттрибуты key
* Context /useContext() - Context API обеспечивает передачу переменных в дерево компонентов, без их непосредственной передачи в props данных компонентов.
* оптимизация структуры компонет - помещать логику ближе к месту использования данных\


\


**Какие хуки использовать для оптимизации рендера**

* useMemo() — чтобы в функциональном компоненте сохранить ссылки на объекты между рендерами
* useCallback() — чтобы в функциональном компоненте сохранить ссылки на объекты между рендерами
* useContext() - Context API обеспечивает передачу переменных в дерево компонентов, без их непосредственной передачи в props данных компонентов.\


\


**Изменение параметров функции, side-эффекты и cloneDeep**

Никогда, никогда, никогда в жизни не делайте так! Изменения параметров функции это зашквар если честно - это сразу +50% к появлению сайд эффектов. Изменять параметры функции можно только в одном случае, если у вас рекурсия и вы изменяете объект.

Хотите такой же объект, делайте копию. Есть крутая штука, cloneDeep у lodash Пользуйтесь ей - это сразу избавил вас от неожиданных последствий

Оптимизацию react приложений, я заставляю изучать всех, с кем в проектах участвую. Это сейчас «must have»\
\


**Side-эффекты в методах жизненного цикла**

В `ComponentDidMount` мы имеем право сделать сайд-эффект Сайд-эффектами являются запросы на сервер, асинхронные операции, setTimeout, обращения к DOM-элементам напрямую В результате компонента будет перерисована, и будет вызван уже не ComponentDidMount, а ComponentDidUpdate

В `ComponentDidUpdate` мы имеем право сделать сайд-эффект, но уже с неким условием, которое позволить его в какой-то момент прекратить.\
Потому что в результате будет вызвана перерисовка компоненты, снова вызван ComponentDidUpdate... И если нет условия - получим цикл, и приложение зависнет\
\


**Props и производительность**

Основная опасность - увеличение количества render, которые мешают производительности

Важно: при вызове render() перерисовывается не только родительский компонент, но и все дочерние (хотя, в них свойства могли и не поменяться). Т.е. если у родительского компонента внутри render есть дочерние компоненты - они будут перерисовываться. Соответственно, если мы вызываем render на родительском компоненте - перерисуем всё приложение. Чтоб решить этот вопрос - используем создание компонента от PureComponent

Даже если я создал класс от PureComponent - это не гарантирует отсутствие лишних ренедров при тех же данных. Одна из причин - анонимные функции (они при каждом рендере новые). Неверно:

```
render() {
  return <Component onClick= {() => this.hangleClick}>
}
```

Верно:

```
handleClick = () => {...}
render() {
  return <Component onClick= {this.hangleClick}>
}
```

То же самое с объектами - не создаём их прямо в функции, а подключаем как константу\
Неверно:

```
  render(){
    return <Component test= {{a: 1}}>
  };
```

Верно:

```
  const obj = {a:1}
  render() {
    return <Component test= {obj}>
  }
```

**Ссылки**

* [YouTube - Какие props портят производительность](https://www.youtube.com/watch?v=zSDOxWhPG\_U)

***

**Ссылки**

* [Гайд по оптимизации веб- приложений в 2017](https://medium.com/@abraztsov/%D0%B3%D0%B0%D0%B9%D0%B4-%D0%BF%D0%BE-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-5684280a445d)
* [Habr -](https://habr.com/ru/company/ruvds/blog/455505/)
* [Habr -](https://habr.com/ru/company/ruvds/blog/442650/)
* [Habr -](https://habr.com/ru/company/ruvds/blog/343888/)
* [Habr -](https://habr.com/ru/company/ruvds/blog/426053/)
* [Habr -](https://habr.com/ru/company/ruvds/blog/340034/)
* [CSSSR - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
* [Habr - Оптимизация производительности в React](https://habr.com/ru/post/319536/)
* [Habr - Несколько способов оптимизировать React-Redux приложение](https://habr.com/ru/post/490526/)
* [Habr - Как организовать большое React-приложение и сделать его масштабируемым (2017)](https://habr.com/ru/company/nix/blog/329060/)
* [IT-Kamasutra #87 - shouldComponentUpdate, PureComponent, memo](https://youtu.be/YEqCI9NMoLI)
* [см. раздел «Redux» - Быстродействие и оптимизация Redux](redux.md)

**Ссылки**

* [Оф. документаця - Rendering](https://ru.react.js.org/docs/rendering-elements.html)
* [Руководство по рендеренгу в React](https://www.bxnotes.ru/conspect/lib/react/react-notes/rendering/)
* [Когда React выполняет повторный рендеринг компонентов?](https://webformyself.com/kogda-react-vypolnyaet-povtornyj-rendering-komponentov/)
* [Визуальное руководство по состоянию в React](https://tuhub.ru/posts/vizualnoe-rukovodstvo-po-sostoyaniyu-v-react)

\


</details>

<details>

<summary><strong>Архитектура React-приложения. Ducks</strong></summary>

Метод организации Redux-кода в приложении.\
Позволяет собрать код, относящийся к управлению состоянием, в одном месте.

Общий принцип:

* стараемся «не размазывать» Redux-логику по проекту.
  * ActionTypes, actions, reduce...
  * Всё что можно храним в папке компонента/фичи.
  * Обычно сохраняем в одном общем файле.
* чтобы вся функциональность имеющая отношение к фиче хранился в папке фичи. Не надо прыгать по куче файлов и папок — ускоряет работу, облегчает поиск.
* чтобы можно было взять папку с фичей из одного проекта и перенести в другой. Останется только чуть-чуть подправить структуру store, всё остальное перенесётся в папке

ActionTypes, actions, reduce объединяются в изолированный модуль, который является автономным.\
И даже может быть легко упакован в библиотеку.

Модуль

* Должен `export default` функцию с названием `reducer()`
* Должен `export` свои `action creators` как функции
* Должен содержать `action types` в форме `npm-module-or-app/reducer/ACTION_TYPE` (это про именование `action types`)
* Может экспортировать свои `action types` как UPPER\_SNAKE\_CASE, если внешний редьюсер должен их прослушивать или если это опубликованная повторно используемая библиотека.

То же самое рекомендуется для {actionType, action, reducer} пакеты, которые применяются как повторно используемые библиотеки Redux.

**Ссылки**

* [Ducks: Redux Reducer Bundles](https://github.com/erikras/ducks-modular-redux)
* [Habr - Масштабирование Redux-приложения с помощью ducks (2020)](https://habr.com/ru/company/otus/blog/492638/?ysclid=l6sz05stk7523793176)
* [Habr - Как организовать большое React-приложение и сделать его масштабируемым (2017)](https://habr.com/ru/company/nix/blog/329060/)
* [IT-Kamasutra - 90. Redux-ducks рефакторинг (YouTube)](https://youtu.be/JtbSOJKRJAI)
* \[Организация кода в масштабных React проектах.(2018)]\(https://blogru.4xxi.com/%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%
* [Medium - Проволочки при проектировании структуры React приложения](https://medium.com/@vladimirmorulus/%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-react-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-609f80105e2c)
* [Medium - The Ducks File Structure for Redux (2016)](https://medium.com/@scbarrus/the-ducks-file-structure-for-redux-d63c41b7035c)

\


</details>

<details>

<summary><strong>Ещё разное про React</strong></summary>

***

**React JS и React Native**

* React JS - js-библиотека для создания UI (2013)
* React Native - платформа для разработки мобильных приложений, создает мобильные приложения с помощью React.js (2015)

Мобильные приложения имеют некоторые преимущества по сравнению с сайтами. Их можно использовать без соединения с Интернетом. Они имеют доступ к таким возможностям устройства, как всплывающие уведомления. Также они позволяют быть в контакте с вашими пользователями в режиме 24/7. React Native — это фреймворк, который позволяет вам создавать мобильные приложения, используя React. Логика приложения пишется на JavaScript, таким образом, программисту не нужно отказываться от привычных приемов веб-разработчика. Все что нужно — научиться писать специфичный для устройства код, который адаптирует компоненты, ранее созданные для веб-сайта к новой среде обитания.

Если мы сравним затраты на разработку разных видов мобильных приложений, мы получим примерно следующие результаты:

* В случае с нативными приложениями вы можете надеяться на довольно высокую производительность, но стоимость разработки будет довольно высокой;
* Если вы предпочтете фреймворки, которые позволяют использовать HTML5, CSS3 и JavaScript, например PhoneGap, вы можете снизить стоимость. Но в этом случае уровень производительности будет гораздо ниже;
* В случае React вы можете достигнуть уровня производительности, сравнимого с нативными приложениями. При этом стоимость разработки сравнима с предыдущим примером.

Если вы планируете создать корпоративное веб-приложение и не вполне уверены, будет ли разработка мобильной версии этого же приложения хорошей идеей, вот что вы должны помнить. React Native позволяет использовать уже имеющуюся логику веб-приложения при создании мобильного приложения. Это значит, что команда разработчиков может использовать тот же код, который был использован в процессе создания сайта вместо того, чтобы начинать с чистого листа.

React.js использует Virtual DOM, в то время как React Native использует собственные API

* [React Native и React.js — что и как, в чем разница, где применять](https://webonrails.ru/post/react-native-i-react-js-chto-i-kak-v-chem-raznica-gde-primenjat/)

**Связывание данных**\
Связывание данных - функция, которая синхронизирует данные между состоянием (моделью) приложения и представлением.

* Односторонняя привязка данных - любое изменение модели автоматически обновляет представление. Но не наоборот.
* Двусторонняя привязка данных - любое изменение модели автоматически обновляет представление. И наоборот.

В React однонаправленная привязка - свойства передаются от родительских компонент к дочерним ("сверху вниз"). Состояние компонента инкапсулируется и недоступно для других компонентов. Если только оно не передается дочернему компоненту в качестве props (т.е. состояние компонента становится props дочернего компонента).

Компоненты получают свойства как неизменяемые (immutable) значения. Поэтому компонент не может напрямую изменять свойства, но может вызывать изменения через callback функции. Такой механизм называют «свойства вниз, события наверх».

**Рендеринг на стороне сервера**\


* Рендеринг на стороне сервера - браузер шлёт серверу запрос, сервер присылает весь HTML-файл. Браузер только выводит его пользователю.
* Рендеринг на стороне клиента - браузер запрашивает у сервера много JS и сырые данные из базы. Генерация HTML идёт в браузере (клиенте).

Рендеринг на стороне клиента имеет недостатки, например плох для SEO. Поэтому можно настроить React для рендеринга на сервере. React может выполняться на стороне клиента и, при этом, рендерится на стороне сервера, и эти части могут взаимодействовать друг с другом. Поэтому он широко используется для создания высокопроизводительных веб-приложений и пользовательских интерфейсов.

React может рендерить компоненты сайта как на серверной, так и на клиентской стороне. Хорош для создания изоморфных приложений - позволяет переиспользовать почти весь клиентский код для рендеринга на сервере, в зависимости от масштаба приложения. Это возможно т.к.: 1) и на сервере и на клиенте используется JS; 2) и там и там не критичен реальный DOM браузера - сам React работает с виртуальным.

**Изоморфность**\
При первом обращении к сайту все операции выполняются на сервере и в браузер передается HTML (как обычный статический сайт). После загрузки JS сайт превращается в «одностраничное приложение», и работает соответственно.

Это полезно для SEO + пользователи сразу видят страницу, а не ждут пока загрузятся все данные и отрисуется нужная информация

Когда пользователь открывает сайт, содержимое страницы должно быть загружено с сервера. В случае с SPA это может занять некоторое время. Во время загрузки пользователи видят либо пустую страницу, либо анимацию загрузки. Учитывая, что по современным стандартам ожидание в течение более чем двух секунд может быть весьма заметным неудобством для пользователя, сокращение времени загрузки может оказаться крайне важным.

Virtual DOM позволяет React легко создавать изоморфные приложения. В других JS-фрэймворках клиентская часть кода часто полагается на DOM браузера, которого нет на серверной стороне => нельзя использовать один код и на клиенте, и на сервере. React же дает нам абстракцию браузерного DOM'а в виде виртуального DOM'а.

Это дает два основных преимущества:

* код, который работает с виртуальным DOM в React не зависит от браузера и может выполняться на сервере;
* React может оптимизировать операции над документами и снизить количество обращений к браузерному DOM и за счет этого значительно ускорить работу фронтенда.

Одной из основных особенностей React является то, что он может выполняться на стороне клиента и, при этом, рендериться на стороне сервера, и эти части могут взаимодействовать друг с другом. Поэтому он широко используется для создания высокопроизводительных веб-приложений и пользовательских интерфейсов.

[Habr - Техники повторного использования кода и разбиения сложных объектов на составные](https://habr.com/ru/post/545368/)

\


</details>

<details>

<summary><strong>Ссылки</strong></summary>

* [Офф. сайт](https://ru.reactjs.org/)
* [Блог Дэна Абрамова (en)](https://overreacted.io/)
* [Агапов Е - База знаний в GitHub](https://github.com/harryheman/my-js)
* [Агапов Е - База знаний на my-js.org](https://my-js.org/)

**Курсы**

* [Reactjs.org (офф. сайт) - учебный курс](https://ru.reactjs.org/tutorial/tutorial.html)
* [IT-Kamasutra - курс «React JS. Путь самурая (часть 1)» (YouTube). Лучший учебный курс, 100 уроков](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8)
* [IT-Kamasutra - курс «React JS. Путь самурая (часть 2)» (YouTube)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM3z1XqMw0kPuxpbyMo3HvN)
* [LearnJS - Курс](https://learn.javascript.ru/screencast/react)
* [Code.mu - Курс](http://code.mu/ru/javascript/framework/react/book/prime/)
* [Bob Ziroll (habr) - учебный курс (27 статей, ru)](https://habr.com/ru/company/ruvds/blog/432636)
* [Hexlet - курсы React](https://ru.hexlet.io/courses/js-redux-toolkit/lessons/data-normalization/theory\_unit)
* [Monsters - курс](https://monsterlessons.com/project/series/react-dlya-nachinayushih)
* [FDS - курс (6 месяцев)](https://ptchk.typeform.com/to/qZXOYF)

**IT-Kamasutra (YouTube)**

* [IT-Kamasutra - ReactJS - Путь Самурая 2.0 (YouTube, 23 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM3z1XqMw0kPuxpbyMo3HvN)
* [IT-Kamasutra - JS+React для Juniors (YouTube, 4 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DMuHec4RCfGuMwiij2\_IvFR)
* [IT-Kamasutra - React JS - путь самурая 1.0 (YouTube)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8)
* [IT-Kamasutra - GIT (YouTube, 2 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DPgk3pH7vDxoMh2C5fM8fXP)
* [IT-Kamasutra - JS в деталях (YouTube, 48 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DN2nTU8Q10SvAn4k8NpMJvh)
* [IT-Kamasutra - Уроки JavaScript с нуля (YouTube, 29 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DPD5sRK3lw4bjBsKdgY2bPi)
* [IT-Kamasutra - React - Кабзда как подробно (YouTube, 3 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM49Jb2XZSf4READ3kO4UFL)
* [IT-Kamasutra - Todolist - React, TypeScript (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DMM8zDacOPhWfVitvOa\_Fhu)
* [IT-Kamasutra - Ajax в деталях (YouTube, 9 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNDDIp2MGbv8cMYsoUO1lew)
* [IT-Kamasutra - addEventListener в деталях (YouTube, 4 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNwI9PyQ\_IFW\_dLpqBIuIyu)
* [IT-Kamasutra - react-четверг (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DN-JSjyJDFtGdRlsapKDpp9)
* [IT-Kamasutra - JavaScript для собеседований (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DMu\_yc4R9btXnbbn4XqEwWj)
* [IT-Kamasutra - TypeScript Камасутра (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM6f9AdaI8bUctNuGiAYKpO)
* [IT-Kamasutra - React English (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DOOi7Wqsv7ia5GJ\_S9YlfDg)

**Best practices**

* [Паттерны React](https://habr.com/ru/post/309422/)
* [Гайд как писать на React в 2017](https://medium.com/@abraztsov/%D0%B3%D0%B0%D0%B9%D0%B4-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BD%D0%B0-react-%D0%B2-2017-8128906dae80)
* [11 советов для тех, кто использует Redux при разработке React-приложений](https://habr.com/ru/company/ruvds/blog/456336/)
* [9 принципов, которые должен знать новичок в React.js](https://medium.com/@apolyntsev/9-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BD%D0%BE%D0%B2%D0%B8%D1%87%D0%BE%D0%BA-%D0%B2-react-js-454e964062b)
* [Почему не надо сохранять props в state](https://riptutorial.com/ru/reactjs/example/15854/%D0%BE%D0%B1%D1%89%D0%B8%D0%B9-%D0%B0%D0%BD%D1%82%D0%B8%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD)
* [Как не надо писать React: неправильные шаблоны и проблемы в React](https://webformyself.com/kak-ne-nado-pisat-react-nepravilnye-shablony-i-problemy-v-react/)
* [Яндекс - Разработка фичи: как эффективно пройти путь от идеи до реализации](https://academy.yandex.ru/journal/razrabotka-fichi-kak-effektivno-projti-put-ot-idei-do-realizacii)
* [Medium - Проволочки при проектировании структуры React приложения](https://medium.com/@vladimirmorulus/%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-react-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-609f80105e2c)

\


</details>

\
\


[_Legmo, 2019-2022_](https://github.com/Legmo/notes/)
