<h1>GIT</h1>

[//]: # (Основные понятия)
<details><summary><h3>Основные понятия</h3></summary><p>

- **Система контроля версий** (Version Control System) — программное обеспечение, помогающее разработчикам управлять состоянием исходного кода на протяжение всей разработки. Система, которая записывает ваши изменения в файл и позже позволяет откатиться к более ранней версии проекта. Также помогает команде эффективно работать надо одними и теми же файлами и синхронизировать свои изменения.
  - бывают `распределенные` и `централизованные` (репозиторий хранится на сервере, вносить правки можно только в него, чреез спец. клиента). GIT - распределенный
- **GIT** (Global Information Tracker) — разработан Линусом Торвальдсом для управления разработкой ядра Linux.
- **Принцип хранения в GIT** — Git хранит полные копии файлов, только заменяя неизмененные файлы на ссылки (многие другие системы хранят только список изменения)
  - Т.е. Git является небольшой файловой системой.
  - Преимущества подхода — при восстановлении данных, работе с комитами и т.д.
  - Недостатки подхода — требует больше места.
- **Repository** — место, где Git хранит метаданные и базу данных объектов вашего проекта.
  - Git хранит все изменения в скрытой папке `.git`, которая есть в каждом проекте, находящемся под контролем VCS.
- **Working Directory** — извлечённая из базы копия определённой версии проекта.
- **Staging Area** (index) — файл c информацией о том, что должно войти в следующий коммит. Хранится в репозитории Git
  - когда я выполняю `git add .` — я добавляю данные в index/Staging Area
- **Tree** — объект (бинарный файл), который представляет директорию.
    - Хранит ссылки к блобам и деревьям, также указывается SHA1 хэшом.
- **Commit** — содержит текущее состояние репозитория.
    - Как и дерево или блоб, коммит хранится в виде SHA1 хэша.
    - Можно понимать коммит, как узел в связном листе.
    - Каждый коммит имеет указатель на своего предка-коммита.
    - Коммит может имет несколько указателей на несколько предков - это значит, что он был создан слиянием веток.
- **Branch** — используется для создания новой ветки разработки.
- **Tag** — обозначает значимое имя с указанной версией в репозитории.
    - Теги очень похожи на ветки, но отличие в том, что они неизменяемы. Если сделать тег для коммита, то даже если создать новый коммит от данного, то он не обновится.
- **HEAD** - указатель/ссылка, обычно указывает на последний комит в текущей ветке.
    - Когда вы делаете комит, то HEAD перемещается на него.
    - HEAD можно переместить на любой другой объект кроме комита.
    - `ORIG_HEAD` - предыдущее состояние HEAD.
    - git reset - передвигает HEAD в указанное состояние
    - `detached HEAD` — состояние открепленного указателя HEAD. 
      - Может возникнуть при `git checkout`, если переключиться на коммит.
      - При стандартном процессе разработки указатель HEAD обычно указывает на главную ветку main или другую локальную ветку. Но при переключении на предыдущий коммит HEAD указывает уже не на ветку, а непосредственно на сам коммит. Такая ситуация называется состоянием «открепленного указателя HEAD». Переход к старой версии файла не перемещает указатель HEAD. Он остается в той же ветке и в том же коммите, что позволяет избежать открепления указателя HEAD. После этого можно выполнить коммит старой версии файла в новый снимок состояния, как и в случае других изменений. Соответственно, такое использование команды git checkout применительно к файлу позволяет откатиться к прежней версии отдельного файла.
      - Переход к отдельному коммиту переведет репозиторий в состояние открепленного указателя HEAD. Работа при этом перестает принадлежать какой-либо из веток. При открепленном указателе HEAD все новые коммиты будут оставаться без родителя, пока вы не вернете ветки в положенное состояние. «Сборщик мусора» в Git удаляет коммиты без родителя. Этот сервис работает с определенными интервалами и удаляет такие коммиты без возможности восстановления. Чтобы такие коммиты не были удалены «сборщиком мусора», перед их выполнением нужно убедиться, что мы работаем в ветке.
      - Сообщение «detached HEAD» предупреждает о том, что вся текущая работа «откреплена» от остальной части вашего проекта. Если вы начнете разрабатывать функцию, находясь в состоянии открепленного указателя HEAD, у вас не будет ветки, которая позволила бы вам вернуться к этой функции. Когда вы неизбежно переключитесь на другую ветку (например, чтобы слить код своей функции), вы уже никак не сможете сослаться на свою функцию:

<br></p>
</details>

[//]: # (Популярные операции)
<details><summary><h3>Популярные операции</h3></summary><p>

- `git merge` — соединяет две или более истории в одну.
  - объединяет две или более «историй разработки». Сохраняет историю в первозданном виде
- `git rebase` — переносит локальные комиты в указанное положение в дереве.
  - повторно применяет коммиты поверх другой базовой ветки. Перезаписывает историю
- `git cherry-pick` — переносит изменения, представленные в указанных комитах.
  - Если ведется сложная история разработки, с несколькими длинными ветками
  разработками, может возникнуть необходимость в применении изменений, внесенных
  отдельным коммитом одной ветки, к дереву другой (активной в настоящий момент).
- `git reset` — передвигает HEAD в указанное состояние
  - позволяет откатить проект до определенной точки.
  - в зависимости от параметра прокидывает нас в истории проекта с соответствующими состояниями индекса.
  - можно использовать с тремя параметрами:
    - `git reset --soft <commit>`
      - Содержимое вашего индекса, а также рабочей директории, остается неизменным. 
      - мы изменим ссылку указателя HEAD на указанный коммит и все изменения, которые были до этого внесены, окажутся в индексе.
    - `git reset --mixed <commit>`
       - мы изменим ссылку указателя HEAD, но все предыдущие изменения в индекс не попадут, а будут отслеживаться как не занесенные в индекс. 
       - Дает возможность внести в индекс только те изменения, которые нам необходимы, что довольно удобно!
    - `git reset --hard <commit>` 
      - мы изменим ссылку указателя HEAD, но все предыдущие изменения не попадут ни в индекс, ни в зону отслеживаемых файлов. 
      - Мы полностью сотрем все изменения, которые вносили ранее.

- `git init` — создание пустого репозитория или переинициализация существующего.
- `git clone` — операция клонирования репозитория.
- `git add` — операция индексирования файла (сообщаю Git какие изменения надо внести в историю).
  - Пока я не сделал `git add` — файл считается «неотслеживаемым». Изменения в нём не попадут в следюущий коммит
- `git commit` — записывает изменения в репозиторий (в историю проекта).
- `git status` — операция вывода статуса текущего working tree.
  - Показывает какие файлы в проекте отслеживаются Git и какие изменения будут включены в следующий коммит
- `git branch` — выводит, создает или удаляет ветки.
- `git checkout` — переключается между элементами или откатывает изменения в файлах в рабочей директории.
  - подразумевают переключение между различными версиями целевого объекта (файл, коммит или ветка) 
  - откатывает изменения в файле.
  - переходит на указанный объект, например ветку
  - По сути дела просто обновляет указатель HEAD, чтобы он ссылался на указанную ветку или коммит.
  - `detached HEAD` — состояние открепленного указателя HEAD.
    - Может возникнуть при `git checkout`, если переключиться на коммит.
    - При стандартном процессе разработки указатель HEAD обычно указывает на главную ветку main или другую локальную ветку. Но при переключении на предыдущий коммит HEAD указывает уже не на ветку, а непосредственно на сам коммит. Такая ситуация называется состоянием «открепленного указателя HEAD». Переход к старой версии файла не перемещает указатель HEAD. Он остается в той же ветке и в том же коммите, что позволяет избежать открепления указателя HEAD. После этого можно выполнить коммит старой версии файла в новый снимок состояния, как и в случае других изменений. Соответственно, такое использование команды git checkout применительно к файлу позволяет откатиться к прежней версии отдельного файла.
    - Переход к отдельному коммиту переведет репозиторий в состояние открепленного указателя HEAD. Работа при этом перестает принадлежать какой-либо из веток. При открепленном указателе HEAD все новые коммиты будут оставаться без родителя, пока вы не вернете ветки в положенное состояние. «Сборщик мусора» в Git удаляет коммиты без родителя. Этот сервис работает с определенными интервалами и удаляет такие коммиты без возможности восстановления. Чтобы такие коммиты не были удалены «сборщиком мусора», перед их выполнением нужно убедиться, что мы работаем в ветке.
    - Сообщение «detached HEAD» предупреждает о том, что вся текущая работа «откреплена» от остальной части вашего проекта. Если вы начнете разрабатывать функцию, находясь в состоянии открепленного указателя HEAD, у вас не будет ветки, которая позволила бы вам вернуться к этой функции. Когда вы неизбежно переключитесь на другую ветку (например, чтобы слить код своей функции), вы уже никак не сможете сослаться на свою функцию.
    - Всегда ведите разработку на ветке, а не на открепленном указателе HEAD. Это гарантия того, что у вас всегда будет ссылка на ваши новые коммиты. Вместе с тем при просмотре предыдущего коммита состояние указателя HEAD не имеет значения: он может быть как откреплен, так и нет.
- `git stash` — прячет, достает, очищает изменения в рабочей директории. Что-то вроде «буфера обмена»
- `git fetch` — загружает историю из указанного репозитория.
- `git pull` — загружает историю из указанного репозитория и сливает ее с локальной историей.
- `git push` — загружает историю в удаленный репозиторий.
- `git remote` — управляет набором отслеживаемых репозиториев.
- `git reflog` — управляет reflog информацией.  
  - Выводит упорядоченный список коммитов, на которые указывал HEAD. Отображает историю всех ваших перемещений по проекту.
  - Хранит свою информацию на вашей машине отдельно от коммитов, поэтому при удалении чего-либо в истории, в сможете это найти в git reflog.
  - Если вы вдруг случайно удалили часть истории или откатились назад, вы сможете проинспектировать момент утраты нужной вам информации и откатиться обратно.
- `git revert` — отменяет существующие комиты.
- `git clean` — удаляет неиндексированные файлы из рабочей директории.

- **Ссылки**
  - [Конспект по GIT](https://gist.github.com/vchernogorov/030144a7b0832c683adc3e0b502ad3e5)

<br></p>
</details>

[//]: # (Как отменять изменения)
<details><summary><h3>Как отменять изменения</h3></summary><p>

- `git checkout` — 
  - перехожу на нужный коммит (`git checkout a1e8fb5`)
  - создаю от него новую ветку с этими данными, работаю в ней (`git checkout -b new_branch_without_some_commit`)
  - Теперь репозиторий находится на новой временной шкале, где коммита 872fa7e не существует. На этом этапе мы можем продолжить работу в новой ветке, где коммита 872fa7e не существует и его можно считать «отмененным». 
  - К сожалению, если вам нужна предыдущая ветка (возможно, это главная ветка main), такая стратегия не подходит.
- `git revert` — Git создаст новый коммит с операцией, обратной последнему коммиту.  
  - В текущую историю ветки будет добавлен новый коммит
  - В отличие от нашей предыдущей стратегии переключения с помощью команды checkout, мы можем продолжить работать с этой же веткой, поэтому данная стратегия является удовлетворительной. Это идеальный способ отмены при работе в открытых общих репозиториях, однако если у вас есть требование вести минимальную «очищенную» историю Git, эта стратегия может не подойти.
- `git reset` — 
  - Если мы выполним команду `git reset --hard a1e8fb5`, история коммитов будет сброшена до указанного коммита.
  - Этот метод отмены изменений оставляет историю максимально чистой. 
  - Отлично подходит для локальных изменений, но при работе в общем удаленном репозитории создает сложности. 
  - Если у нас есть общий удаленный репозиторий, в котором с помощью команды push опубликован коммит 872fa7e, и мы попытаемся выполнить команду git push для ветки, в которой с помощью команды reset была сброшена история, система Git обнаружит это и выдаст ошибку. Git будет считать, что публикуемая ветка не была обновлена, поскольку в ней отсутствуют коммиты. В таких случаях лучше использовать отмену с помощью команды git revert.
- `git commit --amend` — внести правки в последний коммит

- **Ссылки**
- [atlassian — Отмена коммитов и изменений ](https://www.atlassian.com/ru/git/tutorials/undoing-changes)

<br></p>
</details>


[//]: # (Rebase)
<details><summary><h3>Merge и Rebase</h3></summary><p>

**Merge** (слияние)
- объединяет две или более историй разработки
- Сохраняет историю в первозданном виде
- на графике истории репозитория будет видна другая ветка — история нелинейная


**Rebase** (перебазирование)
- повторно применяет коммиты поверх другой базовой ветки. 
- Перезаписывает историю
- графике истории выглядит одной линией

Способ объединить изменения, сделанные в одной ветке, с другой веткой.<br>
Альтернатива `merge`.<br>

Последовательно берет все коммиты из выбранной ветки и заново применяет их к новой ветке.<br>

Результат:
- Переприменяя коммиты, Git создает новые коммиты. Даже если они содержат те же изменения, то рассматриваются Git как
  новые и независимые коммиты.
- Git rebase переприменяет коммиты и не удаляет старые. После выполнения rebase ваши старые коммиты продолжат храниться
  в .git.

**Отличие от merge**

- `rebase` - повторно применяет коммиты поверх другой базовой ветки. Перезаписывает историю
- `merge` - объединяет две или более «историй разработки». Сохраняет историю в первозданном виде

**Ссылки**

- [Владеешь merge  -  освой и rebase](https://nuancesprog.ru/p/12275/?ysclid=lisjrgqkui717486146)
- [Git Rebase: руководство по использованию](https://habr.com/ru/post/161009/)
- [Git Rebase для начинающих](https://habr.com/ru/post/337302/)

<br></p>
</details>



[//]: # (Squash)
<details><summary><h3>Squash</h3></summary><p>

- Берём серию коммитов и «уплотняем», сжимаем ее.<br>
- Серию из N коммитов преобразуем в один коммит.

- Применяется, чтобы превратить большое число малозначимых коммитов в небольшое число значимых. Так легче отслеживать
историю Git.

- Также этот прием используется при объединении ветвей. Чаще всего вам будут советовать всегда сжимать коммиты и выполнять
перебазирование с родительской ветвью (например, master или develop). В таком случае история главной ветки будет
содержать только значимые коммиты, без ненужной детализации.

**Ссылки**

- [Как сжимать коммиты в Git с помощью git squash](https://medium.com/nuances-of-programming/%D0%BA%D0%B0%D0%BA-%D1%81%D0%B6%D0%B8%D0%BC%D0%B0%D1%82%D1%8C-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B-%D0%B2-git-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-git-squash-8a84b9f62734)

<br></p>
</details>



[//]: # (Методологии работы с GIT ,workflow)
<details><summary><h3>Методологии работы с GIT (workflow)</h3></summary><p>

- [Кратко о git-flow](http://ruwhynot.com/2016/03/08/briefly-about-gitflow/)
- [В чём состоит отличие между различными workflow?](https://ru.stackoverflow.com/questions/676514/%D0%92-%D1%87%D1%91%D0%BC-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D0%BC%D0%B8-workflow)
- [Модели ветвления в Git: какую выбрать?](https://proglib.io/p/git-workflow)
- [Оригинальная статья Vincent Driessen с описанием модели GitFlow (перевод на русский)](https://habr.com/ru/post/106912/)

- [atlassian.com - Рабочий процесс Gitflow Workflow ](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow)
- [atlassian.com - Магистральная разработка (Trunk based development)](https://www.atlassian.com/ru/continuous-delivery/continuous-integration/trunk-based-development)

<br></p>
</details>

[//]: # (Про текстовый редактор для коммитов)
<details><summary><h3>Про текстовый редактор для коммитов</h3></summary><p>

- Я использую nano

**Ссылки**

- [stackoverflow - Замена дефолтного редактора кода в git (ru)](https://ru.stackoverflow.com/questions/437331/%D0%97%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0-%D0%B4%D0%B5%D1%84%D0%BE%D0%BB%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B0-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B2-git)
- [Связывание текстового редактора с Git](https://ymatuhin.ru/tools/git-default-editor/)

<br></p>
</details>

**Ссылки**

- [Wikipedia - GIT](https://ru.wikipedia.org/wiki/Git)
- [GIT Book (ru)](https://git-scm.com/book/ru/v2)
- [Pro Git (ru)](http://www.linuxcookbook.ru/books/progit/index.html)
- [Хабр - Git. Коротко о главном](https://habr.com/ru/post/588801/)
- [Hexlet - Что такое Git и для чего он нужен](https://guides.hexlet.io/ru/git-guide/)
- [GIT за полчаса](https://proglib.io/p/git-for-half-an-hour)
- [Конспект по GIT](https://gist.github.com/vchernogorov/030144a7b0832c683adc3e0b502ad3e5)
- [GeekBrains - Git. Базовый курс (бесплатный)](https://gb.ru/courses/1117)
- [GeekBrains - Git. Базовый курс (бесплатный, YouTube)](https://www.youtube.com/playlist?list=PLmRNNqEA7JoM77hOJkPrLOfJQGizCLR3P)
- [Хабр - Поддержание аккуратной истории в Git с помощью интерактивного rebase](https://habr.com/ru/company/flant/blog/536698/)
- [Как сжимать коммиты в Git с помощью git squash](https://medium.com/nuances-of-programming/%D0%BA%D0%B0%D0%BA-%D1%81%D0%B6%D0%B8%D0%BC%D0%B0%D1%82%D1%8C-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B-%D0%B2-git-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-git-squash-8a84b9f62734)
- [Habr - Git Wizardry (краткое введение в Git)](https://habr.com/ru/post/60347/?ysclid=l6y8sw0gaj91345487)

- [atlassian.com - Изучите Git с помощью Bitbucket Cloud ](https://www.atlassian.com/ru/git/tutorials/learn-git-with-bitbucket-cloud)
- [atlassian.com - Рабочий процесс Gitflow Workflow ](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow)
- [atlassian.com - Магистральная разработка (Trunk based development)](https://www.atlassian.com/ru/continuous-delivery/continuous-integration/trunk-based-development)
- [Чёрт побери, Git!?!](https://dangitgit.com/ru)

<br>
<br>
*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*