<h1>Объектно Ориентированное Программирование</h1>


[//]: # (ООП - Основные понятия)
<details><summary><b>ООП - Основные понятия</b></summary><p>

- **Объектно-ориентированное программирование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.
- 
- **Основные понятия**
  - **Класс** - абстрактное описание автомобиля. Чертёж
  - **Объект** - конкретная реализация автомобиля, данная машина
  - **Свойства** - характеристики харакерные для всех машин. Количество колес, цвет, количество бензина...
  - **Методы** - команды, на которые может реагировать машина. По сути функции, которые может вызывать каждый объект.
  - **Геттеры и сеттеры** - спец. методы, для добавления/получения свойств объекта (чтоб не использовать приватные
    свойста)
- 
- **Разные модели (подходы) ООП**
  - Компонентно-ориентированное программирование
  - Прототипно-ориентированное программирование
  - Агентно-ориентированное программирование
- 
- **Шаблоны проектирования "банды четырёх" GoF**
  - [Legmo Notes - Шаблоны проектирования](Pattern.md)
  - [Habr - Шпаргалка по шаблонам проектирования](https://habr.com/ru/post/210288/)
- 
- **Ссылки**
  - [code.mu - на пальцах](http://code.mu/books/javascript/oop/)
  - [code.mu - тоже на пальцах](http://code.mu/books/php/oop/osnovy-raboty-s-objektno-orientirovannym-programmirovaniem-v-php-1.html)
  - [Habr - на пальцах 1](https://habr.com/ru/post/87205/)
  - [Habr - на пальцах 2](https://habr.com/ru/post/87119/)
  - [Что такое ООП в паре слов](https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija)
  - [Habr - Понимание ООП в JS](https://habr.com/ru/company/enterra/blog/153365/)
  - [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Details_of_the_Object_Model)
  - [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
  - [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

<br></p>
</details>

[//]: # (ООП - Базовые принципы )
<details><summary><b>ООП - Базовые принципы </b></summary><p>

- `Наследование
  - механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом. Нужно, прежде всего, для повторного использование кода. Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
- `Абстракция`
  - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных. Для каждого объекта мы задаём минимальное количество методов, полей и описаний, которые позволят решить задачу. Чем меньше характеристик, тем лучше абстракция, но ключевые характеристики убирать нельзя.
- `Инкапсуляция`
  - ограничение доступа к данным и возможностям их изменения. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
- `Полиморфизм`
  - возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.
  - Свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
  - Пример: реализуем в системе два разных класс, которые имеют метод getData - один с диска, другой из сети. При необходимости переключаем их. В других частях системы мы обращаемся к getData() и не думаем, как именно и откуда получаются данные — на этом уровне нам не важно. Интерфейс одинаковый, внутренняя релаизация разная.
  - Способность объекта использовать методы производного класса, который не существует на момент создания базового.

<br></p>
</details>

[//]: # (ООП - Принципы SOLID)
<details><summary><b>ООП - Принципы SOLID</b></summary>

[//]: # (Single Responsibility Principle)
- <details><summary>Single Responsibility Principle (<b>Принцип единственной ответственности</b>)</summary><p>

  - Каждый класс должен решать лишь одну задачу.

  <br></p>
  </details>

[//]: # (Open-Closed Principle)
- <details><summary>Open-Closed Principle (<b>Принцип открытости-закрытости</b>).</summary><p>

  - Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

  <br></p>
  </details>

[//]: # (Liskov Substitution Principle )
- <details><summary>Liskov Substitution Principle (<b>Принцип подстановки Барбары Лисков</b>).</summary><p>

  - Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
  - Классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы.
  - Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

  <br></p>
  </details>

[//]: # (Interface Segregation Principle )
- <details><summary>Interface Segregation Principle (<b>Принцип разделения интерфейса</b>).</summary><p>

  - Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента.
  - Клиенты не должны зависеть от интерфейсов, которые они не используют.

  <br></p>
  </details>

[//]: # (Dependency Inversion Principle)
- <details><summary>Dependency Inversion Principle (<b>Принцип инверсии зависимостей</b>).</summary><p>

  - Объектом зависимости должна быть абстракция, а не что-то конкретное.
  - Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
  - Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

  <br></p>
  </details>

<br></p>
</details>

<br>
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*