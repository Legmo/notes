<h1>Общие вопросы программирования</h1>

[//]: # (Рекурсия)
<details id="recursion"><summary><b>Рекурсия</b></summary><p>

Рекурсия – это термин/приём в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть
использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые
делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Классические примеры рекурсии:

- возведение в степень
- числа Фибоначчи
- -факториал

**Возведение в степень**

```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert(pow(2, 3)); // 8
```

**Числа Фибоначчи**

```js
// Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.

function fib(n) {
  // return n <= 1 ? n : fib(n - 1) + fib(n - 2);
  if (n <= 1) {
    return n
  } else {
    return fib(n - 1) + fib(n - 2);
  }
}

alert(fib(3)); // 2
alert(fib(7)); // 13
```

**Рекурсивная структура данных**

Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой
себя. Например дерево HTML-элементов<br>
рекурсивные функции могут быть использованы для прохода по ним.

**Замена циклом**
Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для
многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.

Любая рекурсия может быть сведена к циклу, по сути это следует из тезиса Черча-Тьюринга любая функция, которая может
быть вычислена физическим устройством, может быть вычислена машиной Тьюринга; Принципиальное отличие рекурсии от цикла
состоит в наличии стека вызова - все локальные переменные и аргументы складываются в стек при каждом вызове рекурсивной
функции, а в цикле локальные переменные остаются "на месте".

Обычно рекурсивный алгоритм может быть заменён циклом и, если необходимо, вспомогательной структурой данных, чаще всего
стеком.

**Ссылки**

- [learn.javascript.ru - Рекурсия и стек](https://learn.javascript.ru/recursion)
- [Habr - Превращаем рекурсию в цикл](https://habr.com/ru/post/533034/)
- [learn.javascript.ru - Задачка на числа Фибоначчи](https://learn.javascript.ru/task/fibonacci-numbers)
- [code.tutsplus.com - Рекурсия в JavaScript](https://code.tutsplus.com/ru/tutorials/understanding-recursion-with-javascript--cms-30346)

<br></p>
</details>

[//]: # (Чистые функции)
<details><summary><b>Чистые функции</b></summary><p>

Детерминированная функция, которая не производит побочных эффектов.

Чистые функции — не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых
аргументов.

Чистая функция:

- `идемпотента` - при повторении операции даст тот же эффект
- `детерминирована` - для одних и тех же данных всегда выдаёт тот же результат
- `иммутабельна` - неизменяема. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
- без `сайд-эффектов` - без побочных эффектов. Например: какой-то внешний объект изменился, функция от него зависела, и
  при тех же входящих данных (которые мы напрямую передали при вызове функции) мы получили новый результат (т.к. она ещё
  взаимодействует с каким-то внешним объектом, который тоже меняется). Например, нельзя делать AJAX-запросы

**Почему важна `иммутабельность`**<br>
У нас ссылочный тип данных - функция изменит входящие данные, и они изменятся в объекте где хранятся (например объект в
памяти). Соответственно эти изменения могут вылезти где-то ещё. Один метод компонента случайно изменил данные, а другой
метод потом взял уже изменённые (хотя ему нужны были оригинальные)...

**Функция должна что-то возвращать**<br>
Функция не меняет никакие данные которые в ней пришли, и не меняет ничего во внешнем мире.<br>
Чтоб в такой функции был какой-то смысл - она должна что-то возвращать, делать return().

**Мутирующие и немутирующие методы**<br>
В JS особенно внимательно нужно относиться к массивам.<br>
Есть методы `мутирующие` и `немутирующие`.<br>

Примеры мутирующих методов:

- `push`
- `reverse`
- `splice`

Примеры немутирующих методов:

- `slice`

**Side-effect**<br>
Побочными эффектами называют любые взаимодействия с внешней средой. К ним относятся файловые операции, такие как запись
в файл, чтение файла, отправка или приём данных по сети и даже вывод в консоль.<br>
Кроме того, побочными эффектами считаются изменения внешних переменных (например, глобальных) и входных параметров в
случае, когда они передаются по ссылке.<br>
Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет логику
кода и тестирование. Приводит к возникновению огромного числа ошибок. Только при работе с файлами количество возможных
ошибок измеряется сотней: начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из
несуществующего файла. Для их предотвращения код обрастает большим числом проверок и защитных механизмов.<br>
Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их
результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически
приводит нас к побочным эффектам. В реальных же приложениях, обычно, все сводится к взаимодействию с базой данных или
отправкой запросов по сети.<br>
Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как
правило, в типичной программе побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в
самом начале и в конце.<br> Например, программа, которая конвертирует файл из текстового формата в PDF, в идеале
выполняет ровно два побочных эффекта:

- Читает файл в самом начале работы программы.
- Записывает результат работы программы в новый файл.<br>
  Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Побочные
  эффекты в таком случае будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу,
  останется чистым от них.<br>
  Инкремент и декремент — единственные базовые арифметические операции в JS, которые обладают побочными эффектами (
  изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут
  приводить к таким сложноотлавливаемым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python
  их нет). В JS стандарты кодирования предписывают их не использовать.

Примеры:

- Видоизменение входных параметров
- console.log
- HTTP вызовы (AJAX/fetch)
- Изменение в файловой системе
- Запросы DOM

**В ReactJS / Redux**<br>
Чистыми функциями должны быть:

- компоненты
- редьюсеры
- селекторы
  <br>

Пример чистой функции

```js
function sum(a, b) {
  return a + b;
}
```    

Пример нечистой функции (записывает данные в свои же аргументы)

```js
function withdraw(account, amount) {
  account.total -= amount;
}
```

**Ссылки**

- [IT-Kamasutra #88 - pure function (чистая функция)](https://youtu.be/KU81NnNcjmw)
- [Hexlet - Чистые функции](https://ru.hexlet.io/courses/js-functions/lessons/pure-functions/theory_unit)
- Смотри также в разделе «[React — Компоненты. Компоненты = чистые функции](/Pages/JS/React.md)»

<br></p>
</details>

[//]: # (Инкапсуляция)
<details><summary><b>Инкапсуляция</b></summary><p>

Сокрытие лишних деталей.

<br></p>
</details>

[//]: # (Идемпотентность)
<details ><summary><b>Идемпотентность</b></summary><p>

Повторное применение операции к объекту дает тот же результат, что и первое.<br>
Свойство объекта или операции.

<br></p>
</details>

[//]: # (Детерминированность)
<details><summary><b>Детерминированность</b></summary><p>

Результат однозначно определяется исходными данными.<br>
Для одних и тех же исходных данных алгоритм выдаёт тот же результат.

<br></p>
</details>

[//]: # (Иммутабельность)
<details><summary><b>Иммутабельность</b></summary><p>

Неизменяемость.<br>
Функция не меняет входящие данные. Делает копию, и работает уже с ней.

<br></p>
</details>

[//]: # (Интерфейс)
<details><summary><b>Интерфейс</b></summary><p>

Как мы взаимодействуем с чем-то.<br>
Интерфейс объекта - какие свойства и методы у него есть.<br>
Интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...

<br></p>
</details>

[//]: # (Декоратор)
<details><summary><b>Декоратор</b></summary><p>

Микропаттерн оптимизации функции — позволяет добавить дополнительное поведение функции, не изменяя ее.

**Ссылки**
* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [learn JS - Декораторы и переадресация вызова, call/apply](https://learn.javascript.ru/call-apply-decorators)

<br></p>
</details>

[//]: # (Debounce)
<details><summary><b>Debounce (Дебаунс)</b></summary><p>

"Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.<br>
Превращает несколько вызовов функции в течение определенного времени в один вызов.<br>
Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова.

Если дословно переводить — «устранение дребезга».

Возможны два варианта:

- Реальный вызов происходит только в случае, если с момента последней попытки прошло время, большее или равное задержке.
- Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет время, большее или
  равное задержке, отсчитанной от времени последней попытки.

**Зачем?**<br>
Обычно debounce используют, если исходная функция вызывается чаще, чем это требуется.<br>
Например, DOM-события mousemove, resize, scroll генерируют очень частые вызовы обработчиков, поэтому в ряде случаев было
бы полезно обернуть такие обработчики в debounce.<br>
Другое применение – контроль пользовательского ввода текста: если при изменении поля INPUT требуется передавать на
сервер текущее введенное значение, это может создать большое количество однотипных запросов, особенно если пользователь
печатает очень быстро. В этом случае тоже весьма кстати будет ограничить число вызовов обработчика с помощью
debounce.<br>
Функция debounce крайне полезна, когда дело доходит до производительности обработчиков событий.

Ссылки:

* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [Для чего нужна функция debounce и как она работает](http://gdrw.ru/reviews/tech/debounce-function-in-javascript)
* [learn.javascript.ru - реализация на js](https://learn.javascript.ru/task/debounce)
* [7 важных функций JavaScript](https://getinstance.info/articles/javascript/essential-javascript-functions/)

- [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)
- [learn.javascript.ru - Сделать Debounce](https://learn.javascript.ru/task/debounce)
- [doka - Сделать Debounce на примере формы поиска](https://doka.guide/js/debounce/)
- [Habr - Debouncing с помощью React Hooks](https://habr.com/ru/post/492248/)
- [Habr - Debouncing с помощью React Hooks: хук для функций](https://habr.com/ru/company/domclick/blog/510616/)

<br></p>
</details>

[//]: # (Throttling)
<details><summary><b>Throttling (Тротлинг)</b></summary><p>

Данный декоратор позволяет «затормозить» функцию — функция будет выполняться не чаще одного раза в указанный период,
даже если она будет вызвана много раз в течение этого периода. Т.е. все промежуточные вызовы будут игнорироваться.

Ссылки:

* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)

<br></p>
</details>

[//]: # (Мемоизация)
<details><summary><b>Мемоизация</b></summary><p>

Разновидность кэширования.<br>
Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша

Для того чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, всегда возвращать одни и те же
значения в ответ на одни и те же аргументы.

Мемоизация — это компромисс между производительностью и потреблением памяти. Мемоизация хороша для функций, имеющих
сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций,
задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.

Может показаться, что собственные реализации мемоизации стоит применять, например, при обращениях к неким API из
браузерного кода. Однако, делать этого не нужно, так как браузер автоматически кэширует их, используя, в частности,
HTTP-кэш.

Если вы работаете с React/Redux, можете взглянуть на **reselect**. Тут используется селектор с мемоизацией. Это
позволяет
выполнять вычисления только в том случае, если в соответствующей части дерева состояний произошли изменения.

Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления. Здесь
данная техника может значительно повысить производительность решения. Надо отметить, что нечто вроде вычисления
факториала или чисел Фибоначчи — это хорошие учебные примеры, но в реальном мире всё гораздо интереснее и сложнее.

**Ссылки**

- [https://habr.com/ru/company/ruvds/blog/332384/](https://habr.com/ru/company/ruvds/blog/332384/)

<br></p>
</details>

[//]: # (Анаморфизмы и катаморфизмы)
<details id="iterators"><summary><b>Анаморфизмы и катаморфизмы</b></summary><p>

**Анаморфизмы**

Функции, с помощью которых объекты разворачиваются в более сложные структуры, содержащие объекты того же типа.
```js
// Преобразование целого числа в ряд чисел:
function downToOne(n) {
  const list = [];

  for (let i = n; i > 0; --i) {
    list.push(i);
  }

  return list;
}

downToOne(5) // [ 5, 4, 3, 2, 1 ]
```
<br>
<br>

**Катаморфизмы**

Противоположность анаморфизмов: сворачивают объекты с более сложной структурой в простые.

```js
// Преобразование ряда чисел в одно
function product(list) {
  let product = 1;

  for (const n of list) {
    product = product * n;
  }

  return product;
}

product(downToOne(5)) // 120
```

<br>
<br>

Ссылки:

- [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#amrphcatmrph)

<br></p>
</details>

[//]: # (MVC для web)
<details><summary><b>MVC для web</b></summary><p>

`Model-View-Controller` (Модель-Вид-Контроллер)<br>
Конструкционный шаблон, архитектурный паттерн, концепция. 1979 г<br>
Описывает способ построения структуры приложения, сферы ответственности и взаимодействие каждой из частей в этой
структуре.

Основная идея: нужно чётко разделять ответственность за различное функционирование в наших приложениях.<br>
Делим приложение на 3 основных компонента, каждый отвечает за свои задачи.
Модификация каждого компонента может осуществляться независимо.

- `Model` - обработка данных и логика приложения
- `View` - представление данных пользователю (в любом формате). Пользовательский интерфейс
- `Controller` - обработка действий пользователя, вызов соответствующих ресурсов. Логика управления

Концепция стала популярна благодаря включению в две среды разработки: Struts и Ruby on Rails.

**Model**<br>
Для извлечения и манипуляций данными приложения.<br>
Данные и правила, которые используются для работы с данными.<br>
Содержит логику управления данными.

Только данные, которые должны быть обработаны в соответствии с правилами (дата не может указывать в будущее, e-mail
должен быть в определённом формате, имя не может быть длиннее Х символов, и так далее).

Даёт контроллеру представление данных, которые запросил пользователь (сообщение, страницу книги, фотоальбом, и тому
подобное). Модель данных будет одинаковой, вне зависимости от того, как мы хотим представлять их пользователю (таблицей,
списком...).

**View (Представление, Вид)**<br>
Отвечает за видимое пользователю отображение этих данных.
Применительно к web — формирует отдаваемый сервером браузеру пользователя HTML/CSS.

Обеспечивает различные способы представления данных, которые получены из модели.<br>
Это может быть шаблон, который заполняется данными. Может быть несколько различных view, и контроллер выбирает, какой
подходит наилучшим образом для текущей ситуации.

**Controller**<br>
Управляет всем этим оркестром. Содержит организационную логику.

Обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и
представление для реализации необходимой реакции.

Контроллер может быть устроен так:

- основной котнтроллер - получает все запросы
- он вызывает другие контроллеры - для выполнения действий в зависимости от ситуации.

**Стандартная схема работы:**<br>

- Контроллер получает запрос
- Посылает команду Модели на работу с данными
- В зависимости от ответа Модели Контроллер решает - какое из Представлений вызвать для формирования итогового ответа на
  изначальный Запрос
- Представление по команде Контроллера меняет отображение информации на экране.
- Пользователь взаимодействует с Представлением (кликает по кнопке, например), и тем самым формирует новый запрос к
  Контроллеру

Веб приложение обычно состоит из набора контроллеров, моделей и видов.

**Модификации**<br>
Есть много модификаций шаблона MVC -HMVC (Hierarchical MVC) и другие

**MVC для React & Redux**<br>

- Model = State. Состояние, хранящееся в Redux Store
- View = React компоненты без хуков и своего стейта.
- Controller = Redux (Reducer, Action)

Другой вариант

- Model = Redux
- View = React
- Controller = React-redux. Обёртка, которая принимает стейт, диспатчит ActionCreators и т. При условии, что никаких "
  умных" компонент со своим стейтом и т.д.

[//]: # (todo: дополнить)

**Ссылки**

- [Концепция MVC для чайников](https://ruseller.com/lessons.php?id=666)
- [MVC для веб: проще некуда](https://habr.com/ru/post/181772/)
- [Habr - Честный MVC на React + Redux (2016)](https://habr.com/ru/company/developersoft/blog/305812/)

<br></p>
</details>

[//]: # (ООП - Основные понятия)
<details><summary><b>ООП - Основные понятия</b></summary><p>

**Объектно-ориентированное программирование (ООП)** — методология программирования, основанная на представлении
программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют
иерархию наследования.

**Основные понятия**

- **Класс** - абстрактное описание автомобиля. Чертёж
- **Объект** - конкретная реализация автомобиля, данная машина
- **Свойства** - характеристики харакерные для всех машин. Количество колес, цвет, количество бензина...
- **Методы** - команды, на которые может реагировать машина. По сути функции, которые может вызывать каждый объект.
- **Геттеры и сеттеры** - спец. методы, для добавления/получения свойств объекта (чтоб не использовать приватные
  свойста)

**Разные модели (подходы) ООП**
- Компонентно-ориентированное программирование
- Прототипно-ориентированное программирование
- Агентно-ориентированное программирование

**Шаблоны проектирования "банды четырёх" GoF**
- [Шпаргалка по шаблонам проектирования](https://habr.com/ru/post/210288/)
- [Шаблоны проектирования](Pattern.md)

**Ссылки**

- [code.mu - на пальцах](http://code.mu/books/javascript/oop/)
- [code.mu - тоже на пальцах](http://code.mu/books/php/oop/osnovy-raboty-s-objektno-orientirovannym-programmirovaniem-v-php-1.html)
- [Habr - на пальцах 1](https://habr.com/ru/post/87205/)
- [Habr - на пальцах 2](https://habr.com/ru/post/87119/)
- [Что такое ООП в паре слов](https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija)
- [Habr - Понимание ООП в JS](https://habr.com/ru/company/enterra/blog/153365/)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Details_of_the_Object_Model)
- [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
- [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

<br></p>
</details>

[//]: # (ООП - Базовые принципы )
<details><summary><b>ООП - Базовые принципы </b></summary><p>

- **Наследование** — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом
  свойства и функциональность родительского класса заимствуются новым классом. Нужно, прежде всего, для повторного
  использование кода. Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или
  полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым,
  родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
- **Абстракция** - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных. Для
  каждого объекта мы задаём минимальное количество методов, полей и описаний, которые позволят решить задачу. Чем меньше
  характеристик, тем лучше абстракция, но ключевые характеристики убирать нельзя.
- **Инкапсуляция** - ограничение доступа к данным и возможностям их изменения. Свойство системы, позволяющее объединить
  данные и методы, работающие с ними, в классе.
- **Полиморфизм** — возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение
  объектов будет разным в зависимости от типа, к которому они принадлежат. <br>
  Cвойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
  структуре объекта.<br>
  Пример: реализуем в системе два разных класс, которые имеют метод getData - один с диска, другой из сети. При
  необходимости переключаем их. В других частях системы мы обращаемся к getData() и не думаем, как именно и откуда
  получаются данные — на этом уровне нам не важно. Интерфейс одинаковый, внутренняя релаизация разная<br>
  Способность обьекта использовать методы производного класса, который не существует на момент создания базового.

<br></p>
</details>

[//]: # (ООП - Принципы SOLID)
<details><summary><b>ООП - Принципы SOLID</b></summary>

<br>

[//]: # (Single Responsibility Principle)
<details><summary>Single Responsibility Principle (<b>Принцип единственной ответственности</b>)</summary><p>

Каждый класс должен решать лишь одну задачу.

<br></p>
</details>

[//]: # (Open-Closed Principle)
<details><summary>Open-Closed Principle (<b>Принцип открытости-закрытости</b>).</summary><p>

Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

<br></p>
</details>

[//]: # (Liskov Substitution Principle )
<details><summary>Liskov Substitution Principle (<b>Принцип подстановки Барбары Лисков</b>).</summary><p>

Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.<br>
Классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу
программы.<br>
Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

<br></p>
</details>

[//]: # (Interface Segregation Principle )
<details><summary>Interface Segregation Principle (<b>Принцип разделения интерфейса</b>).</summary><p>

Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента.<br>
Клиенты не должны зависеть от интерфейсов, которые они не используют.

<br></p>
</details>

[//]: # (Dependency Inversion Principle)
<details><summary>Dependency Inversion Principle (<b>Принцип инверсии зависимостей</b>).</summary><p>

Объектом зависимости должна быть абстракция, а не что-то конкретное.<br>
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.<br>
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

<br></p>
</details>

<br></p>
</details>

[//]: # (Парадигмы программирования)
<details><summary><b>Парадигмы программирования (методологии)</b></summary><p>

Набор приёмов и понятий, которые определяют «как писать» называют парадигмой.

**Кратко**

- Императивное
  - ООП
  - Процедурное
- Декларативное
  - Функциональное
  - Логическое
- Прочие
  - Реактивное - ориентированное на потоки данных и распространение изменений. Можно реализовать в **ООП**, в **чистом
    императивном** стиле и т.д. Естественнее всего реализуется в **функциональном**
  - Структурное
  - Модульное
  - Обобщённое
  - всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное.

- **Императивное** — описываем вычисления в виде инструкций, шаг за шагом изменяющих состояние программы. В деталях
  описывает *как* добраться до нужного места.
  - **Процедурное** - исходная задача разбивается на меньшие (с помощью процедур) и это происходит до тех пор, пока
    решение всех конкретных процедур не окажется тривиальным.
  - **ООП** - сущности в программе представляются в виде объектов. Каждый объект — экземпляр какого-то класса, некой
    абстрактной сущности, в которой описано поведение.
- **Декларативное** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся
  между этими состояниями. Объясняет *что* мы должны получить в итоге.
  - **Функциональное** - всё есть чистая функция, даже числа. Важно "отсутствие состояния". На его основе хорошо
    работать в **реактивном** стиле (см. ниже).
  - **Логическое** - скорее математика, чем программирование. Используя математические доказательства и законы логики,
    решать бизнес-задачи. Часто используется для моделирования процессов.

**Ещё есть**

- **Реактивное** - ориентированное на потоки данных и распространение изменений. Должна существовать возможность легко
  выражать статические и динамические потоки данных, а также нижележащая модель исполнения должна автоматически
  распространять изменения благодаря потоку данных. Можно реализовать в **ООП**, в **чистом императивном** стиле и т.д.
  Естественнее всего реализуется в **функциональном**
- **Структурное** - декомпозиция. По-прежнему оперируем состоянием и инструкциями, однако вводится понятие составной
  инструкции (блока), инструкций ветвления и цикла.
- **Модульное** - разделение функциональности на законченные блоки. Программа описанная в стиле модульного
  программирования — это набор модулей. Что внутри, классы, императивный код или чистые функции — не важно. Благодаря
  модулям впервые в программировании появилась серьезная инкапсуляция — возможно использовать какие-либо сущности внутри
  модуля, но не показывать их внешнему миру.
- **Обобщённое** - разделение на шаблоны

- всякие экзотические - автоматное, аппликативное, аспект/агент/компонент-ориентированное...<br>
  Немного подробнее: [«Забытые» парадигмы программирования](https://habr.com/ru/post/223253/)
  ...

**Прочее**

Декларативный подход читается в среднем легче, хотя на написание в обоих стилях времени может уходить одинаковое
количество. (Но это тоже зависит от конкретных разработчиков, потому что кто-то мог привыкнуть к конкретному стилю.)

Человеческий мозг может держать одновременно в памяти ограниченное количество объектов. Если мы работаем с какой-то
сложной системой, нам будет трудно одновременно помнить и о том, что она делает, и о том, как она устроена.

Императивный стиль смешивает назначение программы и детали её реализации, в то время как декларативный старается
описывать только назначение.

Плюсы и минусы зависят от контекста:

- Если вам нужно детально описать какое-то действие — например при разработке конкретного алгоритма — то больше подходит
  императивный подход.
- Если вы работаете на уровне бизнес-логики, то лучше писать декларативно, а детали реализации скрыть в более низком
  уровне абстракций.

**Мультипарадигменные языки**

Для большой части задач так мы вовсе можем использовать и ФП, и ООП, и процедурное, и логическое программирование. И
есть языки, которые не привязаны к конкретной парадигме. JavaScript как раз один из таких языков. (Именно поэтому мы
могли описать пример для каждой парадигмы на нём.)

**Ссылки**

- [Парадигмы программирования](https://doka.guide/js/programming-paradigms/)
- [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
- [Habr - Чистая архитектура. Часть II — Парадигмы программирования](https://habr.com/ru/post/554474/)
- [Парадигмы программирования](https://pikabu.ru/story/paradigmyi_programmirovaniya_7584307)
- [tproger.ru - Функциональное программирование с примерами на JavaScript. Часть 1. Основные техники функционального программирования](https://tproger.ru/translations/functional-js-1/)
- [tproger.ru - Функциональное программирование с примерами на JavaScript. Часть 2. Аппликативные функторы, curryN и валидации](https://tproger.ru/translations/functional-js-2/)

<br></p>
</details>

[//]: # (Некоторые принципы программирования)
<details><summary><b>Некоторые принципы программирования</b></summary><p>

- `DRY` - Don't repeat yourself (Не повторяйся)
- `KISS` - Keep it simple, stupid (Делай проще, тупица)
- `YAGNI` - You aren't gonna need it (Вам это не понадобится)
- `SOLID`
    - (см выше - ООП)
    - Single Responsibility Principle («Принцип единой ответственности», SRP)
    - Open-Closed Principle («Принцип открытости-закрытости», OCP)
    - Liskov Substitution Principle («Принцип подстановки Барбары Лисков», LSP)
    - Interface Segregation Principle («Принцип разделения интерфейса», ISP)
    - Dependency Inversion Principle («Принцип инверсии зависимостей», DIP)
- `GRASP` - Gneral responsibility assignment software patterns (общие шаблоны распределения ответственностей, паттерны
  проектирования) ООП
    - Информационный эксперт (Information Expert)
    - Создатель (Creator)
    - Контроллер (Controller)
    - Слабое зацепление (Low Coupling)
    - Высокая связность (High Cohesion)
    - Полиморфизм (Polymorphism)
    - Чистое изготовление (Pure Fabrication)
    - Перенаправление (Indirection)
    - Устойчивость к изменениям (Protected Variations)
- `CQS` - Command-query Separation (Разделение ответственности команд и запросов)
- `Law of Demeter` - Закон Деметры (см ООП)
- `SLAP` - Single level of Abstraction Principle (Принцип единого уровня абстракций)

**Интересные идеи на тему**

- [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

**Некоторые принципы Объектно Ориентированнаого Дизайна**

- **Закон Деметры** (англ. Law of Demeter, LoD) - каждый программный модуль:
    - должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение
      к этому модулю.
    - должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
    - обращаться только к непосредственным «друзьям».
      **Ссылки**
    - [Habr](https://habr.com/ru/post/319652/)
    - [wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
- **GRASP** (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей
    - Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения.
      Постоянно используешь в объекте какой-то внешний метод? Скорее всего, этот метод должен быть в этом объекте
    - высокое сцепление - код выполняющий одну задачу, должне быть в одном месте
    - низкая связность - модули не должны зависеть друг от друга (если они ссылаются друг на друга - это то же самое что у вас один большой модуль)
    - ... (всего 9 принципов)
    - [Wikipedia](https://ru.wikipedia.org/wiki/GRASP)
  - **CQS** (Command Query Separation)
    - метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. 
    - Другими словами, задавание вопроса не должно менять ответ. 
    - Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов.
    - Другими словами: если я спрашиваю у объекта "Ты админ?", он должен вернуть только tru или false. И не должен
      внутри заниматься изменением состояния
    - [Wikipediz](https://ru.wikipedia.org/wiki/CQRS)
    - **Single level of Abstraction** (один уровень абстракции)
      - Каждый метод должен быть написан на одном уровне абстракции.
      - [Single level of abstraction (en)](https://medium.com/@yukas/single-level-of-abstraction-1e2bb6a645d7)

  См видео "[Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)"

<br></p>
</details>

[//]: # (Domain Driven Design, DDD)
<details><summary><b>Domain Driven Design, DDD</b></summary><p>

`Domain Driven Design` (предметно-ориентированное проектирование) - подход построения моделей программных продуктов.

DDD не связан с технологиями. Это про архитектуру.<br>
Вместо этого речь идет о развитии знаний о бизнесе и использовании технологий для обеспечения ценности.

Книга Эрика Эванса «Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем»<br>
Рекоменация Кузебюрдина (It-Kamasutra)

Программное обеспечение это не только код. Код редко является конечной целью вашей работы. Код это только средства
решения бизнес-задач. Так почему код должен быть на языке отличном от языка бизнеса? DDD подчеркивает что код и бизнес
должны говорить на одном языке. Когда барьер преодолён, нет необходимости в переводе или утомительной синхронизации,
информация не потеряется. Каждый участник влияет на Бизнес-Домен, не только разработчики. Получающееся программное
обеспечение - единственная правда для общего языка.

Три основных понятия:

- Единый Язык (Ubiquitous Language)
- Стратегическое моделирование (Strategic Design)
- Тактическое моделирование (Tactical Design)

Ссылки:

- [Habr - Domain Driven Design на практике](https://habr.com/ru/post/334126/)
- [Domain Driven Design (DDD) - что это такое? И как начать использовать DDD в разработке](https://blog-programmista.ru/post/132-ddd-what-is-it.html)
- [Что можно узнать о Domain Driven Design за 10 минут?](https://itnan.ru/post.php?c=1&p=489352)
- []()

<br></p>
</details>


<br>
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*