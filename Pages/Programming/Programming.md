<h1>Общие вопросы программирования</h1>

[//]: # (Термины)
<details><summary><b>Термины</b></summary><p>


[//]: # (Синтаксис)
- <details><summary><b>Синтаксис</b> — набор правил написания кода на языке Х. Какие комбинации символов являются допустимыми конструкциями в этом языке.</summary><p>

  - как располагать и сочетать друг с другом команды, какие использовать символы, как структурировать записи и так далее.
  - описывает, какие элементы языка считаются правильными и как они могут быть комбинированы для создания программ.
  - определяет правила написания конкретных программных выражений
  - правила, определяющие комбинации символов, которые считаются правильно структурированными утверждениями или выражениями на этом языке.
  - синтаксис ничего не говорит о значении команд или слов. Он определяет только правильность написания. Например, написать функцию с неправильными скобками — это ошибка синтаксиса. А написать функцию, которая работает неверно, — ошибка другого вида. С точки зрения синтаксиса функция может быть верной.
  - это структура и форма записи текста программы.
  - набор правил, описывающий комбинации символов алфавита, считающиеся правильно структурированной программой (документом) или её фрагментом.
  - это набор правил, управляющих структурой предложения и расположением слов,
  - фокусируется на порядке слов и отношениях между словами,
  - синтаксис языка, определяющий структуру текста, отличается от семантики, определяющей смысл.
  - Синтаксические ошибки приводят к тому, что предложения становятся трудными для понимания
  - Примеры правил синтаксиса
    - Вид скобок, которые используются при записи той или иной команды.
    - Регистрозависимость — есть ли для языка разница между строчными и прописными буквами.
    - Необходимость использовать пробелы и переносы строки — или ее отсутствие. Например, в Python это часть синтаксиса, а в JavaScript они не так важны.
    - Необходимость или отсутствие необходимости указывать тип переменной при создании.
    - Порядок расположения команд и сочетания их друг с другом.
    - Символ, которым обозначается комментарий в коде.
  - Синтаксис определяет правила правильного написания программы, структуру выражений и конструкций. Это связано с тем, каким образом символы и ключевые слова должны быть упорядочены для создания корректного кода. Семантика определяет смысл этих выражений и конструкций, указывает, как они будут исполняться и взаимодействовать во время выполнения программы. Семантика определяет, что делает код и как его выполнение влияет на состояние системы. Вместе синтаксис и семантика обеспечивают полное описание языка программирования, где синтаксис обеспечивает правильность написания кода, а семантика — его осмысленность и поведение при выполнении.

  <br></p>
  </details>

[//]: # (Семантика)
- <details><summary><b>Семантика</b> — определяет смысл выражений и конструкций — какие операции они вызовут в программе. Определяет, что делает код и как его выполнение влияет на состояние системы. </summary><p>

  - говорит о смысле слов и значении команд.
  - указывает, как выражения и конструкции будут исполняться и взаимодействовать во время выполнения программы
  - приписывает значения (действия) различным синтаксическим конструкциям
  - определение того, как выполняется код и взаимодействует его части, описывая смысл программных конструкций.
  - Синтаксис определяет правильность написания, а семантика — смысловую правильность.
  - Синтаксис отвечает за то, поймет ли компьютер, что вы ему сказали. Семантика — за внутреннюю логику написанного, за то, что означают команды.
  - синтаксис языка, определяющий структуру текста, отличается от семантики, определяющей смысл.
  - определяет, какие операции выполняются при выполнении конкретных выражений и как программные инструкции взаимодействуют между собой. В отличие от синтаксиса, который определяет правила написания кода, семантика уточняет, как именно этот код будет интерпретирован или скомпилирован в рамках определенного языка. Семантика включает в себя трактовку различных конструкций, значений переменных, порядка выполнения операций, обработки ошибок, управления памятью и другие аспекты, влияющие на поведение программы во время выполнения. Она играет ключевую роль в понимании того, как программы работают и какие результаты они должны производить.
  - Пример:
    - «Я любить Москва это город» — предложение, написанное неправильно с точки зрения синтаксиса. Но его смысл понятен, по крайней мере человеку;
    - «Я люблю деревню Санкт-Петербург» — предложение, которое правильно синтаксически. Но семантически оно неверно, ведь Санкт-Петербург — это город, а не деревня. Значение слова совсем другое. Поэтому непонятно: человек ошибся или действительно имел в виду какую-то деревню с таким же названием.
  - Синтаксис определяет правила правильного написания программы, структуру выражений и конструкций. Это связано с тем, каким образом символы и ключевые слова должны быть упорядочены для создания корректного кода. Семантика определяет смысл этих выражений и конструкций, указывает, как они будут исполняться и взаимодействовать во время выполнения программы. Семантика определяет, что делает код и как его выполнение влияет на состояние системы. Вместе синтаксис и семантика обеспечивают полное описание языка программирования, где синтаксис обеспечивает правильность написания кода, а семантика — его осмысленность и поведение при выполнении.

  <br></p>
  </details>

[//]: # (Грамматика)
- <details><summary><b>Грамматика</b> — формальное описание правил синтаксиса. Какая структура программных конструкций корректна? Включает в себя синтаксис + другие аспекты</summary><p>

  - способ задания языка
  - формальное описание синтаксиса языка программирования.
  - включает в себя синтаксис и дополнительные лингвистические правила (правописание, пунктуация, морфология...)
  - грамматика, помимо синтаксиса, описывает более общую формальную структуру языка, включая правила комбинирования элементов для создания корректных программ
  - грамматические ошибки могут привести к потери ясности и сложности интерпретации
  - Грамматика включает в себя различные аспекты синтаксиса, такие как правила для объявления переменных, операторов, условных конструкций, циклов, функций и других элементов языка. Грамматика также определяет порядок следования элементов, использование ключевых слов, пунктуации и другие структурные аспекты.

  - **Синтаксис / Грамматика**
    -
    - «Предложением» называется полная последовательность слов, выражающая некоторую мысль. Предложение состоит из одной или нескольких «фраз», связанных знаками препинания или союзами («И», «ИЛИ» и т.д.). Сама фраза может состоять из меньших фраз. Некоторые фразы неполны и мало что дают сами по себе, тогда как другие фразы могут использоваться самостоятельно. Совокупность этих правил называется грамматикой языка.
    -
    - Так же обстоит дело с грамматикой JavaScript.
      - команды - аналоги предложений,
      - выражения - аналоги фраз,
      - операторы - аналоги союзов/знаков препинания.
    -
    - Выражение в JS - может быть вычислено с получением одного конкретного значения (результата).
    - Команда состоит из одного или нескольких выражений
      - у каждой команды имеется завершающее значение (даже если это значение undefined). Если ввести команду в консоли разработчика в браузере, потому что при выполнении консоль по умолчанию выводит завершающее значение последней выполненной команды.
      - Например, любой обычный блок { . . } имеет завершающее значение - это завершающее значение последней выполненной в нем команды/выражения. завершающее значение блока аналогично значению, неявно возвращаемому последней командой блока.
      - Но что бы ни выводилось в консоль, мы не можем перенести это значение в свою программу. Как получить завершающее значение в программе?

  <br></p>
  </details>

[//]: # (Код)
- <details><summary><b>Код</b> — последовательность текстовых инструкций, написанных на языке программирования. </summary><p>

  - бывает `исходный` (пишется человеком) и получаемый из него `исполняемый` (выполняется машиной).

  <br></p>
  </details>

- <b>Переменная</b>  — именованная область памяти. Может хранить данные (значение)
- <b>Значение переменной</b>  — данные, которые хранятся в переменной
- <b>Константа</b>  — особый тип переменных. Их значения нельзя изменить

[//]: # (Литерал)
- <details><summary><b>Литерал</b> — любое значение указанное явным образом в коде. Строка, число, логическо значение, массивы, объекты, функции. В отличии от переменных — не изменяются в процессе работы программы. В переменной хранятся какие-то данные, например литералы.</summary><p>

  - представления фиксированных значений в программе — числа, символы, строки и т.д.
  - текстовое представление (нотация) значения (данных) в том виде, как оно записано в исходном коде.
  - запись в исходном коде компьютерной программы, представляющая собой фиксированное значение.
  - безымянная константа
  - константы, включаемые непосредственно в текст программы. Литералы могут быть изменены в тексте программы лишь во время редактирования. В отличие от переменных, литералы не могут изменяться во время выполнения программы.
  - представление значения некоторого типа данных. 
  - это постоянные значения JavaScript. Это значения, которые не изменяются во время выполнения сценария (целочисленные литералы, литералы с плавающей точкой, логические литералы (true и false), строковый литерал — это ноль и более символов, заключенных в двойные («») или одиночные (») кавычки).
  - используются для представления значений в JavaScript. Они являются фиксированными значениями, а не переменными
  - используются для обозначения числовых значений, строк, символов или логических констант. Постоянное значение, у которого нет имени.
    - В нашем случае понятие литерала немного отличное. Мы можем представить, что литерал это способ объявления значения какого-либо типа в коде.
  - Последовательность символов, представляющая постоянные значения, хранящиеся в переменных, называется литералом. Литерал — это представление значения в исходном коде, например число или строка.
  -  это любое значение указанное явным образом в коде. В качестве литералов в js могут выступать числа, строки (текстовые значения), логические значения. Функциональные литералы, массивы и объекты мы рассмотрим позже.

  <br></p>
  </details>

[//]: # (Оператор)
- <details><summary><b>Оператор</b> — элемент языка, описывает некое действие. Например `+` или `delete`</summary><p>

  - представляет собой законченную фразу языка и определяет однозначно трактуемый этап обработки данных
  - [MDN - Список выражений, операторов и ключевых слов JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)

  <br></p>
  </details>

- <b>Операция</b>  — действия, которые мы выполняем над переменными и значениями. Обычно производятся помощью операторов

- <b>Конструкция</b> — произвольная совокупность кода.

[//]: # (Инструкция)
- <details><summary><b>Инструкция</b> — отдельная команда в коде, которая выполняет определённое действие. Ничего не вычисляет и не возвращает результат. «Строки программы». Отделяются `;`.</summary><p>

  - синтаксические конструкции и команды, которые выполняют действия.
  - обозначает одно действие в программе JS. Во многих случаях инструкция – это одна строка кода и если провести аналогию с русским языком, то она схожа с предложением.
  - В JS есть выражение, которое позволяет возвращать значение по условию — тернарный оператор. Он возвращает значение, но работает с условиями (как инструкиця).
  - Написать программу можно только совмещая выражения, которые работают с данными, и инструкции, которые позволяют управлять порядком выполнения.
  - Примеры: `if` позволяет создать ветвление в программе, `for` позволяет повторять одно и то же действие.
  -
  - Типы инструкций в JS
    - управление потоком выполнения (if и else, switch, throw и так далее);
    - итерации (for, while и так далее);
    - объявление значений (var, let, const);
    - функции (function, return и так далее);
    - прочие (debugger, import, export).
  -
  - [Doka — Выражения и инструкции](https://doka.guide/js/expressions-vs-statements/)

  <br></p>
  </details>

[//]: # (Выражение)
- <details><summary><b>Выражение</b>(expression) — код, который после выполнения возвращает какое-то значение</summary><p>

  - В JS есть выражение, которое позволяет возвращать значение по условию — тернарный оператор. Он возвращает значение, но работает с условиями (как инструкиця).
  - Написать программу можно только совмещая выражения, которые работают с данными, и инструкции, которые позволяют управлять порядком выполнения.
  -
  - Пример: `3` в консоли браузера вернёт `3`
  - Пример: `5 + 3` вернёт `8`
  - Пример: `Math.random()` вернёт случайное число.
  - +
  - [Doka — Выражения и инструкции](https://doka.guide/js/expressions-vs-statements/)
  - [MDN - Список выржений, операторов и ключевых слов JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)

  <br></p>
  </details>

- <b>Пустая инструкция</b> — когда в строке кода стоит только `;`.  Используется, когда инструкция не нужна, хотя синтаксис JS будет предполагать её.

[//]: # (Процедура **)
- <details><summary><b>Процедура **</b> — функция, которая возвращает пустое значение (при этом выполнение кода процедуры непосредственно сказывается на выполнении программы)</summary><p>

  - ДОПОЛНИТЬ

  <br></p>
  </details>

- <b>Аттрибут</b> — свойство или характеристика сущности. Например `аттрибут DOM-элемента`, `аттрибут HTML-элемента`.

- <b>Функция</b> — фрагмент кода, выполняющий определенные операции. Может принимать входные данные и возвращать результаты (но не обязательно). В JS функции = объекты.

[//]: # (Блок)
- <details><summary><b>Блок</b> — используется для группировки нуля или более инструкций. Блок отделяется `{...}`</summary><p>

  - может опционально быть поименован `[имя:] {...}`
  - в других языках = «сложная инструкция»
  - [MDN - Блок](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block)

  <br></p>
  </details>

[//]: # (Ключевое слово)
- <details><summary><b>Ключевое слово</b> — специальное зарезервированное слово. Имеет специфическое назначение — для создания и описания различных структур и элементов программы.</summary><p>

  -  используются для создания структуры программы — указывают, что это за элемент (переменная, функция, условие). А операторы выполняют конкретные действия или вычисления над значениями.
  - Примеры в JS:
    - var, let, const - для объявления переменных.
    - function - для определения функций.
    - if, else, switch - для структур управления потоком.
  - [MDN - Список выражений, операторов и ключевых слов JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)

  <br></p>
  </details>

[//]: # (Предикат)
- <details><summary><b>Предикат</b> — выражение или функция, возвращающая логическое значение (истина или ложь)</summary><p>

  - Примеры:
    - `if (age >= 18) {...}`
    - `function isEven(number) { return number % 2 === 0;}`

  <br></p>
  </details>

- <b>Движок JS</b> — часть браузера или серверной среды, которая интерпретирует и выполняет JS код. Преобразует JS-инструкции в машинный код, который может быть выполнен компьютером.

[//]: # (Движок браузера)
- <details><summary><b>Движок браузера</b> — часть браузера, ответственная за обработку и отображение веб-страниц. </summary><p>

  - включает в себя компоненты для разбора HTML и CSS, выполнения JavaScript кода, обработки событий и рендеринга веб-страницы.

  <br></p>
  </details>

[//]: # (Окружение)
- <details><summary><b>Окружение</b> (environment) — среда выполнения, в которой работает JS код.</summary><p>

  -  включает в себя не только сам движок (например, V8 в браузере Chrome или Node.js), но и другие компоненты, которые обеспечивают функциональность и возможности для выполнения кода в конкретной среде.
  - Важные элементы окружения:
    - JS-движок:
      - Это программная часть, которая интерпретирует и выполняет JavaScript код. Примеры включают V8 (Chrome, Node.js), SpiderMonkey (Firefox), JavaScriptCore (Safari).
    - Среда выполнения (Runtime):
      - Включает в себя компоненты, предоставляющие дополнительные функции и возможности для выполнения кода. Например, в браузере это может включать DOM (Document Object Model), Web APIs (например, XMLHttpRequest, Fetch), а также средства работы с событиями.
    - Web APIs и Событийная модель:
      - В браузерном окружении это включает в себя взаимодействие с браузерным DOM, AJAX запросы, обработку событий и другие веб-специфичные функции.
    - Стек вызовов (Call Stack):
      - Это структура данных, которая отслеживает вызовы функций в вашем коде. Он используется для управления выполнением функций и их возвратами.
    - Память:
      - Окружение управляет выделением и освобождением памяти в процессе выполнения кода, включая работу с примитивами, объектами и сборку мусора.
    - Event Loop (Цикл событий):
      - В браузере и Node.js средах, которые поддерживают асинхронное программирование, существует event loop, который управляет обработкой событий, колбэков и асинхронных операций.

  <br></p>
  </details>

- <b>Компиляция</b> — перевод программы из языка программирования понятного человеку в машинный код. Делается отдельным этапом, до запуска программы. Получаем файл специального формата (например `.exe`) — он и будет выполняться

- <b>Компилятор</b> — программа. которая проводит компиляцию исходного кода программы в машинный код.

- <b>Интерпретация</b> — перевод программы с языка программирования (понятного человеку) в машинный код. Происходит прямо в процессе выполнения программы (пошагово или блоками).

[//]: # (Интерпретатор)
- <details><summary><b>Интерпретатор</b>  — программа, которая выполняет команды, написанные на каком-то языке программирования.  </summary><p>

  - это программа/компонент, который выполняет и интерпретирует исходный код программы пошагово в режиме выполнения. 
  - В отличие от компилятора, который преобразует весь исходный код в машинный код до запуска программы, интерпретатор выполняет код построчно или по блокам на ходу, что обеспечивает более гибкую и динамическую среду выполнения программ. Примеры интерпретируемых языков включают JavaScript, Python и Ruby.

  <br></p>
  </details>

[//]: # (Транспиляция)
- <details><summary><b>Транспиляция</b> — процесс преобразования исходного кода из одного языка программирования в другой. </summary><p>

  - Для сохранения семантики (поведения программы) при изменении синтаксиса. 
  - Например, транспилятор «Babel» переводит программу на современном JS в версию программы на старом варианте JS.   

  <br></p>
  </details>

[//]: # (Область видимости)
- <details><summary><b>Область видимости</b> — контекст, в пределах которого определены переменные и которому можно обратиться для получения значения этих переменных. </summary><p>

  - набор правил — где в коде можно использовать переменные, где они будут доступны, а где нет.  
  - определяет доступность переменных в различных частях кода и управляет их видимостью.

  <br></p>
  </details>

- <b>Куча</b> (heap) —
- <b>Стэк</b> —
- <b>Очередь</b> —
- <b>Event Loop</b> (цикл обработки событий) —
- <b>Объект</b> —
- <b>Массив</b> —
- <b>Метод</b> — функция, которая является свойством объекта.
- <b>Прототип</b> —
- <b>Модуль</b> —
- <b>Класс</b> —
- <b>Конструктор</b> —
- <b>Корутина</b> — сопрограмма.
- <b>Debounce</b> — паттерн микрооптимизации кода. Ждёт Х милисек, если некое событие не произошло за это время — выполняет действие.
- <b>Throttling</b> — паттерн микрооптимизации кода. Тормозит - выполняй событие не чаще чем Х милисек.
- <b>Шлюз</b> (gate) — механизм, который ожидает завершения двух и более параллельных задач. Неважно, в каком порядке они будут завершаться, важно только то, что все они должны быть завершены, чтобы шлюз открылся и пропустил поток команд. В Promise API этот паттерн называется all([ .. ]).

- **Ссылки**
  [golvinov — Введение в программирование](https://golvinov.gitbook.io/js/)
  [golvinov — Введение в JavaScript](https://golvinov.gitbook.io/js/vvedenie-v-javascript)

<br></p>
</details>


---


[//]: # (Рекурсия)
<details id="recursion"><summary><b>Рекурсия</b></summary><p>


[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Термин/приём в программировании, означающий вызов функцией самой себя. 
  - Рекурсивные функции могут быть использованы для элегантного решения определённых задач.
  - 
  - `Шаг рекурсии` —  каждый вызов функцией самой себя при изменении параметров. По сути — итерация рекурсивного цикла. 
  - `База рекурсии` – такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.
  - 
  - Классические примеры рекурсии:
    - возведение в степень
    - числа Фибоначчи
    - -факториал

  <br></p>
  </details>


[//]: # (Возведение в степень)
- <details><summary><b>Возведение в степень</b></summary><p>

  - ```js
      function pow(x, n) {
        if (n == 1) {
          return x;
        } else {
          return x * pow(x, n - 1);
        }
      }

      alert(pow(2, 3)); // 8
    ```

  <br></p>
  </details>

[//]: # (Числа Фибоначчи)
- <details><summary><b>Числа Фибоначчи</b></summary><p>

  - ```js
      // Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.

      function fib(n) {
        // return n <= 1 ? n : fib(n - 1) + fib(n - 2);
        if (n <= 1) {
          return n
        } else {
          return fib(n - 1) + fib(n - 2);
        }
      }

      alert(fib(3)); // 2
      alert(fib(7)); // 13
    ```

  <br></p>
  </details>
  
[//]: # (Рекурсивная структура данных)
- <details><summary><b>Рекурсивная структура данных</b></summary><p>

  - Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя. 
  - Например дерево HTML-элементов.
  - Рекурсивные функции могут быть использованы для прохода по «рекурсивной структуре данных».

  <br></p>
  </details>

[//]: # (Замена циклом)
- <details><summary><b>Замена циклом</b></summary><p>

  - Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.
  - Любая рекурсия может быть сведена к циклу, по сути это следует из тезиса Черча-Тьюринга любая функция, которая может быть вычислена физическим устройством, может быть вычислена машиной Тьюринга; Принципиальное отличие рекурсии от цикла состоит в наличии стека вызова - все локальные переменные и аргументы складываются в стек при каждом вызове рекурсивной функции, а в цикле локальные переменные остаются "на месте".
  - Обычно рекурсивный алгоритм может быть заменён циклом и, если необходимо, вспомогательной структурой данных, чаще всего стеком.

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Рекурсия и стек](https://learn.javascript.ru/recursion)
  - [Habr - Превращаем рекурсию в цикл](https://habr.com/ru/post/533034/)
  - [learn.javascript.ru - Задачка на числа Фибоначчи](https://learn.javascript.ru/task/fibonacci-numbers)
  - [code.tutsplus.com - Рекурсия в JavaScript](https://code.tutsplus.com/ru/tutorials/understanding-recursion-with-javascript--cms-30346)
  
  <br></p>
  </details>


<br></p>
</details>

[//]: # (Чистые функции)
<details><summary><b>Чистые функции</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Детерминированная функция, которая не производит побочных эффектов.
  - Чистые функции — не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

  <br></p>
  </details>

[//]: # (Характеристики чистой функции)
- <details><summary><b>Характеристики чистой функции</b></summary><p>

  - `идемпотента` - при повторении операции даст тот же эффект
  - `детерминирована` - для одних и тех же данных всегда выдаёт тот же результат
  - `иммутабельна` - неизменяема. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
  - без `сайд-эффектов` - без побочных эффектов. Например: какой-то внешний объект изменился, функция от него зависела, и при тех же входящих данных (которые мы напрямую передали при вызове функции) мы получили новый результат (т.к. она ещё взаимодействует с каким-то внешним объектом, который тоже меняется). Например, нельзя делать AJAX-запросы

  <br></p>
  </details>

[//]: # (Почему важна `иммутабельность`)
- <details><summary><b>Почему важна иммутабельность</b></summary><p>

  - У нас ссылочный тип данных - функция изменит входящие данные, и они изменятся в объекте где хранятся (например объект в памяти). Соответственно эти изменения могут вылезти где-то ещё. Один метод компонента случайно изменил данные, а другой метод потом взял уже изменённые (хотя ему нужны были оригинальные)...

  <br></p>
  </details>

[//]: # (Функция должна что-то возвращать)
- <details><summary><b>Функция должна что-то возвращать</b></summary><p>

  - Функция не меняет никакие данные которые в ней пришли, и не меняет ничего во внешнем мире.
  - Чтоб в такой функции был какой-то смысл - она должна что-то возвращать, делать return().

  <br></p>
  </details>

[//]: # (Мутирующие и немутирующие методы)
- <details><summary><b>Мутирующие и немутирующие методы</b></summary><p>

  - В JS особенно внимательно нужно относиться к массивам.
  - Есть методы `мутирующие` и `немутирующие`.
  - Примеры мутирующих методов:
    - `push`
    - `reverse`
    - `splice`
  - Примеры немутирующих методов:
    - `slice`

  <br></p>
  </details>

[//]: # (Side-effect)
- <details><summary><b>Side-effect</b></summary><p>

  - Побочными эффектами называют любые взаимодействия с внешней средой. К ним относятся файловые операции, такие как запись в файл, чтение файла, отправка или приём данных по сети и даже вывод в консоль.
  - Кроме того, побочными эффектами считаются изменения внешних переменных (например, глобальных) и входных параметров в случае, когда они передаются по ссылке.
  - Побочные эффекты составляют одну из самых больших сложностей при разработке. Их наличие значительно затрудняет логику кода и тестирование. Приводит к возникновению огромного числа ошибок. Только при работе с файлами количество возможных ошибок измеряется сотней: начиная с того, что закончилось место на диске, заканчивая попыткой читать данные из несуществующего файла. Для их предотвращения код обрастает большим числом проверок и защитных механизмов. Без побочных эффектов невозможно написать ни одной полезной программы. Какие бы важные вычисления она ни делала, их результат должен быть как-то продемонстрирован. В самом простом случае его нужно вывести на экран, что автоматически приводит нас к побочным эффектам. В реальных же приложениях, обычно, все сводится к взаимодействию с базой данных или отправкой запросов по сети.
  - Не существует способа избавиться от побочных эффектов совсем, но их влияние на программу можно минимизировать. Как правило, в типичной программе побочных эффектов не так много по отношению к остальному коду, и происходят они лишь в самом начале и в конце. Например, программа, которая конвертирует файл из текстового формата в PDF, в идеале выполняет ровно два побочных эффекта:
  -
  - Читает файл в самом начале работы программы.
  - Записывает результат работы программы в новый файл.
  -
  - Между этими двумя пунктами и происходит основная работа, которая содержит чистую алгоритмическую часть. Побочные эффекты в таком случае будут находиться только в верхнем слое приложения, а ядро, выполняющее основную работу, останется чистым от них.
  - 
  - Инкремент и декремент — единственные базовые арифметические операции в JS, которые обладают побочными эффектами (изменяют само значение в переменной). Именно поэтому с ними сложно работать в составных выражениях. Они могут приводить к таким сложноотлавливаемым ошибкам, что во многих языках вообще отказались от их введения (в Ruby и Python их нет). В JS стандарты кодирования предписывают их не использовать.
  - 
  - Примеры:
    - Видоизменение входных параметров
    - console.log
    - HTTP вызовы (AJAX/fetch)
    - Изменение в файловой системе
    - Запросы DOM

  <br></p>
  </details>

[//]: # (В ReactJS / Redux)
- <details><summary><b>В ReactJS / Redux</b></summary><p>

  - Чистыми функциями должны быть:
    - компоненты
    - редьюсеры
    - селекторы

  <br></p>
  </details>

[//]: # (Пример чистой функции)
- <details><summary><b>Пример чистой функции</b></summary><p>

  - ```js
    function sum(a, b) {
      return a + b;
    }
    ```    

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - Пример нечистой функции (записывает данные в свои же аргументы)
  - ```js
      function withdraw(account, amount) {
        account.total -= amount;
      }
    ```

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [IT-Kamasutra #88 - pure function (чистая функция)](https://youtu.be/KU81NnNcjmw)
  - [Hexlet - Чистые функции](https://ru.hexlet.io/courses/js-functions/lessons/pure-functions/theory_unit)
  - Смотри также в разделе «[React — Компоненты. Компоненты = чистые функции](/Pages/JS/React.md)»
    
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Инкапсуляция)
<details><summary><b>Инкапсуляция</b></summary><p>

  - Сокрытие лишних деталей.

<br></p>
</details>

[//]: # (Идемпотентность)
<details ><summary><b>Идемпотентность</b></summary><p>

  - Повторное применение операции к объекту дает тот же результат, что и первое.
  - Свойство объекта или операции.

<br></p>
</details>

[//]: # (Детерминированность)
<details><summary><b>Детерминированность</b></summary><p>

  - Результат однозначно определяется исходными данными.
  - Для одних и тех же исходных данных алгоритм выдаёт тот же результат.

<br></p>
</details>

[//]: # (Иммутабельность)
<details><summary><b>Иммутабельность</b></summary><p>

  - Неизменяемость.
  - Функция не меняет входящие данные. Делает копию, и работает уже с ней.
  
  - **Ссылки**
    - [Неизменяемость в JavaScript](https://techrocks.ru/2020/11/13/immutability-in-javascript-explained/)

<br></p>
</details>

[//]: # (Интерфейс)
<details><summary><b>Интерфейс</b></summary><p>

  - Как мы взаимодействуем с чем-то.
  - Интерфейс объекта - какие свойства и методы у него есть.
  - Интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...

<br></p>
</details>

[//]: # (Декоратор)
<details><summary><b>Декоратор</b></summary><p>

  - Микропаттерн оптимизации функции — позволяет добавить дополнительное поведение функции, не изменяя ее.
  -  
  - **Ссылки**
    - [Habr - Декораторы](https://habr.com/ru/post/60957/)
    - [learn JS - Декораторы и переадресация вызова, call/apply](https://learn.javascript.ru/call-apply-decorators)

<br></p>
</details>

[//]: # (Debounce)
<details><summary><b>Debounce (Дебаунс)</b></summary><p>

- "Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.
- Превращает несколько вызовов функции в течение определенного времени в один вызов.
- Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова.
- `Debounce` — паттерн микрооптимизации кода. Ждёт Х милисек, если некое событие не произошло за это время — выполняет действие.
- Если дословно переводить — «устранение дребезга».
- 
- Возможны два варианта:
  - Реальный вызов происходит только в случае, если с момента последней попытки прошло время, большее или равное задержке.
  - Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет время, большее или равное задержке, отсчитанной от времени последней попытки.
- 
- **Зачем?**
  - Обычно debounce используют, если исходная функция вызывается чаще, чем это требуется.
  - Например, DOM-события mousemove, resize, scroll генерируют очень частые вызовы обработчиков, поэтому в ряде случаев было бы полезно обернуть такие обработчики в debounce.
  - Другое применение – контроль пользовательского ввода текста: если при изменении поля INPUT требуется передавать на сервер текущее введенное значение, это может создать большое количество однотипных запросов, особенно если пользователь печатает очень быстро. В этом случае тоже весьма кстати будет ограничить число вызовов обработчика с помощью debounce.
  - Функция debounce крайне полезна, когда дело доходит до производительности обработчиков событий.
- 
- **Ссылки:**
  - [Habr - Декораторы](https://habr.com/ru/post/60957/)
  - [Для чего нужна функция debounce и как она работает](http://gdrw.ru/reviews/tech/debounce-function-in-javascript)
  - [learn.javascript.ru - реализация на js](https://learn.javascript.ru/task/debounce)
  - [7 важных функций JavaScript](https://getinstance.info/articles/javascript/essential-javascript-functions/)
  - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=Z9g8L-5_c5aHx3dA&t=3807)
  - [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)
  - [learn.javascript.ru - Сделать Debounce](https://learn.javascript.ru/task/debounce)
  - [doka - Сделать Debounce на примере формы поиска](https://doka.guide/js/debounce/)
  - [Habr - Debouncing с помощью React Hooks](https://habr.com/ru/post/492248/)
  - [Habr - Debouncing с помощью React Hooks: хук для функций](https://habr.com/ru/company/domclick/blog/510616/)

<br></p>
</details>

[//]: # (Throttling)
<details><summary><b>Throttling (Тротлинг)</b></summary><p>

  - Данный декоратор позволяет «затормозить» функцию — функция будет выполняться не чаще одного раза в указанный период, даже если она будет вызвана много раз в течение этого периода. Т.е. все промежуточные вызовы будут игнорироваться.
  - `Throttling` — паттерн микрооптимизации кода. Тормозит - выполняй событие не чаще чем Х милисек.
  -
  - **Ссылки:**
    - [Habr - Декораторы](https://habr.com/ru/post/60957/)
    - [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)
    - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=Z9g8L-5_c5aHx3dA&t=3807)

<br></p>
</details>

[//]: # (Мемоизация)
<details><summary><b>Мемоизация</b></summary><p>

- Разновидность кэширования.
- Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша
- 
- Для того чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, всегда возвращать одни и те же значения в ответ на одни и те же аргументы.
- Мемоизация — это компромисс между производительностью и потреблением памяти. Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.
- Может показаться, что собственные реализации мемоизации стоит применять, например, при обращениях к неким API из браузерного кода. Однако, делать этого не нужно, так как браузер автоматически кэширует их, используя, в частности, HTTP-кэш.
- Если вы работаете с React/Redux, можете взглянуть на **reselect**. Тут используется селектор с мемоизацией. Это позволяет выполнять вычисления только в том случае, если в соответствующей части дерева состояний произошли изменения.
- Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления. Здесь данная техника может значительно повысить производительность решения. Надо отметить, что нечто вроде вычисления факториала или чисел Фибоначчи — это хорошие учебные примеры, но в реальном мире всё гораздо интереснее и сложнее.

- **Ссылки**
  - [https://habr.com/ru/company/ruvds/blog/332384/](https://habr.com/ru/company/ruvds/blog/332384/)

<br></p>
</details>

[//]: # (Анаморфизмы и катаморфизмы)
<details id="iterators"><summary><b>Анаморфизмы и катаморфизмы</b></summary><p>

  - **Анаморфизмы**
    - `Анаморфизмы`. Функции, с помощью которых объекты разворачиваются в более сложные структуры, содержащие объекты того же типа. 
    - Например  преобразование целого числа в ряд чисел.
    - ```js
        // Преобразование целого числа в ряд чисел:
        function downToOne(n) {
          const list = [];

          for (let i = n; i > 0; --i) {
            list.push(i);
          }

          return list;
        }

        downToOne(5) // [ 5, 4, 3, 2, 1 ]
      ```
  - **Катаморфизмы**
    - Противоположность анаморфизмов: сворачивают объекты с более сложной структурой в простые.
    - Например преобразует несколько чисел в одно.
    - ```js
        // Преобразование ряда чисел в одно
        function product(list) {
          let product = 1;

          for (const n of list) {
            product = product * n;
          }

          return product;
        }

        product(downToOne(5)) // 120
      ```
  - **Ссылки**
    - [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#amrphcatmrph)

<br></p>
</details>

[//]: # (Профилирование)
<details><summary><b>Мемоизация</b></summary><p>

- `Профилирование` — сбор характеристик работоспособности программы. 
- Чтобы оценить, насколько эффективно она работает, выявить ее «слабые» участки.
- 
- `Профилировщик` — программа, которая следит за другими программами, во время их исполнения. не анализирует, только собирает информацию «как работает программа».
- 
- В языках программирования обычно есть спец. методы дл помощи в профилировании. Также есть специальные плагины/программы, например в отладчиках в браузерах
- 
- **Какая информация обычно собирается**
  - измерение времени, затраченного на ту или иную функцию;
  - измерение потраченных системных ресурсов на ту или иную функцию;
  - изменения программы в зависимости от воздействия на нее со стороны пользователей;
  - как запустилась и как прекратила работать программа;
  - были ли «зависания» в программе и из-за чего;
  - ...

- **Ссылки**
  - [Профилирование в программировании: какой профилировщик выбрать](https://codernet.ru/articles/drugoe/profilirovanie_v_programmirovanii_kakoj_profilirovshhik_vyibrat/)

<br></p>
</details>

[//]: # (Парадигмы программирования)
<details><summary><b>Парадигмы программирования (методологии)</b></summary><p>

[//]: # (Парадигма это)
- <details><summary><b>Парадигма это</b></summary><p>
  
  - Набор приёмов и понятий, которые определяют «как писать» называют парадигмой.

  <br></p>
  </details>

[//]: # (Основные виды)
- <details><summary><b>Основные виды</b></summary><p>

  - Императивное
    - ООП
    - Процедурное
  - Декларативное
    - Функциональное
    - Логическое
  - Прочие
    - Реактивное 
    - Структурное
    - Модульное
    - Обобщённое
  - Экзотические 
    - автоматное
    - аппликативное
    - аспект/агент/компонент-ориентированное
    - ...

  <br></p>
  </details>

[//]: # (Императивное + Процедурное и ООП)
- <details><summary><b>Императивное + Процедурное и ООП</b></summary><p>

  - описываем вычисления в виде инструкций, шаг за шагом изменяющих состояние программы. В деталях описывает *как* добраться до нужного места.
  -
  - **Процедурное** - исходная задача разбивается на меньшие (с помощью процедур) и это происходит до тех пор, пока решение всех конкретных процедур не окажется тривиальным.
  - **ООП** - сущности в программе представляются в виде объектов. Каждый объект — экземпляр какого-то класса, некой абстрактной сущности, в которой описано поведение.

  <br></p>
  </details>

[//]: # (Декларативное + Функциональное и Логическое)
- <details><summary><b>Декларативное + Функциональное и Логическое</b></summary><p>
  
  - Описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями. 
  - Объясняет *что* мы должны получить в итоге.
  -
  - **Функциональное** - всё есть чистая функция, даже числа. Важно "отсутствие состояния". На его основе хорошо
    работать в **реактивном** стиле (см. ниже).
  - **Логическое** - скорее математика, чем программирование. Используя математические доказательства и законы логики,
    решать бизнес-задачи. Часто используется для моделирования процессов.

  <br></p>
  </details>

[//]: # (Реактивное)
- <details><summary><b>Реактивное</b></summary><p>

  - Ориентированное на потоки данных и распространение изменений. 
  - Парадигма должна существовать возможность легко выражать статические и динамические потоки данных, а также нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.
  - Можно реализовать в **ООП**, в **чистом императивном** стиле и т.д. Естественнее всего реализуется в **функциональном**

  <br></p>
  </details>

[//]: # (Структурное)
- <details><summary><b>Структурное</b></summary><p>

  - Основа — декомпозиция. 
  - По-прежнему оперируем состоянием и инструкциями, однако вводится понятие составной инструкции (блока), инструкций ветвления и цикла.

  <br></p>
  </details>

[//]: # (Модульное)
- <details><summary><b>Модульное</b></summary><p>

  - разделение функциональности на законченные блоки. 
  - Программа описанная в стиле модульного программирования — это набор модулей. Что внутри, классы, императивный код или чистые функции — не важно. 
  - Благодаря модулям впервые в программировании появилась серьезная инкапсуляция — возможно использовать какие-либо сущности внутри модуля, но не показывать их внешнему миру.

  <br></p>
  </details>

[//]: # (Обобщённое)
- <details><summary><b>Обобщённое</b></summary><p>

  - разделение на шаблоны

  <br></p>
  </details>

[//]: # (Экзотические)
- <details><summary><b>Экзотические</b></summary><p>

  - Автоматное
  - Аппликативное, 
  - Аспект/агент/компонент-ориентированное...
  -
  - Немного подробнее: [«Забытые» парадигмы программирования](https://habr.com/ru/post/223253/)

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Про реактивный стиль</b></summary><p>

  - Если кратко: реактивность — это способность реагировать на какие-либо изменения. Но о каких изменениях идет речь? В первую очередь, об изменениях данных. 
  -
  - Пример:
    - ```js
        let a = 2;
        let b = 3; let sum = a + b;console.log(sum); // 5 a = 3;// значение не поменялось, потому что данные нужно пересчитать
        console.log(sum); // 5 
      ```
  -
  - Пример демонстрирует привычную нам императивную парадигму программирования. В отличие от императивного подхода, реактивный подход строится на push стратегии распространения изменений. Push стратегия подразумевает, что в случае изменения данных эти самые изменения будут “проталкиваться”, и зависимые от них данные будут автоматически обновляться. 
  - Вот как бы вел себя наш пример, если бы применялась push стратегия:
    - ```js
        let a = 2;
        let b = 3;let sum = a + b;console.log(sum); // 5a = 3;// значение переменной sum автоматически пересчитается
        console.log(sum); // 6
      ```
  - Данный пример показывает реактивный подход. Стоит отметить, что этот пример не имеет ничего общего с реальностью, я его привел лишь с целью показать разницу в подходах.
  -
  - Классический пример «реактивности» — электронные таблицы Excel: 
    - меняем значение в одной ячейке A1 — все ячейки, которые считают сове значение на основа A1 автоматически пересчитываются, сами.

  <br></p>
  </details>

[//]: # (Прочее)
- <details><summary><b>Прочее</b></summary><p>

  - Декларативный подход читается в среднем легче, хотя на написание в обоих стилях времени может уходить одинаковое количество. (Но это тоже зависит от конкретных разработчиков, потому что кто-то мог привыкнуть к конкретному стилю.)
  - Человеческий мозг может держать одновременно в памяти ограниченное количество объектов. Если мы работаем с какой-то  сложной системой, нам будет трудно одновременно помнить и о том, что она делает, и о том, как она устроена.
  - Императивный стиль смешивает назначение программы и детали её реализации, в то время как декларативный старается  описывать только назначение.
  - Плюсы и минусы зависят от контекста:
    - Если вам нужно детально описать какое-то действие — например при разработке конкретного алгоритма — то больше подходит императивный подход.
    - Если вы работаете на уровне бизнес-логики, то лучше писать декларативно, а детали реализации скрыть в более низком уровне абстракций.

  <br></p>
  </details>

[//]: # (Мультипарадигменные языки)
- <details><summary><b>Мультипарадигменные языки</b></summary><p>

  - Для большой части задач так мы вовсе можем использовать и ФП, и ООП, и процедурное, и логическое программирование. 
  - Некоторые языки ощутимо склоняются к одной парадигме
    - С относится к процедурным языкам, 
    - Java/C++ почти полностью ориентированы на работу с классами, 
    - Haskell от начала до конца относится к функциональным.
  - И есть языки, которые не привязаны к конкретной парадигме. JavaScript как раз один из таких языков. (Именно поэтому мы могли описать пример для каждой парадигмы на нём.)

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Парадигмы программирования](https://doka.guide/js/programming-paradigms/)
  - [Википедия - парадигмы программирования](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
  - [Habr - Чистая архитектура. Часть II — Парадигмы программирования](https://habr.com/ru/post/554474/)
  - [Парадигмы программирования](https://pikabu.ru/story/paradigmyi_programmirovaniya_7584307)
  - [tproger.ru - Функциональное программирование с примерами на JavaScript. Часть 1. Основные техники функционального программирования](https://tproger.ru/translations/functional-js-1/)
  - [tproger.ru - Функциональное программирование с примерами на JavaScript. Часть 2. Аппликативные функторы, curryN и валидации](https://tproger.ru/translations/functional-js-2/)
  - [Medium - Основы реактивного программирования с использованием RxJS] (https://medium.com/ngx/introducing-to-reactive-programming-984c1a390e2d)
  - [doka - Реактивность в программировании](https://doka.guide/tools/reactivity/?ysclid=ln33nzwpuu404244868)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Некоторые принципы программирования)
<details><summary><b>Некоторые принципы программирования</b></summary><p>

  - `DRY` - Don't repeat yourself (Не повторяйся)
  - `KISS` - Keep it simple, stupid (Делай проще, тупица)
  - `YAGNI` - You aren't gonna need it (Вам это не понадобится)
  - `SOLID`
      - (см выше - ООП)
      - Single Responsibility Principle («Принцип единой ответственности», SRP)
      - Open-Closed Principle («Принцип открытости-закрытости», OCP)
      - Liskov Substitution Principle («Принцип подстановки Барбары Лисков», LSP)
      - Interface Segregation Principle («Принцип разделения интерфейса», ISP)
      - Dependency Inversion Principle («Принцип инверсии зависимостей», DIP)
  - `GRASP` - Gneral responsibility assignment software patterns (общие шаблоны распределения ответственностей, паттерны
    проектирования) ООП
      - Информационный эксперт (Information Expert)
      - Создатель (Creator)
      - Контроллер (Controller)
      - Слабое зацепление (Low Coupling)
      - Высокая связность (High Cohesion)
      - Полиморфизм (Polymorphism)
      - Чистое изготовление (Pure Fabrication)
      - Перенаправление (Indirection)
      - Устойчивость к изменениям (Protected Variations)
  - `CQS` - Command-query Separation (Разделение ответственности команд и запросов)
  - `Law of Demeter` - Закон Деметры (см ООП)
  - `SLAP` - Single level of Abstraction Principle (Принцип единого уровня абстракций)
  - 
  - **Интересные идеи на тему**
    - [YouTube - Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)

<br></p>
</details>

[//]: # (Некоторые принципы Объектно Ориентированнаого Дизайна)
<details><summary><b>Некоторые принципы Объектно Ориентированнаого Дизайна</b></summary><p>

  - **Закон Деметры** (англ. Law of Demeter, LoD) - каждый программный модуль:
    - должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение
      к этому модулю.
    - должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.
    - обращаться только к непосредственным «друзьям».
      **Ссылки**
    - [Habr](https://habr.com/ru/post/319652/)
    - [wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
  - **GRASP** (general responsibility assignment software patterns) — общие шаблоны распределения ответственностей
    - Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения.
      Постоянно используешь в объекте какой-то внешний метод? Скорее всего, этот метод должен быть в этом объекте
    - высокое сцепление - код выполняющий одну задачу, должне быть в одном месте
    - низкая связность - модули не должны зависеть друг от друга (если они ссылаются друг на друга - это то же самое что у вас один большой модуль)
    - ... (всего 9 принципов)
    - [Wikipedia](https://ru.wikipedia.org/wiki/GRASP)
  - **CQS** (Command Query Separation)
    - метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. 
    - Другими словами, задавание вопроса не должно менять ответ. 
    - Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов.
    - Другими словами: если я спрашиваю у объекта "Ты админ?", он должен вернуть только tru или false. И не должен внутри заниматься изменением состояния
    - [Wikipediz](https://ru.wikipedia.org/wiki/CQRS)
  - **Single level of Abstraction** (один уровень абстракции)
    - Каждый метод должен быть написан на одном уровне абстракции.
    - [Single level of abstraction (en)](https://medium.com/@yukas/single-level-of-abstraction-1e2bb6a645d7)

  См видео "[Ментальное программирование](https://www.youtube.com/watch?v=EEq1wdM2M2w)"

<br></p>
</details>

[//]: # («Запахи» кода todo: выписать)
<details><summary><b>«Запахи» кода *</b></summary><p>

- [Усачёв М — «Запашки» кода React-компонентов](https://css-live.ru/javascript/zapashki-koda-react-komponentov.html)
- [Wikipedia — Code smell](https://en.wikipedia.org/wiki/Code_smell)
- [Wikipedia — Design smell“](https://en.wikipedia.org/wiki/Design_smell)

<br></p>
</details>

[//]: # (Ссылки)
<details><summary><b>Ссылки</b></summary><p>

  - [Doka - Что такое код-ревью](https://doka.guide/tools/code-review/)
  - [Doka - Что такое технический долг](https://doka.guide/js/technical-debt/)
  - [Wikipedia - Дональд Кнут «Искусство программирования»](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

<br></p>
</details>

<br>
<br>

*[Legmo, 2019-2023](https://github.com/Legmo/notes/)*