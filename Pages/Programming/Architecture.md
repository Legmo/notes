<h1>Архитектура фронтенда</h1>

**Что такое архитектура фронтенда&** 
- совокупность решений об организации программной системы.
- набор решений о том, как модули приложения будут общаться друг с другом и с внешним миром.
- приёмы и методы для решения «проблем сложной системы» в отношении программного обеспечения
<br>
<br>

**Зачем нужна архитектура**
- Причины
  - Организация большого объема кода
  - Дублирование функциональности, переиспользуемость
  - Поддержка
  - Изменение состава команды - порог/время вхождения, bus-фактор
  - Расширение функциональности (!)
  - Ошибки
  - Все причины вместе — **проблемы сложной системы**

- Цель
  - Поддержка жизненного цикла системы. Хорошая архитектура делает систему легкой в освоении, простой в разработке, сопровождении и развертывании. 
  - Минимизировать затраты на протяжении срока службы системы и максимизировать продуктивность программиста (команды разработчиков).

- Цитаты
  - «Всё развитие нашей индустрии можно охарактеризовать как борьбу со сложностью»
  - «Усложнять просто, упрощать сложно.»
    <br>
    <br>

**Что входит в понятие архитектура?**
- файловая структура
- стэк
  <br>
  <br>

**Термины**
- `Паттерн` в архитектуре — шаблонное решение частой архитектурной проблемы.
- `Методология` — свод правил и соглашений по организации кода
<br>
<br>

[//]: # (История вопроса)
<details><summary><b>История вопроса</b></summary><p>

- 1968 — Эдсгер Дейкстра. Статья «Operator GOTO considered harmful» («Оператор GOTO — оператор безусловного перехода — зло»)
- 1970-е — Дейкстра и Дэвид Парнас — развивали идею, в соавторстве и по отдельности
- 1996 — первая подробная книга об архитектуре. Мэри Шоу и Дэвид Гэрлан. «Архитектура программного обеспечения: перспективы новой дисциплины» («Software Architecture: Perspectives on an Emerging Discipline»)
- После этого подробных книг об архитектуре ПО практически не писалось — именно из-за области применения. В каждой сфере знаний есть свои архитектурные подходы, часто не применимые в других областях. Архитектура — процесс творческий => конкретные книги про как писать архитектуру, вы не найдете.
- 2007 — вышел первый стандарт программной архитектуры: «ISO ISO / IEC 42010:2007». «IEEE 1471: ANSI / IEEE 1471 — 2000: Рекомендации по описанию преимущественно программных систем».

<br></p>
</details> 

[//]: # (Некоторые архитектурные подходы)
<details><summary><b>Некоторые архитектурные подходы</b></summary><p>

- MVC, MVP, MVVM, MV* — 19XX
- Компонент-контейнерный подход — 2000-2010
- Domain Driven Design (DDD) — 2003
- Onion Architecture — 2003-2012
- Clean architecture (Чистая архитектура) — 2012
- Атомарная архитектура, atomic design — 2013
- Микросервисная архитектура — 2011
- Feature Based / Feature first — 2010-2016
- Vertical slices — 2010-2016
- Flux, Redux — 2015
- Redux Duсks — 2015
- Business Logic Component (BLoC)
- Feature Driven Architecture (FDA) — 2018
- Feature Sliced Design (FSD) — 2018
- Функциональная архитектура

<br></p>
</details>

[//]: # (Связность и зацепленность)
<details><summary><b>Связность и зацепленность</b></summary><p>

Хорошая архитектура должна обладать низкой связностью, высокой зацепленностью.<br>
`Low coupling, high cohesion`

`Связность` (coupling) — взаимная зависимость модулей между собой.<br> 
Сколько изменений надо внести в модули при изменении другого модуля.<br>
Чем ниже этот показатель — тем лучше.<br>
Плохо кода модули зависят друг от друга — изменили что-то в компоненте User и надо вносить кучу правок в других модулях.

`Зацепленность` (cohesion) — степень общности обязанностей модуля.<br> 
Насколько модуль сфокусирована на решении одной задачи.<br>
Чем выше этот показатель — тем лучше.<br>
Плохо кода модуль решает несколько разных задач (например авторизация и шифрование).


Ссылки:

- [ООП: некоторые принципы разработки программ на C++](https://statmod.ru/3-5/programming/oop_potapov/index.htm)
- [Как написать аккуратный код? Часть вторая: связность](https://bureau.ru/soviet/20200227/?ysclid=l95u4bmvwd168275487)
- [Medium - Low Coupling и High Cohesion](https://medium.com/german-gorelkin/low-coupling-high-cohesion-d36369fb1be9)
- []()

<br></p>
</details>

[//]: # (MV* для web todo: дополнить)
<details><summary><b>MV* для web *</b></summary><p>

***

`Model-View-Controller` (Модель-Вид-Контроллер)<br>
Конструкционный шаблон, архитектурный паттерн, концепция. 1979 г<br>
Описывает способ построения структуры приложения, сферы ответственности и взаимодействие каждой из частей в этой
структуре.

Основная идея: нужно чётко разделять ответственность за различное функционирование в наших приложениях.<br>
Делим приложение на 3 основных компонента, каждый отвечает за свои задачи.
Модификация каждого компонента может осуществляться независимо.

- `Model` - обработка данных и логика приложения
- `View` - представление данных пользователю (в любом формате). Пользовательский интерфейс
- `Controller` - обработка действий пользователя, вызов соответствующих ресурсов. Логика управления

Концепция стала популярна благодаря включению в две среды разработки: Struts и Ruby on Rails.

**Модификации**<br>
Есть много модификаций шаблона MV* 
- HMVC (Hierarchical MVC) и другие


[//]: # (Model)
<details><summary><b>Model</b></summary><p>

Для извлечения и манипуляций данными приложения.<br>
Данные и правила, которые используются для работы с данными.<br>
Содержит логику управления данными.

Только данные, которые должны быть обработаны в соответствии с правилами (дата не может указывать в будущее, e-mail
должен быть в определённом формате, имя не может быть длиннее Х символов, и так далее).

Даёт контроллеру представление данных, которые запросил пользователь (сообщение, страницу книги, фотоальбом, и тому
подобное). Модель данных будет одинаковой, вне зависимости от того, как мы хотим представлять их пользователю (таблицей,
списком...).

<br></p>
</details>

[//]: # (View &#40;Представление, Вид&#41;)
<details><summary><b>View (Представление, Вид)</b></summary><p>

Отвечает за видимое пользователю отображение этих данных.
Применительно к web — формирует отдаваемый сервером браузеру пользователя HTML/CSS.

Обеспечивает различные способы представления данных, которые получены из модели.<br>
Это может быть шаблон, который заполняется данными. Может быть несколько различных view, и контроллер выбирает, какой
подходит наилучшим образом для текущей ситуации.

<br></p>
</details>

[//]: # (Controller)
<details><summary><b>Controller</b></summary><p>

Управляет всем этим оркестром. Содержит организационную логику.

Обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и
представление для реализации необходимой реакции.

Контроллер может быть устроен так:

- основной котнтроллер - получает все запросы
- он вызывает другие контроллеры - для выполнения действий в зависимости от ситуации.

<br></p>
</details>

[//]: # (Стандартная схема работы MVC)
<details><summary><b>Стандартная схема работы MVC</b></summary><p>

- Контроллер получает запрос
- Посылает команду Модели на работу с данными
- В зависимости от ответа Модели Контроллер решает - какое из Представлений вызвать для формирования итогового ответа на
  изначальный Запрос
- Представление по команде Контроллера меняет отображение информации на экране.
- Пользователь взаимодействует с Представлением (кликает по кнопке, например), и тем самым формирует новый запрос к
  Контроллеру

Веб приложение обычно состоит из набора контроллеров, моделей и видов.


<br></p>
</details>

[//]: # (MV* для React & Redux)
<details><summary><b>MVC для React & Redux</b></summary><p>

**Вариант 1**
- Model = State. Состояние, хранящееся в Redux Store
- View = React компоненты без хуков и своего стейта.
- Controller = Redux (Reducer, Action)
<br>
<br>

**Вариант 2**
- Model = Redux
- View = React
- Controller = React-redux. Обёртка, которая принимает стейт, диспатчит ActionCreators и т. При условии, что никаких "
  умных" компонент со своим стейтом и т.д.

<br></p>
</details>

[//]: # (Model-View-View Model)
<details><summary><b>Model-View-View Model</b></summary><p>

Позволяет связывать элементы представления со свойствами и событиями View-модели.<br>
Каждый слой этого паттерна не знает о существовании другого слоя.

Для MVVM связывание представления с View-моделью осуществляется автоматически, а для MVP — необходимо программировать

Используется в ситуации, когда возможно «связывание данных» без необходимости ввода специальных интерфейсов представления.

Используется для разделения модели и её представления, что необходимо для их изменения отдельно друг от друга.<br>
Например, разработчик задаёт логику работы с данными, а дизайнер работает с пользовательским интерфейсом.

MVVM удобно использовать вместо классического MVC и ему подобных когда в платформе есть «связывание данных».<br> 
В MVC/MVP изменения в пользовательском интерфейсе не влияют непосредственно на Mодель, а предварительно идут через Контроллер или Presenter. 
В MVVM (например WPF и Silverlight) есть концепция «связывания данных», позволяющая связывать данные с визуальными элементами в обе стороны. Следовательно, при использовании этого приёма применение модели MVC становится крайне неудобным из-за того, что привязка данных к представлению напрямую не укладывается в концепцию MVC/MVP.


**Шаблон MVVM состоит из трёх частей**
- `Модель` — логика работы с данными и описание фундаментальных данных, необходимых для работы приложения.
- `Представление` — графический интерфейс (окна, списки, кнопки и т. п.). 
  - Выступает подписчиком на событие изменения значений свойств или команд, предоставляемых `Моделью Представления`. 
  - Если в `Модели Представления` изменилось свойство — она оповещает всех подписчиков об этом, и Представление запрашивает обновлённое значение свойства из `Модели Представления`. 
  - Если пользователь воздействует на интерфейс, Представление вызывает соот. команду, предоставленную `Моделью Представления`.
- `Модель Представления` (ViewModel) — абстракция Представления + обёртка данных из Модели, подлежащиx связыванию. 
  - Содержит 
    - Модель, преобразованную к Представлению, 
    - команды, которыми может пользоваться Представление, чтобы влиять на Модель.

<br></p>
</details>

[//]: # (Картинки)
<details><summary><b>Картинки</b></summary><p>

<img src="/Assets/Img/architecture-mv-1.jpg" title="Схема 1" alt="Схема 1" />

<br></p>
</details>

**Ссылки**

- [Концепция MVC для чайников](https://ruseller.com/lessons.php?id=666)
- [MVC для веб: проще некуда](https://habr.com/ru/post/181772/)
- [Habr - Честный MVC на React + Redux (2016)](https://habr.com/ru/company/developersoft/blog/305812/)
- [Doka - Архитектурный паттерн MVC ](https://doka.guide/js/architecture-mvc/)
- [Medium - Прощай, Redux (2018)](https://medium.com/devschacht/jack-scott-goodbye-redux-4f11cc3c6af5)

***

<br></p>
</details>

[//]: # (Domain Driven Design, DDD)
<details><summary><b>Domain Driven Design, DDD</b></summary><p>

`Domain Driven Design` (предметно-ориентированное проектирование) - подход построения моделей программных продуктов.

DDD не связан с технологиями. Это про архитектуру.<br>
Вместо этого речь идет о развитии знаний о бизнесе и использовании технологий для обеспечения ценности.

Книга Эрика Эванса «Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем»<br>
Рекоменация Кузебюрдина (It-Kamasutra)

Программное обеспечение это не только код. Код редко является конечной целью вашей работы. Код это только средства
решения бизнес-задач. Так почему код должен быть на языке отличном от языка бизнеса? DDD подчеркивает что код и бизнес
должны говорить на одном языке. Когда барьер преодолён, нет необходимости в переводе или утомительной синхронизации,
информация не потеряется. Каждый участник влияет на Бизнес-Домен, не только разработчики. Получающееся программное
обеспечение - единственная правда для общего языка.

Три основных понятия:

- Единый Язык (Ubiquitous Language)
- Стратегическое моделирование (Strategic Design)
- Тактическое моделирование (Tactical Design)


**Картинки**

<img src="/Assets/Img/architecture-ddd-1.jpg" title="Схема 1" alt="Схема 1" />

<br>
<br>

**Ссылки**

- [Habr - Domain Driven Design на практике](https://habr.com/ru/post/334126/)
- [Domain Driven Design (DDD) - что это такое? И как начать использовать DDD в разработке](https://blog-programmista.ru/post/132-ddd-what-is-it.html)
- [Что можно узнать о Domain Driven Design за 10 минут?](https://itnan.ru/post.php?c=1&p=489352)
- []()

<br></p>
</details>

[//]: # (Feature Sliced Design, FSD)
<details><summary><b>Feature Sliced Design, FSD</b></summary><p>

`Feature Sliced Design` - методология проектирования архитектуры frontend-приложений.<br>
Свод правил и соглашений по организации кода

Полезна для средних и больших проектов, которые будут в вашем распоряжении несколько лет.<br>
Учитывает регулярные изменения требований бизнеса.

Не привязана к конкретному языку программирования, UI-фреймворку или менеджеру состояния. 

Одним из минусов является высокий порог входа.<br>
Разработчик должен понимать как работает этот подход и при разработке очередного модуля вам придется подумать о правильности его расположения.

Выделяются следующие архитектурные абстракции:
- `слои` - по области влияния
    - app - инициализация приложения (init, styles, providers, ...);
    - processes - бизнес-процессы приложения управляющие страницами (payment, auth, ...);
    - pages - страницы приложения (user-page, ...);
    - features - части функциональности приложения (auth-by-oauth, ...);
    - entities - бизнес-сущности (viewer, order, ...);
    - shared - переиспользуемый инфраструктурный код (UIKit, libs, API, ...).
- `слайсы` - по бизнес-домену
  - разделение кода на слайсы зависит от проекта, не определяется методологией
  - Например:
    - user
    - post
    - comment
- `сегменты` - по назначению в реализации
    - ui - UI-представление модуля (components, widgets, canvas, ...);
    - model - бизнес-логика модуля (store, effects/actions, hooks/contracts, ...);
    - lib - вспомогательные библиотеки;
    - api - логика взаимодействия с API;
    - config - модуль конфигурации приложения и его окружения.

\*\*\*

- Методология состоит из разделения на 
  - страницы
  - виджеты
  - фичи
  - сущности
  - shared-компоненты

- В папке каждой сущности, виджета, страницы происходит разделение на 
  - /ui, 
  - /lib, 
  - /model. 
 
Основная сложность при использовании методологии заключается в том, чтобы грамотно разбить код.<br>
Всегда проще просто взять, вынести компоненты фичи в папку `/components`, но со временем - с ростом проекта - приходит понимание того, что не всё так просто, и длинная папка `/components` может не радовать, как и размазывание логики фичи по множеству папок, будь то `/redux` или какая-нибудь `/core` папка, куда складываются бизнес-сущности и их логика.


**Ссылки**
- [Оф. сайт](https://feature-sliced.design/)
- [Habr - Архитектура фронтенда и какой она должна быть (2022)](https://habr.com/ru/post/667214/)
- [Илья Азин (Яндекс) — Доклад Feature-Sliced Design (2021, YouTube)](https://www.youtube.com/watch?v=af-PD2yIUiU)
- [Методология "feature-sliced" - идеальный способ структурировать растущий проект?](https://okusov.ru/metodologiya-feature-sliced-idealnyj-sposob-strukturirovat-rastushij-proekt)
- [Структура frontend-приложений. Миф или реальность? (2022)](https://vc.ru/s/fly-code/512625-struktura-frontend-prilozheniy-mif-ili-realnost)
- []()

<br></p>
</details>

[//]: # (Clean architecture. Чистая архитектура)
<details><summary><b>Clean architecture (Чистая архитектура)</b></summary><p>

***

2012 г.

`Чистая архитектура` — способ разделения ответственностей и частей функциональности по степени их близости к предметной области приложения.<br>

`Предметная область` (домен) — часть реального мира, которую моделируем программой. <br>
Такие преобразования данных, которые отражают преобразования в реальном мире.<br>
Например, если мы обновили название товара, то замена старого имени на новое и есть преобразование предметной области (доменное преобразование).

Также называют `трёхслойной арзитектурой` — приложение делится на слои
- `домен` в центре
- `прикладной слой` вокруг него
- `слой адаптеров` снаружи

Чем дальше мы от центра — тем функциональность кода более «сервисная», тем дальше она от предметной области нашего приложения.<br>
Это важно когда мы принимаем решение, к какому слою отнести какой-либо модуль.

[//]: # (Слой 1 — домен)
<details><summary><b>Слой 1 — домен</b></summary><p>

Сущности и данные, которые описывают предметную область приложения и код для преобразования этих данных.

Например, для магазина это: 
- сущности: товары, заказы, пользователи, корзина 
- функции для обновления их данных.

Ядро, которое отличает одно приложение от другого.<br>
То, что точно не поменяется, если мы будем переезжать с React на Angular, или если изменим какой-то пользовательский сценарий.<br>

Структура данных доменных сущностей и суть их преобразований не зависит от внешних обстоятельств.<br>
Внешние обстоятельства запускают доменные преобразования, но не определяют, как они будут протекать.

Для функции добавления товара в корзину неважно, как именно товар был добавлен: самим пользователем через кнопку «Купить» или автоматически по промо-коду. Она в обоих случаях будет принимать товар и возвращать обновлённую корзину с добавленным товаром.
<br></p>
</details>

[//]: # (Слой 2 — прикладной)
<details><summary><b>Слой 2 — прикладной</b></summary><p>

Здесь описываются `юзкейсы` и `порты`. <br>

`Юзкейсы` — пользовательские сценарии. <br>
Отвечают за то, что происходит после возникновения какого-то события.

Например, сценарий «Положить товар в корзину» — это юзкейс. <br>
Описывает действия, которые должны произойти после нажатия на кнопку. 
Говорит:
- сходи на сервер, отправь такой запрос;
- теперь выполни такое-то доменное преобразование;
- а теперь перерисуй UI, используя новые данные.

`Порты` — спецификации того, как наше приложение хочет, чтобы с ним общался внешний мир. Интерфейсы, контракты на поведение.<br>
Служат «буфером» между хотелками нашего приложения и реалиями внешнего мира.<br> 

`Входные порты` (Input Ports) — говорят, как приложение хочет, чтобы к нему обращались извне.<br> 
`Выходные порты` (Output Ports) — говорят, как приложение собирается общаться с внешним миром.
<br></p>
</details>

[//]: # (Слой 3 — адаптеры)
<details><summary><b>Слой 3 — адаптеры</b></summary><p>

`Адаптеры` превращают несовместимое API внешних сервисов в совместимое с хотелками нашего приложения.

Адаптеры — способ понизить зацепление между нашим кодом и кодом сторонних сервисов.<br> 
Низкое зацепление уменьшает необходимость менять один модуль при изменении других.

Во фронтенде чаще всего адаптеры — это UI-фреймворк и модуль запросов к API-серверу. <br>
Например:
- UI-фреймворк;
- модуль запросов к API;
- адаптер для работы с локальным хранилищем (Local storage Browser API);
- адаптеры и конвертеры ответов API к прикладному слою.

Адаптеры часто делят на:
- `управляющие` (driving) — которые посылают сигналы нашему приложению;
  - с ними чаще всего взаимодействует пользователь
  - например, обработка нажатия кнопки UI-фреймворком — это работа управляющего адаптера. Он работает с браузерным API (по сути сторонним сервисом) и преобразует событие в понятный нашему приложению сигнал.
- `управляемые` (driven) — которые получают сигналы от нашего приложения.
  - взаимодействуют с инфраструктурой.
  - во фронтенде большая часть инфраструктуры — это бекенд-сервер, но иногда мы можем взаимодействовать и с какими-то другими сервисами напрямую, например, с поисковым движком.
<br></p>
</details>

[//]: # (Правило зависимостей)
<details><summary><b>Правило зависимостей</b></summary><p>

Только внешние слои могут зависеть от внутренних. 

Следствия:
- домен должен быть независим;
- прикладной слой может зависеть от домена;
- внешние слои могут зависеть от чего угодно.

<br></p>
</details>

[//]: # (Плюсы чистой архитектуры)
<details><summary><b>Плюсы чистой архитектуры</b></summary><p>

- Обособленный домен
  Вся главная функциональность приложения обособлена и собрана в одном месте — в домене. Функциональность в домене независима, а значит, её проще тестировать. Чем меньше у модуля зависимостей, тем меньше нужно инфраструктуры для тестирования, меньше нужно моков и стабов.
  Также обособленный домен проще проверять на соответствие ожиданиям бизнеса. Это помогает новым разработчикам быстрее сориентироваться с тем, что приложение должно делать. Кроме того, обособленный домен помогает быстрее искать ошибки и неточности «перевода» с языка бизнеса на язык программирования.
  - Независимые юзкейсы
  Сценарии приложения, юзкейсы, описаны отдельно. Именно они диктуют, какие сторонние сервисы понадобятся. Мы подстраиваем внешний мир под свои нужды, а не наоборот — это даёт больше свободы в выборе сторонних сервисов. Например, мы можем быстро поменять платёжную систему, если нынешняя стала требовать слишком большую комиссию.
  Также код юзкейсов получается плоским, тестируемым и расширяемым. Мы увидим это на примере позже.
- Заменяемые сторонние сервисы 
  - Внешние сервисы становятся заменяемыми благодаря адаптерам. Пока мы не меняем интерфейс взаимодействия с приложением, нам не важно, какой именно внешний сервис будет реализовывать этот интерфейс.
  Таким образом мы создаём барьер для распространения изменений: изменения в чужом коде не влияют напрямую на наш. Адаптеры также ограничивают и распространение ошибок во время работы приложения.

<br></p>
</details>

[//]: # (Недостатки)
<details><summary><b>Недостатки</b></summary><p>

- Требует времени 
  - Не только на проектирование, но и на реализацию. Всегда проще вызвать сторонний сервис напрямую, чем писать адаптеры. 
- Иногда излишне многословна 
- Завышает порог входа 
- Увеличивает количество кода
<br></p>
</details>

[//]: # (Картинки)
<details><summary><b>Картинки</b></summary><p>

<img src="/Assets/Img/architecture-clean-1.jpg" title="Схема 1" alt="Схема 1" />
<br></p>
</details>

**Ссылки**
- [Robert C. Martin - The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Беспоясов А - Чистая архитектура во фронтенде](https://bespoyasov.ru/blog/clean-architecture-on-frontend/)
- [Беспоясов А - Чистая архитектура во фронтенде. Доклад (YouTube)](https://youtu.be/h4WQRqNjmX0)
- [Беспоясов А - Чистая архитектура во фронтенде. Слайды к докладу](https://bespoyasov.ru/slides/clean-architecture-on-frontend/)

<br></p>
</details>

[//]: # (Атомарный дизайн)
<details><summary><b>Атомарный дизайн</b></summary><p>

Модульная методология для создания библиотек паттернов, простых в поддержке, масштабировании и развитии.<br>
Создание крупных и сложных UI-компонентов из более мелких и простых.

Брэд Фрост, 2016.<br>

5 категорий компонентов:
- `атомы` - неделимы элементы. Кнопка, ссылка, цвет
- `молекулы` - несколько атомов. Строка поиска - текстовое поле + кнопка + пиктограмма + подсказки
- `организмы` - несколько молекул и атомов. Шапка сайта 
- `шаблон` - законченные веб-страницы или экраны приложений (но с тестовым контентом)
- `страницы` - шаблон, заполненный реальным контентом (картинками, текстами и т.д.)

Примеры реализации
- [Storybook](https://storybook.js.org/) - инструмент для разработки и управления библиотекой UI компонентов. Open Source
- [Pattern Lab](https://patternlab.io/) - генератор статических сайтов, использующий методологию атомарного дизайна.

Ссылки:

- [Habr - Атомарный веб-дизайн (2015)](https://habr.com/ru/post/249223/)
- [Брэд Фрост — Атомарный дизайн (перевод)](https://medium.com/%D0%B0%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD/atomic-design-foreword-4960ad17bc1a)
- [Всё, что вам нужно знать об атомарном дизайне](https://deadsign.ru/ui/everything-you-need-to-know-about-atomic-design/)

<br></p>
</details>

[//]: # (Feature first)
<details><summary><b>Feature first</b></summary><p>

Большое приложение должно быть набором небольших приложений, которые функционируют изолированно.

`Feature` — единица проекта, на основе разнообразия которых строится продукт.
`Feature-first` — предполагает, что все компоненты, объединенные общей логикой и интерфейсом, являются фичей и располагаются в одном месте.

Иногда под `features` понимают пользовательские сценарии.<br>
Например — добавление товара в корзину, пополнение кошелька.<br>
Есть сущности (пользователь, товар, корзина), есть действия которые мы с ними можем соврешить - подписатьсся на пользователя, зарегистрировать его, авторизовать... Эти действия — features.

Открывая папку feature/Profile, мы находим весь код, относящийся к функционалу профиля пользователя и сразу получаем представление, как это работает.

Похоже на микросервисную архитектуру.

Общий подход:
- Вне папки компонента нет файлов, которые связывают его с приложением. 
- Когда вы используете компонент в приложении — вы импортируете его, как если бы это был любой другой модуль или библиотека. Вплоть до включения файла Readme.md в папку каждого компонента.

Преимущества:
- вы поощряете изоляцию и инкапсуляцию ваших компонентов пользовательского интерфейса. Вы буквально гарантируете, что компоненты вашего приложения будут повторно использоваться в будущих проектах.

\*\*\*

**Ссылки**
- [Организация кода в масштабных React проектах.(2018)](https://blogru.4xxi.com/%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B2-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%BD%D1%8B%D1%85-react-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0%D1%85-bc00ce1621e3)
-[Medium - Feature First Organization (2016)](https://medium.com/front-end-weekly/the-secret-to-organization-in-functional-programming-913484e85fc9)

<br></p>
</details>

[//]: # (Redux Duсks)
<details><summary><b>Redux Duсks</b></summary><p>

См [Legmo Notes - React. Ducks](../JS/React.md#ducks)

<br></p>
</details>

[//]: # (Функциональная архитектура)
<details><summary><b>Функциональная архитектура</b></summary><p>

Примерно так: 
- до начала работы с кодом анализируем будущий продукт
- решаем какие потребуются функции 
- выделяем функции общие для разных частей 
- расставляем их по рейтингу и т.д. 

- [Шерер П - Функциональная архитектура цифровых продуктов. Часть 1](https://sherer-pro.turbopages.org/sherer.pro/s/blog/funkcionalnaja-arhitektura-cifrovyh-produktov-chast-1/)
- [Шерер П - Функциональная архитектура цифровых продуктов. Часть 2](https://sherer-pro.turbopages.org/sherer.pro/s/blog/funkcionalnaja-arhitektura-cifrovyh-produktov-chast-2/)
- [Шерер П - Функциональная архитектура цифровых продуктов. Часть 3](https://sherer-pro.turbopages.org/sherer.pro/s/blog/funkcionalnaya-arxitektura-cifrovyx-produktov-chast-3/?last_related=1&turbo_feed_type=full)

<br></p>
</details>

[//]: # (Микросервисная архитектура)
<details><summary><b>Микросервисная архитектура</b></summary><p>

См [Legmo Notes - Микросервисная архитектура](../WebDeveloping/Microservices.md)

<br></p>
</details>

**Ссылки**

- [Карпелевич А - Верхнеуровневая архитектура фронтенда. Лекция Яндекса. Видео + расшифровка (2018)](https://itnan.ru/post.php?c=1&p=425611)
- [Habr - «Откуда ноги растут» или что предшествует программированию?](https://habr.com/ru/company/otus/blog/493898/)
- [Habr - Архитектура фронтенда и какой она должна быть](https://habr.com/ru/post/667214/)
- [Doka - Архитектура и паттерны проектирования](https://doka.guide/js/architecture-and-design-patterns/)
- [Doka - Трёхслойная архитектура (Чистая архитектура, Clear architecture)](https://doka.guide/js/clean-architecture/)
- [Doka - Организация потоков данных (Flux)](https://doka.guide/js/architecture-data-flow/)
- [Беспоясов А - Чистая архитектура во фронтенде](https://bespoyasov.ru/blog/clean-architecture-on-frontend/)
- [Яндекс - Разработка фичи: как эффективно пройти путь от идеи до реализации](https://academy.yandex.ru/journal/razrabotka-fichi-kak-effektivno-projti-put-ot-idei-do-realizacii)
- [Medium - Проволочки при проектировании структуры React приложения](https://medium.com/@vladimirmorulus/%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-react-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-609f80105e2c)
- [Hexlet - Курс «JS: Архитектура фронтенда»](https://ru.hexlet.io/courses/js-frontend-architecture)
- [Legmo Notes - Паттерны проектирования](./Pattern.md)
- [Legmo Notes - Микросервисная архитектура](../WebDeveloping/Microservices.md)
- 
- [Habr - Масштабирование Redux-приложения с помощью ducks (2020)](https://habr.com/ru/company/otus/blog/492638/?ysclid=l6sz05stk7523793176)
- [Habr - Как организовать большое React-приложение и сделать его масштабируемым (2017)](https://habr.com/ru/company/nix/blog/329060/)
- 
- [Habr - Как два программиста хлеб пекли (2012)](https://habr.com/ru/post/153225/)
- [Doka - Что такое код-ревью](https://doka.guide/tools/code-review/)
- [Doka - Что такое технический долг](https://doka.guide/js/technical-debt/)
- [Habr - Архитектура для пользователей (VK-video)](https://habr.com/ru/company/vk/blog/687752/)

<br>
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*