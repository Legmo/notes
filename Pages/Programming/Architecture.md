<h1>Архитектура фронтенда</h1>

**Базовые темы**
- Что такое архитектура фронтенда? 
  - набор решений о том, как модули приложения будут общаться друг с другом и с внешним миром.
  - совокупность решений об организации программной системы.
- Зачем нужна архитектура?
  - Причины
    - Организация большого объема кода
    - Дублирование функциональности, переиспользуемость
    - Поддержка
    - Изменение состава команды - порог/время вхождения, bus-фактор
    - Расширение функциональности (!)
    - Ошибки
  - Идеи
    - Все причины вместе — проблемы сложной системы
    - Главное предназначение архитектуры — поддержка жизненного цикла системы. Хорошая архитектура делает систему легкой в освоении, простой в разработке, сопровождении и развертывании. 
    - Конечная цель — минимизировать затраты на протяжении срока службы системы и максимизировать продуктивность программиста, а если быть точнее, команды разработчиков.
- Что входит в понятие архитектура?
  - файловая структура, стэк
- Паттерн в архитектуре
  - шаблонное решение частой архитектурной проблемы.
- Методология
  - свод правил и соглашений по организации кода
- История вопроса
  - 1968 — Эдсгер Дейкстра. Статья «Operator GOTO considered harmful» («Оператор GOTO — оператор безусловного перехода — зло»)
  - 1970-е — Дейкстра и Дэвид Парнас — развивали идею, в соавторстве и по отдельности
  - 1996 — первая подробная книга об архитектуре. Мэри Шоу и Дэвид Гэрлан. «Архитектура программного обеспечения: перспективы новой дисциплины» («Software Architecture: Perspectives on an Emerging Discipline»)
  - После этого подробных книг об архитектуре ПО практически не писалось — именно из-за области применения. В каждой сфере знаний есть свои архитектурные подходы, часто не применимые в других областях. Архитектура — процесс творческий => конкретные книги про как писать архитектуру, вы не найдете.
  - 2007 — вышел первый стандарт программной архитектуры: «ISO ISO / IEC 42010:2007». «IEEE 1471: ANSI / IEEE 1471 — 2000: Рекомендации по описанию преимущественно программных систем».
- Некоторые архитектурные подходы
  - Feature Based
  - Компонент-контейнерный подход
  - MVC
  - MVP
  - MVVM
  - MV*
  - Атомарная архитектура, atomic design
  - Domain Driven Design (DDD)
  - Vertical slices
  - Чистая архитектура (Clear architecture)
  - Flux, Redux
  - Business Logic Component (BLoC)
  - Feature Sliced Design (FSD)
  - DUCKS

[//]: # (Связность и зацепленность)
<details><summary><b>Связность и зацепленность</b></summary><p>

`Связность` (coupling) — взаимная зависимость модулей между собой.<br> 
Сколько изменений надо внести в модули при изменении другого модуля.<br>
Чем ниже этот показатель — тем лучше.<br>
Плохо кода модули зависят друг от друга — изменили что-то в компоненте User и надо вносить кучу правок в других модулях.

`Зацепленность` (cohesion) — степень общности обязанностей модуля.<br> 
Насколько модуль сфокусирована на решении одной задачи.<br>
Чем выше этот показатель — тем лучше.<br>
Плохо кода модуль решает несколько разных задач (например авторизация и шифрование).

Хорошая архитектура должна обладать низкой связностью, высокой зацепленностью.<br>
`Low coupling, high cohesion`

Ссылки:

- [ООП: некоторые принципы разработки программ на C++](https://statmod.ru/3-5/programming/oop_potapov/index.htm)
- [Как написать аккуратный код? Часть вторая: связность](https://bureau.ru/soviet/20200227/?ysclid=l95u4bmvwd168275487)
- [Medium - Low Coupling и High Cohesion](https://medium.com/german-gorelkin/low-coupling-high-cohesion-d36369fb1be9)
- []()

<br></p>
</details>

[//]: # (MV* для web todo: дополнить)
<details><summary><b>MV* для web *</b></summary><p>

`Model-View-Controller` (Модель-Вид-Контроллер)<br>
Конструкционный шаблон, архитектурный паттерн, концепция. 1979 г<br>
Описывает способ построения структуры приложения, сферы ответственности и взаимодействие каждой из частей в этой
структуре.

Основная идея: нужно чётко разделять ответственность за различное функционирование в наших приложениях.<br>
Делим приложение на 3 основных компонента, каждый отвечает за свои задачи.
Модификация каждого компонента может осуществляться независимо.

- `Model` - обработка данных и логика приложения
- `View` - представление данных пользователю (в любом формате). Пользовательский интерфейс
- `Controller` - обработка действий пользователя, вызов соответствующих ресурсов. Логика управления

Концепция стала популярна благодаря включению в две среды разработки: Struts и Ruby on Rails.

**Model**<br>
Для извлечения и манипуляций данными приложения.<br>
Данные и правила, которые используются для работы с данными.<br>
Содержит логику управления данными.

Только данные, которые должны быть обработаны в соответствии с правилами (дата не может указывать в будущее, e-mail
должен быть в определённом формате, имя не может быть длиннее Х символов, и так далее).

Даёт контроллеру представление данных, которые запросил пользователь (сообщение, страницу книги, фотоальбом, и тому
подобное). Модель данных будет одинаковой, вне зависимости от того, как мы хотим представлять их пользователю (таблицей,
списком...).

**View (Представление, Вид)**<br>
Отвечает за видимое пользователю отображение этих данных.
Применительно к web — формирует отдаваемый сервером браузеру пользователя HTML/CSS.

Обеспечивает различные способы представления данных, которые получены из модели.<br>
Это может быть шаблон, который заполняется данными. Может быть несколько различных view, и контроллер выбирает, какой
подходит наилучшим образом для текущей ситуации.

**Controller**<br>
Управляет всем этим оркестром. Содержит организационную логику.

Обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и
представление для реализации необходимой реакции.

Контроллер может быть устроен так:

- основной котнтроллер - получает все запросы
- он вызывает другие контроллеры - для выполнения действий в зависимости от ситуации.

**Стандартная схема работы:**<br>

- Контроллер получает запрос
- Посылает команду Модели на работу с данными
- В зависимости от ответа Модели Контроллер решает - какое из Представлений вызвать для формирования итогового ответа на
  изначальный Запрос
- Представление по команде Контроллера меняет отображение информации на экране.
- Пользователь взаимодействует с Представлением (кликает по кнопке, например), и тем самым формирует новый запрос к
  Контроллеру

Веб приложение обычно состоит из набора контроллеров, моделей и видов.

**Модификации**<br>
Есть много модификаций шаблона MVC -HMVC (Hierarchical MVC) и другие

**MVC для React & Redux**<br>

- Model = State. Состояние, хранящееся в Redux Store
- View = React компоненты без хуков и своего стейта.
- Controller = Redux (Reducer, Action)

Другой вариант

- Model = Redux
- View = React
- Controller = React-redux. Обёртка, которая принимает стейт, диспатчит ActionCreators и т. При условии, что никаких "
  умных" компонент со своим стейтом и т.д.



**Ссылки**

- [Концепция MVC для чайников](https://ruseller.com/lessons.php?id=666)
- [MVC для веб: проще некуда](https://habr.com/ru/post/181772/)
- [Habr - Честный MVC на React + Redux (2016)](https://habr.com/ru/company/developersoft/blog/305812/)
- [Doka - Архитектурный паттерн MVC ](https://doka.guide/js/architecture-mvc/)
- [Medium - Прощай, Redux (2018)](https://medium.com/devschacht/jack-scott-goodbye-redux-4f11cc3c6af5)

<br></p>
</details>

[//]: # (Domain Driven Design, DDD)
<details><summary><b>Domain Driven Design, DDD</b></summary><p>

`Domain Driven Design` (предметно-ориентированное проектирование) - подход построения моделей программных продуктов.

DDD не связан с технологиями. Это про архитектуру.<br>
Вместо этого речь идет о развитии знаний о бизнесе и использовании технологий для обеспечения ценности.

Книга Эрика Эванса «Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем»<br>
Рекоменация Кузебюрдина (It-Kamasutra)

Программное обеспечение это не только код. Код редко является конечной целью вашей работы. Код это только средства
решения бизнес-задач. Так почему код должен быть на языке отличном от языка бизнеса? DDD подчеркивает что код и бизнес
должны говорить на одном языке. Когда барьер преодолён, нет необходимости в переводе или утомительной синхронизации,
информация не потеряется. Каждый участник влияет на Бизнес-Домен, не только разработчики. Получающееся программное
обеспечение - единственная правда для общего языка.

Три основных понятия:

- Единый Язык (Ubiquitous Language)
- Стратегическое моделирование (Strategic Design)
- Тактическое моделирование (Tactical Design)

Ссылки:

- [Habr - Domain Driven Design на практике](https://habr.com/ru/post/334126/)
- [Domain Driven Design (DDD) - что это такое? И как начать использовать DDD в разработке](https://blog-programmista.ru/post/132-ddd-what-is-it.html)
- [Что можно узнать о Domain Driven Design за 10 минут?](https://itnan.ru/post.php?c=1&p=489352)
- []()

<br></p>
</details>

[//]: # (Feature Sliced Design, FSD)
<details><summary><b>Feature Sliced Design, FSD</b></summary><p>

`Feature Sliced Design` - методология проектирования архитектуры frontend-приложений.<br>
Свод правил и соглашений по организации кода

Полезна для средних и больших проектов, которые будут в вашем распоряжении несколько лет.<br>
Учитывает регулярные изменения требований бизнеса.

Не привязана к конкретному языку программирования, UI-фреймворку или менеджеру состояния. 

Одним из минусов является высокий порог входа.<br>
Разработчик должен понимать как работает этот подход и при разработке очередного модуля вам придется подумать о правильности его расположения.

Выделяются следующие архитектурные абстракции:
- `слои` - по области влияния
    - app - инициализация приложения (init, styles, providers, ...);
    - processes - бизнес-процессы приложения управляющие страницами (payment, auth, ...);
    - pages - страницы приложения (user-page, ...);
    - features - части функциональности приложения (auth-by-oauth, ...);
    - entities - бизнес-сущности (viewer, order, ...);
    - shared - переиспользуемый инфраструктурный код (UIKit, libs, API, ...).
- `слайсы` - по бизнес-домену
  - разделение кода на слайсы зависит от проекта, не определяется методологией
  - Например:
    - user
    - post
    - comment
- `сегменты` - по назначению в реализации
    - ui - UI-представление модуля (components, widgets, canvas, ...);
    - model - бизнес-логика модуля (store, effects/actions, hooks/contracts, ...);
    - lib - вспомогательные библиотеки;
    - api - логика взаимодействия с API;
    - config - модуль конфигурации приложения и его окружения.

\*\*\*

- Методология состоит из разделения на 
  - страницы
  - виджеты
  - фичи
  - сущности
  - shared-компоненты

- В папке каждой сущности, виджета, страницы происходит разделение на 
  - /ui, 
  - /lib, 
  - /model. 
 
Основная сложность при использовании методологии заключается в том, чтобы грамотно разбить код.<br>
Всегда проще просто взять, вынести компоненты фичи в папку `/components`, но со временем - с ростом проекта - приходит понимание того, что не всё так просто, и длинная папка `/components` может не радовать, как и размазывание логики фичи по множеству папок, будь то `/redux` или какая-нибудь `/core` папка, куда складываются бизнес-сущности и их логика.


Ссылки:

- [Оф. сайт](https://feature-sliced.design/)
- [Habr - Архитектура фронтенда и какой она должна быть (2022)](https://habr.com/ru/post/667214/)
- [Илья Азин (Яндекс) — Доклад Feature-Sliced Design (2021, YouTube)](https://www.youtube.com/watch?v=af-PD2yIUiU)
- [Методология "feature-sliced" - идеальный способ структурировать растущий проект?](https://okusov.ru/metodologiya-feature-sliced-idealnyj-sposob-strukturirovat-rastushij-proekt)
- [Структура frontend-приложений. Миф или реальность? (2022)](https://vc.ru/s/fly-code/512625-struktura-frontend-prilozheniy-mif-ili-realnost)
- []()

<br></p>
</details>

[//]: # (Атомарный дизайн)
<details><summary><b>Атомарный дизайн</b></summary><p>

Модульная методология для создания библиотек паттернов, простых в поддержке, масштабировании и развитии.<br>
Создание крупных и сложных UI-компонентов из более мелких и простых.

Брэд Фрост, 2016.<br>

5 категорий компонентов:
- `атомы` - неделимы элементы. Кнопка, ссылка, цвет
- `молекулы` - несколько атомов. Строка поиска - текстовое поле + кнопка + пиктограмма + подсказки
- `организмы` - несколько молекул и атомов. Шапка сайта 
- `шаблон` - законченные веб-страницы или экраны приложений (но с тестовым контентом)
- `страницы` - шаблон, заполненный реальным контентом (картинками, текстами и т.д.)

Примеры реализации
- [Storybook](https://storybook.js.org/) - инструмент для разработки и управления библиотекой UI компонентов. Open Source
- [Pattern Lab](https://patternlab.io/) - генератор статических сайтов, использующий методологию атомарного дизайна.

Ссылки:

- [Habr - Атомарный веб-дизайн (2015)](https://habr.com/ru/post/249223/)
- [Брэд Фрост — Атомарный дизайн (перевод)](https://medium.com/%D0%B0%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD/atomic-design-foreword-4960ad17bc1a)
- [Всё, что вам нужно знать об атомарном дизайне](https://deadsign.ru/ui/everything-you-need-to-know-about-atomic-design/)

<br></p>
</details>

[//]: # (Redux Duсks)
<details><summary><b>Redux Duсks</b></summary><p>

См [Legmo Notes - React. Ducks](../JS/React.md#ducks)

<br></p>
</details>

[//]: # (Функциональная архитектура)
<details><summary><b>Функциональная архитектура</b></summary><p>

Примерно так: до начала работы с кодом анализируем будущий продукт

- [Шерер П - Функциональная архитектура цифровых продуктов. Часть 1](https://sherer-pro.turbopages.org/sherer.pro/s/blog/funkcionalnaja-arhitektura-cifrovyh-produktov-chast-1/)
- [Шерер П - Функциональная архитектура цифровых продуктов. Часть 2](https://sherer-pro.turbopages.org/sherer.pro/s/blog/funkcionalnaja-arhitektura-cifrovyh-produktov-chast-2/)
- [Шерер П - Функциональная архитектура цифровых продуктов. Часть 3](https://sherer-pro.turbopages.org/sherer.pro/s/blog/funkcionalnaya-arxitektura-cifrovyx-produktov-chast-3/?last_related=1&turbo_feed_type=full)

<br></p>
</details>


**Ссылки**

- [Карпелевич А - Верхнеуровневая архитектура фронтенда. Лекция Яндекса. Видео + расшифровка (2018)](https://itnan.ru/post.php?c=1&p=425611)
- [Habr - «Откуда ноги растут» или что предшествует программированию?](https://habr.com/ru/company/otus/blog/493898/)
- [Habr - Архитектура фронтенда и какой она должна быть](https://habr.com/ru/post/667214/)
- [Doka - Архитектура и паттерны проектирования](https://doka.guide/js/architecture-and-design-patterns/)
- [Doka - Трёхслойная архитектура (Чистая архитектура, Clear architecture)](https://doka.guide/js/clean-architecture/)
- [Doka - Организация потоков данных (Flux)](https://doka.guide/js/architecture-data-flow/)
- [Беспоясов А - Чистая архитектура во фронтенде](https://bespoyasov.ru/blog/clean-architecture-on-frontend/)
- [Яндекс - Разработка фичи: как эффективно пройти путь от идеи до реализации](https://academy.yandex.ru/journal/razrabotka-fichi-kak-effektivno-projti-put-ot-idei-do-realizacii)
- [Medium - Проволочки при проектировании структуры React приложения](https://medium.com/@vladimirmorulus/%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-react-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-609f80105e2c)
- [Hexlet - Курс «JS: Архитектура фронтенда»](https://ru.hexlet.io/courses/js-frontend-architecture)
- [Legmo Notes - Паттерны проектирования](./Pattern.md)
- [Legmo Notes - Микросервисная архитектура](../WebDeveloping/Microservices.md)
- 
- [Habr - Масштабирование Redux-приложения с помощью ducks (2020)](https://habr.com/ru/company/otus/blog/492638/?ysclid=l6sz05stk7523793176)
- [Habr - Как организовать большое React-приложение и сделать его масштабируемым (2017)](https://habr.com/ru/company/nix/blog/329060/)
- 
- [Habr - Как два программиста хлеб пекли (2012)](https://habr.com/ru/post/153225/)
- [Doka - Что такое код-ревью](https://doka.guide/tools/code-review/)
- [Doka - Что такое технический долг](https://doka.guide/js/technical-debt/)

<br>
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*