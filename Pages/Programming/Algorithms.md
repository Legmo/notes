<h1>Алгоритмы</h1>

[//]: # (Алогоритмическая сложность todo: доработать)
<details><summary><b>Алогоритмическая сложность</b></summary><p>

Вычислительная сложность (алгоритмическая сложность) - понятие, обозначающее функцию зависимости объема работы алгоритма от размера обрабатываемых данных.

Пытается ответить на центральный вопрос разработки алгоритмов: как изменится время исполнения и объем занятой памяти в зависимости от размера входных данных?

<br></p>
</details>

[//]: # (Big O нотация todo: доработать)
<details><summary><b>Big O нотация</b></summary><p>

Big O нотация — нужна для описания сложности алгоритмов.

Big O – это мера эффективности «в худшем случае», верхняя граница того, сколько времени потребуется для выполнения задачи, или сколько памяти для этого необходимо. Например, поиск элемента в несортированном списке имеет значение O(n).

Алгоритмы описывают с помощью двух характеристик — времени и памяти.

**Время**
- Когда говорят о `Time Complexity` — речь идёт именно о количестве операций.
- Проблема: секунды, минуты и часы — это не очень показательные единицы измерения. 
- Кроме того, время работы алгоритма зависит от железа, на котором он выполняется, и других внешних факторов. 
- Поэтому время считают не в секундах и часах, а в `количестве операций, которые алгоритм совершит`.
- в О-нотации на операции с одной или двумя переменными вроде i++, a * b, a / 1024, max(a,b) уходит всего одна единица времени.

**Память**
- объём оперативной памяти, который потребуется алгоритму для работы. 
- Потребление памяти обычно называется `Space Complexity` или просто `Space`, редко `Memory`.
- Одна переменная — это одна ячейка памяти, а массив с тысячей ячеек — тысяча ячеек памяти.
- Все ячейки считаются равноценными. Например, int a на 4 байта и double b на 8 байт имеют один вес.
- `in-place` — алгоритмы, которые используют исходный массив как рабочее пространство. Они потребляют мало памяти и создают одиночные переменные — без копий исходного массива и промежуточных структур данных. 
- `out-of-place` — алгоритмы, требующие дополнительной памяти, называют. 
- Прежде чем использовать алгоритм, надо понять, хватит ли на него памяти, и если нет — поискать менее прожорливые альтернативы.

При расчёте Big O Notation используют **два правила**:
- Константы откидываются. 
  - Нас интересует только часть формулы, которая зависит от размера входных данных. Проще говоря, это само число n, его степени, логарифмы, факториалы и экспоненты, где число находится в степени n.
- Если в O есть сумма, нас интересует самое быстрорастущее слагаемое. 
  - Это называется асимптотической оценкой сложности

**Сценарии работы алгоритмов**
- У каждого алгоритма есть худший, средний и лучший сценарии работы — в зависимости от того, насколько удачно выбраны входные данные. Часто их называют случаями.
- `Худший случай `(worst case) — это когда входные данные требуют максимальных затрат времени и памяти.
- `Лучший случай` (best case) — полная противоположность worst case, самые удачные входные данные.
  - Правильно отсортированный массив, с которым алгоритму сортировки вообще ничего делать не нужно. В случае поиска — когда алгоритм находит нужный элемент с первого раза.
- `Средний случай` (average case) 
  - между best case и worst case, но далеко не всегда понятно, где именно. 
  - Часто он совпадает с worst case 
  - всегда хуже best case, если best case не совпадает с worst case. Да, иногда они совпадают.
  - Как определяют средний случай? Считают статистически усреднённый результат: берут алгоритм, прокручивают его с разными данными, составляют сводку результатов и смотрят, вокруг какой функции распределились результаты. В общем, расчёт average case — дело сложное.

Алгоритмы
- Линейный поиск - сравнивать значения одно за другим.  работает с любыми массивами. Сложность  O(n^2)
- Бинарный поиск - упорядочить массив, потом открыть по середине и смотреть - нужно больше или меньше. Телефонный справочник.  работает только с отсортированныйми массивами, Сложность  O(n)
- 

Опредеелние сложности алгоритма
- На глаз
- амортизационный анализ (разновидность "На глаз")
  - если на X «дешёвых» операций (например, с O(1)) приходится одна «дорогая» (например, с O(n)), то на большом количестве операций суммарная сложность получится неотличимой от O(1).
- для оценки сложности рекурсивных алгоритмов широко используют мастер-теорему.
  - По сути, это набор правил по оценке сложности. Он учитывает, сколько новых ветвей рекурсии создаётся на каждом шаге и на сколько частей дробятся данные в каждом шаге рекурсии. Это если вкратце.
- Метод Монте-Карло
  - применяют довольно редко — только если первые два применить невозможно. Особенно часто с его помощью описывают производительность систем, состоящих из множества алгоритмов.
  - Суть метода: берём алгоритм и гоняем его на случайных данных разного размера, замеряем время и память. Полученные измерения выкладываем на отдельные графики для памяти и времени. А затем автоматически вычисляется функция, которая лучше всего описывает полученное облако точек.


Каки ещё есть оценки сложности нотаций
- Big O обозначает верхнюю границу сложности алгоритма. Это идеальный инструмент для поиска worst case.
- Big Omega (которая пишется как подкова) обозначает нижнюю границу сложности, и её правильнее использовать для поиска best case.
- Big Theta (пишется как О с чёрточкой) располагается между О и омегой и показывает точную функцию сложности алгоритма. С её помощью правильнее искать average case.
- Small o и Small omega находятся по краям этой иерархии и используются в основном для сравнения алгоритмов между собой.

**Ссылки**
- [Habr - Big O](https://habr.com/ru/post/444594/)
- [Big O Notation: что это такое и как её посчитать](https://skillbox.ru/media/code/big-o-notation-chto-eto-takoe-i-kak-eye-poschitat/)
- [Proglib - Big O нотация: что это такое и почему ее обязательно нужно знать каждому программисту](https://proglib.io/p/big-o-notaciya-chto-eto-takoe-i-pochemu-ee-obyazatelno-nuzhno-znat-kazhdomu-programmistu-2022-02-17)

<br></p>
</details>


[//]: # (Оптимизация алгоритмов todo: доработать)
<details><summary><b>Оптимизация алгоритмов*</b></summary><p>

Вообще не очень понятно о чём речь.

Ну, например есть такая статья: [techrocks.ru - Оптимизация программного кода](https://techrocks.ru/2019/01/25/code-optimization-tips/)


<br></p>
</details>

[//]: # (Ссылки)
<details><summary><b>Ссылки</b></summary><p>


- [Алгоритмическая сложность](https://tproger.ru/translations/algorithms-and-data-structures)
- [Сортировки. Пузырьковая сортировка/фильтрация](https://tproger.ru/translations/sorting-for-beginners)
- [Бинарное дерево](https://tproger.ru/translations/binary-search-tree-for-beginners)

<br></p>
</details>