<h1>Шпаргалка по React JS</h1>

[//]: # (Что нового?)
<details><summary><h3>Что нового?</h3></summary><p>

- **React 18**  (апрель 2022)
  - `Параллельный рендеринг` (Concurrent Rendering)
    - В обычном поведении, если React начал перерисовывать DOM, все остальные обновления в очереди блокируются и
      дожидаются окончания обновления. Concurrent rendering должен решить эту проблему. В конкурентном режиме рендеринг
      не блокируется. Он прерывается. Это улучшает UX и открывает новые возможности.
  - `automatic batching` (“автоматическое пакетирование”) - улучшение производительности, меняет способ пакетной
    обработки обновлений React для автоматического выполнения большей пакетной обработки.
    - До версии 18, React уже объединял/группировал (batched) несколько обновлений состояния в одно, чтобы уменьшить
      количество ненужных повторных отрисовок. Однако это происходило только в обработчиках событий DOM, поэтому
      промисы, тайм-ауты или другие обработчики этим не могли воспользоваться.
    - ранее каждый вызов useState (установка нового значения) приводил к перерисовке компонентов. Чуть позже движок
      оптимизировали и такие вызовы начали группироваться и выполняться за один раз, что должно было сократить
      количество перерисовок. Теперь данный функционал еще больше оптимизировали.
  - Изменения в `Strict Mode`
    - режим был добавлен в React 16.3 — позволяет React производить доп. проверки, что бы исключить возможные проблемы
      приложения.
    - Более строгий «строгий режим»
    - Добавление `<StrictMode>` в приложение React добавляет особое поведение (только в режиме DEV) ко всем компонентам,
      вокруг которых оно выполняется. Например, при работе в «строгом режиме» React намеренно выполняет двойной
      рендеринг компонентов, чтобы избавиться от небезопасных побочных эффектов.
    - в будущем React предоставит функцию, позволяющую компонентам сохранять состояние между анмаунтами. Чтобы
      подготовиться к этому, React 18 вводит новую проверку только для разработки в строгом режиме. React автоматически
      анмаунтит и маунтит каждый компонент всякий раз, когда компонент создаётся в первый раз, восстанавливая предыдущее
      состояние при втором маунте.
  - `Offscreen API`
    - обеспечивает лучшую производительность, скрывая компоненты вместо их размонтирования, сохраняя состояние и
      по-прежнему вызывая эффекты монтирования/размонтирования.
    - Это сыграет решающую роль в оптимизации таких компонентов, как вкладки, виртуализированные списки и т. д.
  - `Root API` (React DOM Client)
    - Функция рендеринга (render) — та, которая находится в корне каждого приложения React, будет заменена на
      createRoot.
    - Новый API — это шлюз для доступа к новым функциям React 18. createRoot предоставляется вместе с устаревшим API,
      чтобы способствовать постепенному внедрению и упрощению возможных сравнений производительности.
    - `createRoot` — новый метод создания корня для рендеринга или анмаунта. Используйте его вместо ReactDOM.render. Без
      него новые функции в React 18 не работают.
    - `hydrateRoot` — новый метод гидратации приложения, отображаемого на сервере. Заменяет `hydrate()`. Используется в
      сочетании с новыми API-интерфейсами React DOM Server. Без него новые функции в React 18 не работают.
  - React DOM Server API
    - имеет полную поддержку потоковой передачи Suspense на сервере:
    - `renderToPipeableStream` — для потоковой передачи в среде Node.
    - `renderToReadableStream` — для современных сред выполнения, таких как Deno и Cloudflare.
    - Существующий метод `renderToString` продолжает работать, но не рекомендуется его использовать.
  - `useId` — новый хук для создания уникальных идентификаторов как на клиенте, так и на сервере, избегая при этом
    hydration несоответствий.
    - В первую очередь полезно для библиотек компонентов, интегрирующихся с API, для которых требуются уникальные
      идентификаторы.
    - Решает проблему, которая уже существует в React 17 и более ранних версиях, но еще более важна в React 18 из-за
      того, что новый рендерер сервера доставляет HTML не по порядку.
  - `startTransition` и `useTransition` — позволяют помечать некоторые обновления состояния как несрочные
    - Другие обновления состояния по умолчанию считаются срочными. React позволит срочным обновлениям состояния (
      например, обновлению ввода текста) прерывать несрочные обновления состояния (например, отображение списка
      результатов поиска).
  - `useDeferredValue` - позволяет отложить повторный рендеринг несрочной части дерева.
    - Похож на `debouncing`, но имеет несколько преимуществ по сравнению с ним.
    - Фиксированной задержки по времени нет, поэтому React попытается выполнить отложенный рендеринг сразу после того,
      как первый рендер отобразится на экране.
    - Отложенный рендеринг может быть прерван и не будет блокировать ввод данных пользователем.
  - `useSyncExternalStore` — хук, который позволяет внешним хранилищам поддерживать параллельное чтение, заставляя
    обновления в хранилище быть синхронными.
    - Он устраняет необходимость в useEffect при реализации подписок на внешние источники данных и рекомендуется для
      любой библиотеки, которая интегрируется со сторонним состоянием по отношению к React.
  - `useInsertionEffect` — хук, который позволяет библиотекам CSS-in-JS решать проблемы с производительностью при
    внедрении стилей во время рендеринга.
    - Если вы не планируете создавать библиотеку CSS-in-JS, мы не ожидаем, что вы когда-либо будете это использовать.
      Этот хук запустится после изменения DOM, но до того, как эффекты лейаута узнают об этом. Это решает проблему,
      которая уже существует в React 17 и более ранних версиях, но еще более важна в React 18, поскольку React уступает
      браузеру во время одновременного рендеринга, давая ему возможность пересчитать лейаут.
  - `Согласованное время useEffect` —
    - React теперь всегда синхронно сбрасывает функции эффектов, если обновление было запущено во время дискретного
      события пользовательского ввода, такого как щелчок или событие нажатия клавиши.
    - Раньше поведение не всегда было предсказуемым или последовательным.
  - `Более строгие ошибки гидратации`
    - несоответствия гидратации из-за отсутствующего или дополнительного текстового содержимого теперь обрабатываются
      как ошибки, а не как предупреждения. React больше не будет пытаться «исправлять» отдельные узлы, вставляя или
      удаляя узел на клиенте в попытке сопоставить разметку сервера, и вернется к рендерингу клиента до ближайшей
      границы <Suspense> в дереве.
    - Это гарантирует согласованность гидратированного дерева и позволяет избежать потенциальных дыр в
      конфиденциальности и безопасности, которые могут быть вызваны несоответствием гидратации.
  - `Эффекты лейаута с задержкой`
    - когда дерево повторно приостанавливается и возвращается к резервному варианту, React теперь очищает эффекты
      лейаута, а затем воссоздает их, когда содержимое внутри границы снова отображается.
    - Это устраняет проблему, из-за которой библиотеки компонентов не могли правильно измерить лейаут при использовании
      с Suspense.
  - `Новые требования к среде JS`
    - React теперь зависит от современных функций браузеров, включая `Promise`, `Symbol` и `Object.assign`.
    - Если вы поддерживаете более старые браузеры и устройства, такие как Internet Explorer, которые изначально не
      предоставляют современные функции браузера или имеют несовместимые реализации, рассмотрите возможность включения
      глобального полифилла в приложение.
  - [Medium - React 18 вышел! Это то, что вам нужно знать](https://medium.com/@hydrock/react-18-%D0%B2%D1%8B%D1%88%D0%B5%D0%BB-%D1%8D%D1%82%D0%BE-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%B2%D0%B0%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-b2bc675761f1)
  - [Habr - React 18. Что нового?](https://habr.com/ru/post/660333/)
- **React 17** (2020)
  - Прославился малым количеством изменений
  - Изменение в `делегировании событий` — теперь все обработчики привязываются к `корневому элементу`, а не `document`
    - Реакт использует особый способ привязки событий (onClick и т.д.) к DOM-элементам. Для повышения
      производительности.
    - Использует прием «делегирования событий» и привязывает все события к объекту `document`.
    - Теперь все обработчики крепятся к `корневому элементу`, а не `document`.
    - Это решает ряд проблем если: на странице используется N версий React, есть микрофронтенды или используется jQuery
  - Убран костыль с Синтетическим Событием (`SyntheticEvent Even Pooling`) — убрана оптимизация событий, которая более
    не актуальна в современных браузерах.
  - Небольшие изменения на сближение поведения React с браузера
    - Событие `onScroll` — больше не всплывает, чтобы избежать текущей путаницы;
    - События `onFocus` и `onBlur` — изменены "под капотом" на нативные focusin и focusout;
    - `onClickCapture` и другие `Capture`-события — теперь используют браузерные обработчики событий. Типо onClick? Иил
      что-то про всплытие/погружение событий?
  - `useEffect()` теперь полностью асинхронный
    - раньше только функция эффекта запускалась асинхронно, тогда как возвращаемая функция для очистки подписок
      запускалась синхронно, так же как и метод componentWillUnmount(), то теперь и эта функция работает асинхронно, что
      улучшает производительность в случае перерисовки большого количества элементов, например, когда на сайте
      присутствуют вкладки, или при переходе со страницы на страницу.
    - Для синхронной работы, можно по-прежнему использовать useLayoutEffect(), который остался незатронутым.
  - Ошибки при возвращении `
  - undefined`
    - Если раньше нельзя было возвращать undefined только в обычных компонентах, то теперь такая ошибка будет
      выбрасываться еще и в React.forwardRef и React.memo.
  - Улучшенный `стек вызовов при ошибках`
    - Когда выбрасывается ошибка, браузер показывает stack trace с названиями функций и их местоположения.
    - Теперь используется новый механизм генерации стека вызовов => позволяет увидеть дерево React-компонентов, которое
      привело к ошибке, даже в production-среде.
  - `Удаление приватных экспортов` — это удаление некоторых внутренних экспортов, которые ранее были открыты наружу.
    - Например, React Native for Web ранее зависела на некоторых внутренностях системы событий, но эта зависимость не
      была надежной. В 17-м React эти приватные экспорты были удалены. По большей части из-за того, что только
      вышеупомянутый проект их использовал, а миграция на более надежные методы уже была произведена.
  - [Habr - React 17: Ничего нового?](https://habr.com/ru/post/519824/)

**Ссылки**

- http://bogdanov-blog.ru/react-router-v4-notes/
- https://habrahabr.ru/post/329996/

<br></p>
</details>

[//]: # (Базовые понятия)
<details><summary><h3>Базовые понятия</h3></summary><p>

---

[//]: # (Что такое React)
<details><summary><b>Что такое React</b></summary><p>

JS-библиотека для создания пользовательских интерфейсов.

Это не фреймворк! Сам по себе не позволит создать веб-приложение, предназначен для создания представлений (это «V» в
MVC). React – это только представление. Это язык шаблонов + несколько функций, которые позволяют отрисовать HTML.
Результат работы React – это HTML.

Разрабатывается и поддерживается Facebook + Instagram и сообществом отдельных разработчиков и корпораций. <br>
Открытый исходный код

Выход первой версии:

- 2009 - Angular
  - 2010 - Backbone
  - 2011 - Ember
  - 2012 - Meteor
  - **2013 - REACT**
  - 2014 - Vue
  - 2015 - Polymer
  - 2015 - Aurelia
  
  Также Facebook разработал **Flux** - архитектурный шаблон, который дополняет React (см. Redux). 
  
  **Ключевые особенности:**
  - **Компонентный подход** - разбиваем страницы на небольшие фрагменты. Мы называем эти фрагменты компонентами. Их можно потом переиспользовать в других проектах.
  - **Виртуальный DOM** - React создает кэш-структуру в памяти, что позволяет вычислять разницу между предыдущим и текущим состояниями интерфейса для оптимального обновления DOM браузера. 
  - **Однонаправленная передача данных** - свойства передаются от родительских компонентов к дочерним (сверху-вниз). Компонент не может напрямую изменять свойства, но может вызывать изменения через callback функции.
  - **JSX** (JavaScript XML) - расширение синтаксиса JavaScript, "синтаксический сахар" для JS. Позволяет использовать похожий на HTML синтаксис для описания структуры интерфейса. Можно работать с React и без JSX (но не стоит)
  
  **Также:**
  - **Декларативный** - описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между этими состояниями
  - **Функциональный** - поощряется использование функционального подхода к программированию (не ООП)
  - **Реактивный** - как бы из названия видно, что является реализацией реактивного подхода к программированию
  - **Типизация** - динамическая слабая неявная (как и весь JS). Для введения статической типизации можно использовать (в порядке усложнения): propTypes / Flow / TypeScript 
  - **Тестируемость** - поддерживает js-тестирование (Jest, Enzyme, Mocha...)
  - **ES6+** - т.к. всё равно используем Babel, логично использовать возможности ES6 (константы, стрелочные функции, шаблонные строки и т.д.)
  - **Изоморфность** - код может выполняться и на клиентской, и на серверной стороне. 
  - **Быстрый** - в частности, потому что выполняет оптимизацию при компиляции кода в JSX -> JS
  - **Легко интегрировать** - React можно встраивать в приложение по частям: часть уже работает на React, часть без него. И всё ок. Можно подключать через CDN и т.д.
  - **React Native** - платформа для разработки мобильных приложений, создает мобильные приложения с помощью React.js. Т.е. на основе React JS приложения можно довольно легко создать мобильное приложение.
  
  **Про название**<br>
  React получил свое название от того, что он реагирует на изменения состояния (хоть и не реактивно, но по графику).
  Была шутка, что React должен был быть назван Schedule.

**Ссылки**

- [Angular vs. React: Сравнение 7 Основных характеристик](https://code.tutsplus.com/ru/articles/angular-vs-react-7-key-features-compared--cms-29044)
- [React и SEO: преимущества изоморфности React для одностраничных приложений](https://xbsoftware.ru/blog/react-seo-izomorphnost-react-odnostrannoe-prilozhenie/)
- [Все фундаментальные принципы React.js, собранные в одной статье](https://medium.com/@divermak/%D0%B2%D1%81%D0%B5-%D1%84%D1%83%D0%BD%D0%B4%D0%B0%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-react-js-%D1%81%D0%BE%D0%B1%D1%80%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9-%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B5-ec6a97bfd1bf)

<br><p>
</details>

[//]: # (Как работает React? todo: доработать)
<details><summary><b>Как работает React?</b></summary><p>

**В целом, схема работы примерно такая (пример из PReact)**

- Компоненты написанные на JSX (HTML и JS) преобразуются в чистый JS с помощью CLI инструмента Babel.
- После чего React функция “React.createElement” преобразует их в VDOM дерево (ReactElement).
- И наконец, Preact’s VDOM алгоритм создает реальный DOM из VDOM (наше приложение).

JSX это конечно круто, он помогает написать “представление” DOM, но в конечном счете, нам нужен именно реальный DOM. Нам
надо преобразовать наше “представление” в JSON (VDOM, который также дерево), чтобы в дальнейшем использовать его в
качестве входных данных для создания DOM. Для этого React использует функцию React.createElement.

Для того, чтобы преобразовать JSX к виду “React.createElement” функции нам понадобиться Babel. Он проходит через каждый
узел JSX и преобразует его к “React.createElement” функции. Т.е. на входе у нас JSX, на выходе из Babel - вызов функции
React.createElement() в которую передан чистый JS. Те JSX -> React.createElement(JS)

React.createElement возвращает ReactElement - он является простым JS объектом узла DOM с его свойствами и наследниками.

Функция React.createElement не создает целое дерево! Она создаёт простой JS объект для одного узла.

**!**

- VNode = ReactElement
- h = React.createElement

*Сценарий 1: При первом запуске*

- Когда наше приложение загружается в первый раз, React создаёт ReactElement с наследниками и атрибутами для основного
  компонента.
- Потом мы создаём реальный DOM для родительского узла
- Повторяем эти действия (создание реального DOM) для всех наследников
- Добавление наследников к родителям
- Обработка дочерних компонентов наследников
- Повторяем цикл для каждого дочернего узла.
- И наконец последний пункт. Здесь мы просто вызываем “componentDidMount” для всех компонентов (дочерних и родительских)
  .

После того как все сделано, ссылка на реальный DOM добавляется к каждому экземпляру компонента!. Данная ссылка
используется для всех остальных действий (создание, обновление, удаление), чтобы сравнить и избежать создания тех же DOM
узлов.

*Сценарий 2: Удаление узла из DOM, который не имеет наследников*

- После первоначального рендеринга, каждое изменение считается “обновлением”. Цикл обновления работает почти так же как
  и цикл создания
- Отличие в том, что это приводит к вызову “componentWillReceiveProps”, “shouldComponentUpdate”, и “componentWillUpdate”
  для каждого компонента.
- Кроме того, цикл обновления, не создаёт повторно элементы которые уже присутствуют в DOM. Чтобы избежать повторное
  создание узлов в реальном DOM, каждый экземпляр компонента имеет ссылку на реальное DOM дерево, которое было создано
  во время начальной загрузки. И когда ReactElement создан, каждое его свойство сравнивают с узлами в реальном DOM. Если
  такой узел уже существует, цикл переходит к следующему узлу.
- Мы удаляем элемент из VDOM. Происходит сравнение с реальным DOM (скорее всего, с его копией, чтоб не читать реальный
  DOM, т.к. это дорогая операция). Видим, что они различаются. Перерисовываем реальный DOM
- Вызываем componentDidMount

*Сценарий #3: Удаление/Unmounting компонента*

- Удаление компонента похоже на удаление одного узла. За исключением того, что мы удаляем узел, который имеет ссылку на
  компонент, в этом случае библиотека вызовет “componentWillUnmount”, а затем рекурсивно удалит все дочерние элементы
  DOM.

**Babel**<br>
Транспилятор. Преобразует JSX в обычный JS<br>
Компоненты написанные на JSX (HTML и JS) преобразуются в чистый JS с помощью CLI (интерфейс командной строки)
инструмента Babel

`Транспиляция` — это конвертация кода в другой, похожий язык.<br>
Это важная часть фронтенд-разработки: поскольку в браузерах медленно появляются новые фичи, были созданы языки с
экспериментальными возможностями, которые транспилируются в совместимые с браузерами языки.<br>
Превращение одной версии языка в другую версию языка. JSX - это расширение JS, nfr xnj JSX->JS = транспиляция.<br>
`Компиляция` - перевод на другой язык (чаще всего низкоуровневый = байт-код).

**Webpack**<br>
Сборщик модулей, bundler. Используется для компиляции JS-модулей.<br>
Берёт всё, от чего зависит проект (Css, JS...), и преобразует это в статические ресурсы, которые могут быть переданы
клиенту. Позволяет объединять ресурсы и библиотеки, необходимые для проекта, в один файл - «bundle» (пачка).

Как уже говорилось, node.js — это среда исполнения JavaScript, разработанная для запуска на серверах. Вот как сначала
выглядело использование node.js-модулей: вместо загрузки всего moment.min.js в скриптовом теге HTML можно было грузить
JS-файл напрямую:

  ```
  var moment = require('moment');
  console.log("Hello from JavaScript!");
  console.log(moment().startOf('day').fromNow());
  ```

Загрузка модулей работает прекрасно, поскольку node.js — это серверный язык с доступом к файловой системе. Также ему
известно расположение всех npm-модулей, поэтому вместо require('./node_modules/moment/min/moment.min.js) можно писать
просто require('moment').

Всё это прекрасно, но если вы попробуете использовать приведённый код в браузере, то получите ошибку, в которой
говорится, что require не определён. У браузера нет доступа к файловой системе, поэтому такая загрузка модулей
реализована очень хитро: файлы нужно грузить динамически, синхронно (замедляет исполнение) или асинхронно (могут быть
проблемы с синхронизацией).

И здесь появляется бандлер (bundler). Это инструмент для сборки модулей в единые пакеты, имеющий доступ к файловой
системе. Получающиеся пакеты совместимы с браузером, которому не нужен доступ к файловой системе. В нашем случае бандлер
нужен для поиска всех выражений require (имеющих ошибочный, с точки зрения браузера, JS-синтаксис) и замены на настоящее
содержимое каждого требуемого файла. В финале мы получаем единый JS-файл без выражений require!

Самым популярным бандлером сначала был Browserify, выпущенный в 2011 г. Он был пионером в использовании
node.js-выражений require во фронтенде (это позволило npm стать самым востребованным диспетчером пакетов). К 2015-му
лидером стал webpack (ему помогла популярность фронтенд-фреймворка React, использующего все возможности этого бандлера).

**Ссылки**

- [habr - Объясняем современный JavaScript динозавру](https://habr.com/ru/company/mailru/blog/340922/)
- [Как работает Virtual DOM ?](https://medium.com/@abraztsov/how-virtual-dom-work-567128ed77e9)
- [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)

<br></p>
</details>

[//]: # (Среда React)
<details><summary><b>Среда React</b></summary><p>

Для работы используется:

- **NPM/Yarn** - для управления зависимостями. Ну, и чтобы установить Create React App (для работы npm нужен Ruby)
- **Babel**
- **WebPack**
- **WebPack server**
- **Create React App** - специальная npm/yarn утилита дл ябыстрого развоарчивания проекта на React. Содержит Babel,
  WebPack и прочее
- OpenServer не нужен!

Вообще, можно работать без всего этого добра - добавить в код ссылку на CDN Реакта и всё. Но с "добром" удобнее.

**Create React App**<br>
Специльное приложение от разработчиков React. По сути - готовая среа для работы, с настроенным Babel, WebPack, live
development server, линтерами и всеми чудесами. Установил - и можешь сразу начинать работать. <br>
[GitHub](https://github.com/facebook/create-react-app)

<br></p>
</details>

[//]: # (Элемент)
<details><summary><b>Элемент</b></summary><p>

Это JS-объект, который описывает узел DOM. <br>  
Объектное представление некоторого пользовательского интерфейса.

  ```
    //Создаём элемент с помощью метода React createElement
    const element = React.createElement(
      'div',
      {id: 'login-btn'},
      'Login'
    )
    
    //Получаем такой объект (элемент):
    {
      type: 'div',
      props: {
        children: 'Login',
        id: 'login-btn'
      }
    }
    
    //Когда он будет отображён в DOM (с помощью функции ReactDOM.render), появится узел DOM
    <div id='login-btn'>Login</div>    
  ```
  
  Компонент же — класс или функция, которая принимает данные и возвращает элементы.
  ```jsx
  //компонент Button принимает функцию onLogin и возвращает React элемент
    function Button ({ onLogin }) {
      return React.createElement(
        'div',
        {id: 'login-btn', onClick: onLogin},
        'Login'
      )
    }
  ```
  
  Надо только учесть, что когда мы работаем с JSX - мы не видим `React.createElement`. JSX позволяет писать это проще, но по факту, переделывает в тот самый `React.createElement`

  Примеры создания React элемента:
  - `React.createElement('div', className: 'container', 'Hello!')`
  - `<div className='container'>Hello!</div>`
  - `<Hello />`
  
  Т.е. компонент (класс/функция) генеририрует элемент (js-объект). Этот элемент будет отображён в DOM (с помощью функции ReactDOM.render), и у нас появиться новый DOM узел. А браузер на основе этого DOM-узла отобразит какую-то информацию на экране (кнопку, например)
  
  **Ссылки:**
  [React Elements против React Components](https://tuhub.ru/posts/react-elements-protiv-react-components)
  
  <br></p>
</details>

[//]: # (Компонент)
<details><summary><b>Компонент</b></summary><p>
    
  Компонент - класс или функция, которая принимает данные и возвращает элементы React.
                                                                                             
  Компонент - js-функция, которая возвращает кусок кода, представляющего фрагмент страницы. 
  Описывают DOM-элементы (h1, div, section...). Обычно это части пользовательского интерфейса, которые содержат свою структуру и функциональность. Например: NavBar, LikeButton, или ImageUploader. 
  
  Благодаря синтаксису JSX компонента совмещает и разметку, и логику<br>
  Концептуально, компоненты подобны JS-функциям - принимают данные (props) и возвращают React-элементы, описывающие что должно появиться на экране. 
  
  Когда компонент создан, автоматически появляется тэг <Имя_Компонента /> - при его помощи мы выводим этот JSX в нужном месте.
    
  Т.е. компонент (класс/функция) генерирует элемент (js-объект). Этот элемент будет отображён в DOM (с помощью функции ReactDOM.render), и у нас появиться новый DOM узел. А браузер на основе этого DOM-узла отобразит какую-то информацию на экране (кнопку, например)
  
  Основополагающая концепция React.js – многоразовые компоненты. Разработчик создает небольшие части кода, которые можно объединять, чтобы сформировать более крупные или использовать их как самостоятельные элементы интерфейса.
  
  Самое главное в этой концепции то, что и большие, и маленькие компоненты можно использовать повторно и в текущем и в новом проекте.
  
  Компоненты, которые были созданы во время работы над тем или иным проектом, не имеют дополнительных зависимостей. Таким образом, ничто не мешает использовать их снова и снова в проектах разного типа. Весь предыдущий опыт может быть с легкостью применен при работе над новым сайтом или даже при создании мобильного приложения. 
  
      
  **Ссылки:**
  [React Elements против React Components](https://tuhub.ru/posts/react-elements-protiv-react-components)
  
  <br></p>
</details>

[//]: # (Props)
<details><summary><b>Props (свойства)</b></summary><p>

  Определения:  
  - В React есть функция, которая создаёт/вызывает компоненты. Она принимает параметры. Первый параметр называется `props`. В него прокидывается объект со всеми данными, которые мы передаём при создании/вызове компонента. Если этих данных нет — объект пустой.
  - Произвольные данные, которые принимают компоненты. Это могут быть и функции.
  - Все данные в компонент приходят в первом аргументе.
  - Первый аргумент функции, создающей компонент. В него приходят все данные, с которыми мы работаем в компоненте.
  - Информация, коллективно используемая родительским компонентом и компонентами-потомками.
  - Объект, который позволяет передать в компонент какие-то данные или callback.
    - `callback` = функция, которую компонент потом сможет запустить. Сама функцию создана в файле Х, но если передать её через `props` - вызывается из файла Y.

  Props от `properties` (свойства).<br>
  Props передаются в качестве аргументов компонента. Выглядят как атрибуты HTML.

  Каждый элемент имеет список свойств (атрибутов), как и в HTML. В Реакте это называется props.

  Любой компонент может принимать параметры, которые потом использует внутри себя. Например, текст, который надо вывести внутри JSX-разметки, генерируемой компонентом. Главный такой параметр называется `props`.<br>
  Это просто название параметра, оно принято в React).<br> 
  React, вызывая компонент, всегда передаёт в этот параметр `props` некий объект (если ничего нет - объект пуст).<br>
  Находясь внутри компонента я могу получать данные, которые пришли внутри этого `props`.
  
  ```jsx      
  //Тут передаются props imageURL (значение - адрес), caption (текст), isPlaying (функция)
  <Button imageURL='http:tinyurl.comlkevsb9' caption='New York!' isPlaying={this.state.isMusicPlaying} />
  ```      

  Чтоб при вызове компонента передать что-то в его `props` - достаточно прописать некий атрибут.<br>
  Например `name='Dima'` превратится в `props.name`

  ```
    const User = (props) => {
      return (
          <>
            <p> {props.name} </p>
            <p> {props.age} </p>
          </>
      )
    }
  
    <User name='Dima' age='30' />
  ```

Правила использования:

- **`Props` можно только читать**! Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от
  того, функциональный он или классовый.
- Правильный подход - **прокидывать в компоненты как можно меньше `props`**. Чтоб компоненты оставались "чистыми", "
  презентационными". В идеале компонент ничего не знает про `store`, мы никак завязаны на `store`. Тогда, в будущем,
  можно использовать эти компоненты с другими реализациями `state-managment` (MobX, ...)

**Props и производительность**
см. раздел «Быстродействие и оптимизация React»

**Ссылки**

- [Оф. документация - Компоненты и пропсы](https://ru.reactjs.org/docs/components-and-props.html)

<br></p>
</details>

[//]: # (State)
<details><summary><b>State (состояние)</b></summary><p> 

Специальный js-объект внутри компонента. Хранит данные, которые могут изменятся с течением времени.<br>
  Описывает внутреннее состояние компонента. 
  
  - Props - входные данные, которые передаются в компонент извне. 
  - State - хранит данные, которые создаются в компоненте и полностью зависят от компонента. Определяется внутри компонента и доступно только из компонента. Компонент может передать своё состояние дочерним компонентам в виде props.
  
  Также, в отличие от props, значения в state можно изменять. 
  
  
  С добавлением Redux всё становится немного интереснее, т.к. Redux вводит свой state. Он собственно и нужен для управления state приложения.(см. Redux)
  
  **Как правильно использовать state**
  - Не изменяйте состояние напрямую. Вместо этого используйте setState()
  ```
  // Неправильно
  this.state.comment = 'Привет';
  
  // Правильно
  this.setState({comment: 'Привет'}); 
  ``` 

- Обновления состояния могут быть асинхронными. Поскольку this.props и this.state могут обновляться асинхронно, вы не
  должны полагаться на их текущее значение для вычисления следующего состояния.
- Обновления состояния объединяются. Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим
  состоянием. Состояния объединяются поверхностно.

**Ссылки**

- [оф. документация](https://ru.reactjs.org/docs/state-and-lifecycle.html)

<br></p>
</details>

[//]: # (События todo: доработать)
<details><summary><b>События</b></summary><p>

При обработке событий важно понимать, что все атрибуты элементов React именуются с помощью camelCase. При работе с
функциями, мы передаем фактическую ссылку на функцию, а не строку.

React.js создает для DOM-события обертку в виде собственного объекта, чтобы оптимизировать производительность работы с
событиями. Внутри обработчика все так же возможно получить доступ ко всем методам, доступным для документа.

<br></p>
</details>

[//]: # (Virtual DOM todo: доработать)
<details><summary><b>Virtual DOM</b></summary><p>

Это дерево React элементов на JavaScript.

На самом деле React хранит два Virtual DOM:

- тот который отражает текущее состояние React;
- тот который отражает текущее состояние DOM.
  React сравнивает их между собой, не обращаясь к реальному DOM без крайней необходимости (т.к. чтение реального DOM -
  ресурсоёмкая операция)

React отрисовывает Virtual DOM в браузере, чтоб сделать интерфейс видимым.
React следит за изменениями в Virtual DOM и автоматически изменяет DOM в браузере так, чтоб он соответствовал
виртуальному.

Виртуальный DOM обновляет требуемую часть, сравнивая различия между предыдущей и текущей версией HTML. Процесс схож с
тем, как Github работает при обнаружении изменений в файле.

React создает кэш-структуру в памяти, что позволяет вычислять разницу между предыдущим и текущим состояниями интерфейса
для оптимального обновления DOM браузера.

React считается быстрым из-за VirtualDOM. В компоненте есть метод render, который вызывается при каждом обновлении
компонента. Затем результат рендера (здесь и далее под рендером будет иметься в виду именно вызов функции render
компонента, а не рендер в реальный DOM) обрабатывается React, сравнивается результат текущего рендера с результатом
предыдущего и в реальный DOM вносятся только необходимые изменения, а не целиком. Учитывая, что операции с реальным DOM
медленные, это должно быть быстрее.

Но, операции с Virtual DOM тоже могут быть медленными. Результат рендера React — это многоуровневый объект. Сравнение
результатов рендера — это не сравнение двух объектов по ссылке, а их полное, глубокое сравнение.

Более того, React будет делать полный перерендер компонента при любом вызове SetState (даже если данные не поменялись) и
при перерендере родителя. То есть, если у вас большое приложение, и вы вызываете setState у корневого компонента, у вас
всё приложение целиком будет перерендерено. React построит VDOM для всего приложения, сравнит его с предыдущим
результатом и в DOM поместит те самые незначительные правки (если они даже были). Всё это приведет к значительным
потерям в производительности приложения.

Это решается через `shouldComponentUpdate` и `PureComponent`. Тут тоже есть две проблемы:

1. Если в state есть ссылочные типы. Если мутировать объект, то нет никакой возможности проверить, изменилось ли
   значение, так как объект в текущем и новом state будет ссылаться на один и тот же объект. Компонент не будет
   перерендериваться, хотя данные в действительности поменялись. <br>
   **Решение**: либо заменяем все мутабельные операции на аналогичные иммутабельные операции, либо создаем новую ссылку
   и затем уже её мутируем.

2. Обратная ситуация. Когда мы каждый раз создаем ссылочный тип данных, даже если данные в нем не поменялись. Например,
   прогоняем данные через map - на выходе всегда новый массив, даже если данные не изменились. Получается, что у нас
   каждый раз создается новая ссылка, компонент будет перерендериваться, хотя не должен. <br>
   **Решение**: мемоизация (разновидность кэширования). Запоминаем предыдущие результаты вызова функции, и если
   вызывается снова - используем их из кэша. Есть специальные библиотеки с разной реализацией. <br>
   Важен тот момент, что так как значение берется из кеша, то возвращается та же самая ссылка. И так как у нас все
   данные иммутабельны, то нужна мемоизация, которая будет проверять значения по ссылке, а не глубоким сравнением

Также многие забывают, что использование стрелочных функций, bind и литералов массивом \ объектов в рендере создает
новую ссылку при каждом рендере. Решается использованием bind один раз в конструкторе или использованием свойств класса
и выносом литералов за пределы рендера. См.
подробнее: [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)

Когда мы создаем динамичную интерактивную веб-страницу, мы хотим, чтобы DOM обновлялся так быстро, как это возможно
после изменения состояния определенного элемента. Для данной задачи некоторые фреймворки используют прием, который
называется «dirty checking» и заключается в регулярном опросе состояния документа и проверке изменений в структуре
данных. Как вы можете догадаться, подобная задача может стать самой настоящей головной болью в случае высоко-нагруженных
приложений. Virtual DOM, в свою очередь, хранится в памяти. Именно поэтому в момент, когда «настоящий» DOM меняется,
React может изменять Virtual DOM в мгновение ока. React «собирает» такие изменения сравнивает их с состоянием DOM, а
затем перерисовывает изменившиеся компоненты.

При данном подходе вы не производите регулярное обновление DOM. Именно поэтому может быть достигнута более высокая
производительность React приложений.

**Изоморфность**
Кстати, Virtual DOM позволяет React легко создавать изоморфные приложения. В других JS-фрэймворках клиентская часть кода
часто полагается на DOM браузера, которого нет на серверной стороне => нельзя использовать один код и на клиенте, и на
сервере. React же дает нам абстракцию браузерного DOM'а в виде виртуального DOM'а. Это дает два основных преимущества:

- код, который работает с виртуальным DOM в React не зависит от браузера и может выполняться на сервере;
- React может оптимизировать операции над документами и снизить количество обращений к браузерному DOM и за счет этого
  значительно ускорить работу фронтенда.

**Про DOM**
Входными данными для render() являются свойства (props) и внутреннее состояние, которое может быть обновлено в любое
время.

Когда для render меняются входные данные, меняется и результат выполнения render.

React.js ведет запись жизненного цикла компонента. Когда React.js видит, что один рендер отличается от другого, он
переводит разницу между своим виртуальным представлением в операции с DOM API, которые будут отрисованы в документе.

**Ссылки**

- [Оф. документация - Виртуальный DOM и детали его реализации в React](https://ru.reactjs.org/docs/faq-internals.html)
- [Как работает Virtual DOM ?](https://medium.com/@abraztsov/how-virtual-dom-work-567128ed77e9)
- [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
- [React и SEO: преимущества изоморфности React для одностраничных приложений](https://xbsoftware.ru/blog/react-seo-izomorphnost-react-odnostrannoe-prilozhenie/)
- [learnjavascript - про обычный DOM](https://learn.javascript.ru/browser-environment)
- [Как работает Virtual DOM?](https://medium.com/@abraztsov/how-virtual-dom-work-567128ed77e9)
- [IT-Kamasutra #86 - Virtual DOM](https://youtu.be/rsW9_UtF4jk)

  <br></p>

</details>

[//]: # (Композиция в React)
<details><summary><b>Композиция в React</b></summary><p>

Комбинирование меньших компонентов при формировании большего.

<br></p>
</details>

[//]: # (Reverse Data Flow - обратный поток данных)
<details><summary><b>Reverse Data Flow - обратный поток данных</b></summary><p> 

Изменение state родительского компонента из его компонента-потомка.
  
  Например такая картина:
  - есть два компонента: Родитель и Потомок
  - в Родителе хранится состояние (например цвет фона)
  - в Потомке происходит что-то, что должно поменять состояние Родителя (например, нажата кнопка)
  - Как из дочернего компонента повлиять на состояние родительского?
  
  Делаем так:
  - в Родителе кроме state определяем функцию для изменения этого state
  - эту функцию передаём в виде колбэка Потомку (через props)
  - Потомок вызывает колбэк, тот отрабатывает в Родителе, и там меняется состояние
  
  **Другими словами**<br>
  В React обычным является кода родитель управляет потомком. Так же часто надо управлять родителем из дочернего компонента. Такой подход как раз и называется "Обратный поток данных".
  
  В родительском компоненте, там где хранится состояние, хранится и обработчик этого события. Нужно только передать этот обработчик в дочерний компонент в качестве props. В дочернем компоненте, в нужный момент я просто подставлю эту функцию из props, и отработает изменение состояния в родительском компоненте.
  
  **Ссылки**
  - [React. 1 . Props, State, Жизненный цикл, Reverse Data Flow](https://vk.com/@489914144-react-vvedenie)
  
  <br></p>
</details>

[//]: # (State lifting - подъём состояния)
<details><summary><b>State lifting - подъём состояния</b></summary><p>
    
  Перенос данных / функций из дочернего элемента в родителя, чтоб они были доступны нескольким потомкам. 
  А из потомка вызываю эти обработчики как коллбэки (через props) или получаю эти данные в виде props.

Если несколько компонентов должны отражать одни и те же изменяющиеся данные - поднимаем общее состояние до ближайшего
общего предка.

**Ссылки**
- [Оф. документация - Подъём состояния](https://ru.reactjs.org/docs/lifting-state-up.html)

<br></p>
</details>

[//]: # (Key todo: доработать)
<details><summary><b>Key</b></summary><p>

Специальный строковый атрибут, который необходимо включать при создании списков элементов.<br>
Внутри вызова map() обязательно указывать ключи для элементов.

Атрибут, особое уникальное свойство элемента. Связывает данные и элементы React.<br>
Если быть точным - это special props. Не включается в объект props и недоступно внутри самого компонента.

Например, если надо удалить одну статью из 10 - React удалит только статью с нужным key, а остальные перестраивать не
будет.

Ключи помогают React идентифицировать, какие элементы были изменены, добавлены или удалены. Ключи должны быть заданы
элементам внутри массива, чтобы предоставить элементам постоянный идентификатор.

Ключи оптимизируют работу с элементами массивов, уменьшают количество ненужных удалений и созданий элементов.

При использовании ключей важно понимать, что при смене данных ключи должны меняться. Яркий пример ошибки- использование
индекса элемента в массиве как key. Но массив изменится, а индекс останется тот же...

Лучший способ выбрать ключ — использовать строку, которая однозначно идентифицирует элемент списка среди его соседних
элементов. Идеальные ключи должны браться из самих данных - id, уникальный title или ещё что-то в этом роде.

Если у вас нет постоянных идентификаторов для отрисовываемых элементов, в крайнем случае вы можете использовать индекс
элемента в массиве. Мы не рекомендуем использовать индексы для ключей, если порядок элементов может измениться. Это
может негативно сказаться на производительности и вызвать проблемы с состоянием компонента. Если вы решите не назначать
явный ключ для списка элементов, тогда React по умолчанию будет использовать индексы в качестве ключей.

Главная задача ключей в реакте — помогать механизму reconciliation. Без key механизм reconciliation сверяет компоненты
попарно между текущим и новым VDOM. Из-за этого может происходить большое количество лишних перерисовок интерфейса, что
замедляет работу приложения. Добавляя key, вы помогаете механизму reconciliation тем, что с key он сверяет не попарно, а
ищет компоненты с тем же key (тег / имя компонента при этом учитывается) — это уменьшает количество перерисовок
интерфейса. Обновлены/добавлены будут только те элементы, которые были изменены/не встречались в предыдущем дереве.

**Уникальность**

Ключи в массивах должны быть уникальными среди элементов того же уровня.<br>
Им не обязательно быть глобально уникальными.<br>
Можно использовать те же самые ключи при создании двух разных массивов.

Надо использовать только внутри `.map()` и подобных методов перебора массива

```javascript
function ListItem(props) {
  const value = props.value;
  return (
          // Неправильно! Здесь не нужно указывать ключ:
          <li key={value.toString()}>
            {value}
          </li>
  );
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
          // Неправильно! Здесь должен быть указан ключ:
          <ListItem value={number}/>
  );
  return (
          <ul>
            {listItems}
          </ul>
  );
}
```

**Ссылки**

- [Оф. документация - Списки и ключи](https://ru.react.js.org/docs/lists-and-keys.html)
- [Оф. документация - Согласование](https://ru.reactjs.org/docs/reconciliation.html#recursing-on-children)
- [habr - подробная статья](https://habr.com/ru/company/hh/blog/352150/)
- [YouTube - Отображение массивов, смысл аттрибута key](https://www.youtube.com/watch?v=tn9HyYRVZ9A)

<br></p>
</details>

[//]: # (Refs todo: доработать)
<details><summary><b>Refs</b></summary><p>

Аттрибут HTML-элемента или классового компонента.<br>
Если быть точным - это special props. Не включается в объект props и недоступно внутри самого компонента.<br>
От reference - ссылка.

Используются для получения ссылки на узел DOM или компонента в React.
Refs возвращает ссылку на элемент. Почти как старые добрые getElementById.

Работают только в классовых компонентах.<br>
**Современная альтернатива - хук `useRef`** Работает в функциональных.<br>
Хук `useRef` позволяет сохранить некоторый объект, который можно изменять, и который хранится в течение всей жизни
компонента.

`Ref` нужен чтоб «достучаться» к конкретному элементу и вызвать метод. <br>
Добавляем атрибут ref в компонент для обратного вызова.

Полезно в нескольких случаях.<br>
Например:

- вы хотите прочитать значение элемента без React
- навесить jQuery библиотеку на элемент
- вызвать какой-то нативный метод - например focus.

В обычном потоке данных React родительские компоненты могут взаимодействовать с дочерними только через пропсы.<br>
Чтобы модифицировать потомка — надо заново отрендерить его с новыми пропсами. Могут возникать ситуации, когда вам
требуется императивно изменить дочерний элемент (React-компонентом или DOM-элемент), обойдя обычный поток данных. Для
этого есть refs

Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части
компонента. Refs становятся доступны после метода render и перед componentDidMount.

**Почему бы не брать ссылку по ID элемента?**

- Под каждый элемент должна быть уникальная id, тогда как названия ref могут повторяться в разных компонентах.
- Это противоречит “философии” React.

**Best Practise**

- Выносите функции для получения ref в методы
- Не используйте string рефы (старый синтаксис ref)

**Избегаем использования**
Старайтесь не использовать, если в них не реальной необходимости.

Ref отличный способ доступа к DOM элементам, но его нужно применять с осторожностью. Это не React way, а просто
возможность доступа к DOM элементам. Если это возможно - лучше использовать state или props вместо refs, так как они
поддерживают правильный поток данных в приложении, а refs нет.

Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом. Например, вместо того чтобы
определять методы open() и close() в компоненте Dialog, лучше передавать ему проп isOpen

**Применение оправдано**

- Управление фокусом, выделение текста или воспроизведение медиа.
- Анимации.
- Интеграция с DOM библиотеками.

**Ссылки**

- [Оф. документация - Рефы и DOM](https://ru.reactjs.org/docs/refs-and-the-dom.html)
- [monsterlessons.com](https://monsterlessons.com/project/lessons/react-refs)
- [Refs в React: Всё что нужно знать](https://medium.com/@abraztsov/refs-%D0%B2-react-%D0%B2%D1%81%D1%91-%D1%87%D1%82%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-266a979690f8)
- [Оф. документация - Хук useRef](https://ru.reactjs.org/docs/hooks-reference.html#useref)
- [Mentanit - Хук useRef](https://metanit.com/web/react/6.4.php)
- [Hexlet - Хук useRef ](https://ru.hexlet.io/courses/js-react-hooks/lessons/use-ref/theory_unit)
- [Умный способ использования хука useRef() в React](https://bookflow.ru/umnyj-sposob-ispolzovaniya-huka-useref-v-react/)

<br></p>
</details>

[//]: # (Как правильно получать данные из html-элемента - без использования ref)
<details><summary>Как правильно получать данные из html-элемента (без использования ref)</summary>

	```javascript
        let onQuoteChanged = (event) => {
          let text = event.target.value;
        };
        return ( <textarea onChange={onQuoteChanged} value="Test" /> }
	```

</details>

[//]: # (Методы отладки React)
<details><summary><b>Методы отладки React</b></summary><p>

- React devtools поставляется в двух видах
    - отдельным пакетами
    - расширением для популярных браузеров. В расширении можно увидеть изменения состояний приложения и узлы
      виртуального DOM-дерева.
- console.log()
    Иногда хочется отлаживать по старинке, с помощью console.log(). 
    Можно получить значение переменной внутри JSX прямо в точке её применения.
      <img src={console.log('logo', logo) || logo} />
    Как это работает: 
      console.log() вернет undefined и код выполнится дальше по условию "||", 
      а в консоли браузера мы увидим искомое значение, например: "/static/media/logo.5d5d9eef.svg".
  - (() => { debugger })() || // anything
  - Отладка внутри IDE WebStorm
    - Установите расширение Chrome — JetBrains IDE Support.
    - Добавьте Run/Debug-конфигурацию.
    - Запустите create-react-app через терминал командой: $ yarn start
    - Выберите конфигурацию Debug и нажмите кнопку с иконкой жука (в правом верхнем углу IDE)
    - Откроется браузер с предупреждением "JetBrains IDE Support отлаживает этот браузер". Замечено, что если теперь
      открыть Chrome DevTools по [F12], то отладка в WebStorm завершится — не надо этого делать)
    - можно отметить нужную строчку кода, как точку останова, затем перегрузить страницу браузера по [F5], и получить
      желаемое — инструмент отладки внутри WebStorm.

**Ссылки**

- [IT-Kamasutra #91 - chrome extensions для react и redux - React JS](https://youtu.be/K2DB3B9PU9Q)

<br></p>
</details>

[//]: # (Алгоритм мыследеятельности при создании React-приложения)
<details><summary><b>Алгоритм мыследеятельности при создании React-приложения</b></summary><p>

- есть некий дизайн (UI)
- глядя на него, я начинаю общаться с заказчиком, и разбираться - какие данный приходят на ту или иную страницу, какие с
  ними действия происходят, и т.д.
- на основе этого я формирую state для каждой из страниц. Формирую BLL - Busines Logic Layer
- параллельно решаю вопрос как буду управлять state (state managment) - например, через Redux
- потом начинаю кодить компоненты UI и связывать их со state
- ну, и тестирование

<br></p>
</details>

[//]: # (Ссылки)
<details><summary><b>Ссылки</b></summary><p>

- [Оф. документация - обучение теоретическое](https://ru.reactjs.org/docs/)
- [Оф. документация - обучение практическое](https://ru.reactjs.org/tutorial/tutorial.html)
- [IT Kamasutra - лучший курс видео. Большой](https://www.youtube.com/channel/UCTW0FUhT0m-Bqg2trTbSs0g)
- [http://code.mu - курс. Должен быть неплох](http://code.mu/books/advanced/javascript/react/)
- [learn.javascript.ru - вводный курс видео. Короткий](https://learn.javascript.ru/screencast/react)
- [habr- Учебный курс по React, (28 частей)](https://habr.com/ru/company/ruvds/blog/432636/)
- [monsterlessons.com - вводные уроки. Видео + текст. Примерно 2017](https://monsterlessons.com/project/series/react-dlya-nachinayushih)
- [какой-то курc](https://habr.com/ru/company/ruvds/blog/432636/)
- [ещё курc](https://vk.com/@489914144)
- [developer.mozilla.org - раздел про JS-фрэймворки (частично на русском)](https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks)
- [Максим Пацианский](https://maxpfrontend.ru/)
- [npm trends - сравнение популярности React, Angular & Vue](https://www.npmtrends.com/react-vs-@angular/core-vs-vue)
- [google trends - сравнение популярности React, Angular & Vue](https://trends.google.ru/trends/explore?geo=RU&q=react,angular,vue)

<br></p>
</details>

<br></p>
</details>

[//]: # (Компоненты)
<details><summary><h3>Компоненты</h3></summary><p>

---

[//]: # (Названия компонент начинаются с Заглавной буквы)
<details><summary><b>Названия компонент начинаются с Заглавной буквы</b></summary><p>

Это важно, так как в работе будут сочетаться HTML-элементы и элементы React. <br>
Названия со строчных букв зарезервированы для HTML. Если вы попробуете назвать элемент просто button, при рендере
фреймворк проигнорирует его и отрисует обычную HTML-кнопку.

<br></p>
</details>

[//]: # (Компоненты = чистые функции)
<details><summary><b>Компоненты = чистые функции</b></summary><p>

React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.<br>
Чистые функции не пытаются ничего изменить и всегда отдают тот же результат (при условии, что на вход подаются одни и те
же данные).

Функция не должна работать ни с какими глобальными объектами или генерировать данные. Всё с чем она работает - только с
тем, что приходит в неё через props (т.е. через параметры функции).

Такие функции не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.
Возвращаемая разметка должна зависеть только от входящих значений props - если 100 раз вызвать функцию с одними и теми
же значениями props, мы 100 раз получим один и тот же результат.

State даёт компонентам возможность реагировать на действия пользователя, ответы сервера и другие события, не нарушая
чистоту компонента.

Если есть локальный стэйт - компонента не является чистой функцией. Т.к. она может хранить своё состояние, использовать
его, и в следующий раз при тех же входящих значениях вернуть новый ответ (т.к. сохранила в стэйте какие-то данные с
прошлого вызова, и использовала их для вычисления результата. Т.е вычисляет ответ не только по входящим данным, но ещё и
по стэйту.)

Такие компоненты легко тестировать. Легко предсказать что они вернут

**Как поддерживать чистоту компонент:**

- Никогда не менять по ссылке внешние (глобальные) переменные, массивы и т.д.<br>
  Не сортировать и вообще не трогать. Особенно то, что приходит в props.<br>
  Если надо изменить - создавай в компоненте отдельную переменную, записывай в неё, и её меняй.<br>
- Пропсы можно только читать!<br>
  Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или
  классовый.<br>
  У нас ссылочный тип данных - функция изменит props, и они изменятся в объекте где хранятся (например объект в памяти).
  Соответственно эти изменения могут вылезти где-то ещё. Один метод компонента случайно изменил данные, а другой метод
  потом взял уже изменённые (хотя ему нужны были оригинальные)...

Пример чистой функции - не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых
аргументов:
```javascript
  function sum(a, b) {
  return a + b;
}
```    

Пример нечистой функции — записывает данные в свои же аргументы:
```js
function withdraw(account, amount) {
  account.total -= amount;
}
```

**Ссылки**
- [IT-Kamasutra #88 - pure function (чистая функция)](https://youtu.be/KU81NnNcjmw)
- [Оф. документация - Компоненты и пропсы](https://ru.reactjs.org/docs/components-and-props.html)
- [YouTube - Отладка React-приложений (javascript.learn)](https://www.youtube.com/watch?v=NhT5nMvve4Q)
- Смотри подробнее в разделе «[Программирование — Чистые функции](/Pages/Programming/Programming.md)»

<br></p>
</details>

[//]: # (Компоненты контейнерные и презентационные todo: доработать)
<details><summary><b>Компоненты контейнерные и презентационные (умные/глупые)</b></summary><p>

Два типа компонент по типу задач, которые выполняют.

**Контейнерная**

Отвечает за данные и операции с ними. <br>
Например, берёт на себя общение со Redux или AJAX запросы.<br>
Позволяет поддерживать внутреннюю (глупую) компоненту чистой.

Всегда работают как обёртка вокруг другой компоненты - контейнерной или презентационной. <br>
Обычно не содержат разметки и не имеют CSS-стилей. Их задача - делать грязную/сложную работу (запросы и т.д.), а не
отрисовывать данные.

Их часто создают с использованием React-Redux, они могут осуществлять диспетчеризацию действий Redux.

**Презентационная**

Отвечает лишь за отрисовку полученных данных. И передачу в систему данных от пользователя (клик мышкой, ввод
текста...)<br>
Не осведомлены о состоянии Redux и прочем. Обычно содержат DOM-разметку (JSX, HTML...)

Часто обрачиваются контейнерными компонентами, которые берут на себя общение со Store и прочую логику. <br>
А презентационная компонента остаётся чистой, мало знает об окружении, не сильно с ним связана => может быть легко
переиспользована в другом проекте. И легко протестированна.

Могут быть обёрнуты контейнерной компонентой, либо работают без них (сами по себе)

Получают данные через свойства и могут вызывать коллбэки, которые также передаются им через свойства. Не должны изменять
данные.

Подробнее:

- Отвечают за внешний вид
- Могут содержать как другие presentation компоненты, так и контейнеры
- Поддерживают слоты (Often allow containment via this.props.children)
- Не зависят от приложения (Redux и т.д.)
- Не зависят от данных
- Интерфейс основан на props
- Часто stateless, т.е. не имею своего состояния
- Часто функциональные

**UNSORTED**

Контейнерная компонента - обёртка вокруг презентационной компоненты, чтоб сохранить её чистой (не зависимой от props,
store, state...)<br>
Тогда презентационную можно будет пере-использовать в других проектах и т.д.<br>
Т.е. чтоб презентационная компонента не использовала actionCreator из dispatch и прочее.<br>
Вместо этого мы всё получаем через props, а вместо dispatch используем callbacks.<br>

С другой стороны, если бы контейнерной компоненты не было - нам нужно было бы каждый callback прокидывать из store через
всё дерево в каждую презентационную компоненту. Это неудобно.<br>
Поэтому мы до контейнерной компоненты прокидываем обычный dispatch + state, в ней вызываем отрисовку чистой
презентационной компоненты, и передаём ей (через props) из этого dispatch колбэки и state.<br>

Контейнерная компонента общается со Store через context API (https://ru.reactjs.org/docs/context.html)

- Контейнерная компонента - берёт на себя общение со Store (ООП-объект, хранящий state).<br>
  И позволяет поддерживать внутреннюю компоненту чистой<br>
  Прокидывает в неё данные из Store (props, dispatch колбэки)<br>
  отрисовывает презентационную компоненту

- Если кратко, компоненты-контейнеры отвечают за данные и операции с ними. <br>
  Их состояние передается в виде свойств в компоненты-представления и отображается.

**Организация контейнерных компонент и AJAX**

- снаружи - контейнерная, которая через connect работает со Store
- в ней (в том же файле) - классовая, которая делает AJAX-запросы и прочие сайд-эффекты
- классовая вызывает отрисовку функциональной (которая лежит в отдельном файле). Та получает только props и отдаёт JSX

Презентационная компонента - чистая компонента, получает props, отдаёт JSX.
Всё получает через props (из контейнерной компоненты), а вместо dispatch используем callbacks.

***

- smart-компоненты - манипулируют данными
- dumb-компоненты - что-то отрисовывают

***
Пакет react-redux предоставляет привязки React для контейнера состояния Redux, чрезвычайно упрощая подключение
React-приложения к хранилищу Redux. Это позволяет разделять компоненты React-приложения, основываясь на их связи с
хранилищем. А именно, речь идёт о следующих видах компонентов:

- Презентационные компоненты. Они отвечают лишь за внешний вид приложения и не осведомлены о состоянии Redux. Они
  получают данные через свойства и могут вызывать коллбэки, которые также передаются им через свойства.
- Компоненты-контейнеры. Они ответственны за работу внутренних механизмов приложения и взаимодействуют с состоянием
  Redux. Их часто создают с использованием react-redux, они могут осуществлять диспетчеризацию действий Redux. Кроме
  того, они подписываются на изменения состояния.

**Ссылки:**

- [Презентационный компонент и контейнер в React](https://medium.com/@kanby/%D0%BF%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82-%D0%B8-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80-%D0%B2-react-f0e118480809)
- [Stateful и Функциональные stateless компоненты в React](https://code.tutsplus.com/ru/tutorials/stateful-vs-stateless-functional-components-in-react--cms-29541)
- [По поводу паттернов в React](https://medium.com/@abraztsov/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-react-e5092c06f019)
- [habr - Паттерны React](https://habr.com/ru/post/309422/)

<br></p>
</details>

[//]: # (Компоненты с состоянием и без)
<details><summary><b>Компоненты с состоянием и без (stateful/stateless)</b></summary><p>

Некоторые компоненты используют в React метод setState(), а некоторые нет.<br>

- Stateful - компоненты имеющие состояние (state). Всегда являются классовыми компонентами (у функциональных своего
  state нет).
- Stateless - компоненты без состояния. Могут быть и функциональными и классовыми.

**Недостатки stateful-компонент**

- Наличие состояния затрудняет тестирование компонентов
- Наличие состояния затрудняет понимание работы компонента
- Наличие состояния слишком легко позволяет вставить в компонент бизнес-логику. А это не хорошо
- Наличие состояния затрудняет обмен информацией с другими частями приложения. Состояние легко передаётся вниз (
  потомкам), а вот в стороны - намного труднее

**Ссылки:**

- [Stateful и Функциональные stateless компоненты в React](https://code.tutsplus.com/ru/tutorials/stateful-vs-stateless-functional-components-in-react--cms-29541)
- [По поводу паттернов в React](https://medium.com/@abraztsov/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-react-e5092c06f019)
- [habr - Паттерны React](https://habr.com/ru/post/309422/)

<br></p>
</details>

[//]: # (Компоненты классовые и функциональные todo: доработать)
<details><summary><b>Компоненты классовые и функциональные</b></summary><p>

**Функциональные** (Functional components) - простые компоненты, созданные как функции.<br>
React - функционально-ориентированная библиотека, так что рекомендуется использовать эти компоненты, там где можно.
Кстати, они появились позже

   ```
    //Создаются так:
    const Welcome = (props) => {}
    
    //Или так:
    function Welcome(props) {}
   ```
    
   **Классовые** (Class-Components) - объявлены как класс, имеют методы жизненного цикла, локальное состояние, refs и многие другие штуки. <br>
   Без лишней необходимости их лучше не использовать. С появлением хуков вообще становятся менее востребованны.
   ```
    //Создаются так:
    class Welcome extends React.Component {}
    
    //Или так:
    class Welcome extends React.PureComponent {}
   ```
   
   **UNSORTED**
   
  Есть два типа компонентов
    - функциональные - states - очень простые (тупые), без состояний (presentational, stateless, dumb). Это функция, которая принимает props и возвращает JSX
    - классовые - с использованием классов ES6 - с состояниями. Можно использовать методы жизненного цикла. Необходимы, если компонент имеет состояние или значимые методы.
    
  React-разработчики стараются минимизировать использование классовых компонент. Если можно решить вопрос функциональной компонентой - так и делай
    
  Есть два типа синтаксиса
  - функциональные компоненты. 
      Для очень простых компонентов, почти без логики (stateless компоненты):
          import React, {Component} from 'react';
          function Article(props) {}
              
  - классовый компонент (классы компонентов). 
      Позволяет использовать дополнительные возможности, такие как локальное состояние и методы жизненного цикла.
      Наследуется от базового компонента Component
      Должны содержать функцию render()
      Компоненты, основанные на классах, могут хранить информацию о текущей ситуации. Эта информация называется состоянием (state), она хранится в JS-объекте.
          
          import React, {Component} from 'react';
          class Article extends PureComponent {
            render () {}
          }
          
          метод render нужен обязательно, он отвечает за то, как будет выглядеть компонент.
          props будет жить в this.props   
   
    **Классовые компоненты**
  
  Класс, который наследуется от метода React.Component, у которого есть как минимму метод render, и который возвращает JSX
  
  
  Для чего нужны классы? Чтоб создавать однотипные объекты на базе этих классов и реализовать в них концепции ООП (инкапсуляция, полиморфизм, наследование)
    - Полиморфизм - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
    - Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
    - Инкапсуляция – сокрытие деталей. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
    - Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.
  
  Методы и обработчики классовых компонент писать так (кроме render): onClick = () => {}
  
      https://www.youtube.com/watch?v=vO63wxg4aKY
  
      Позволяет решить вопросы c контекстом вызова (bind и т.д.) - 
      Не забыть, что все обработчики (практически все) объявляются внутри классовой компоненты, как её метод
  
   setState - метод компонента. Обновляет его состояние, и вызывает перерисовку
   
      Вызов setState позволяет React перестроить ваше приложение и обновить DOM.
      Обычно когда необходимо обновить компонент вы просто вызываете setState с новым значением переданным в виде объекта в функцию setState: 
        this.setState({someField:someValue})

setState - использование стрелочной функции вместо объекта

        https://clck.ru/GDfFh
        раньше: setState(nextState)
        теперь: setState((s,p) => s) 
  
        позволяет использовать текущее состояние this.State, не опасаясь, что произойдёт что-то не то.  
        То есть: позволит получить вам достоверные значения для state и props компонента. 
        Иначе: так как this.props и this.state могут обновляться асинхронно, то не стоит полагаться на их значения для вычисления нового состояния. 
        Т.е. я хочу просто инвертировать свойство внутри state (например open/close), и делаю !this.state.isOpen. Но, к моменту выполнения кода этот параметр может уже измениться из другого места, и я получу неожиданный результат

**Обновления state могут быть асинхронными**

React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.

Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для
вычисления следующего состояния.

Например, следующий код может не обновить счётчик:

// Неправильно

```jsx
  this.setState({
  counter: this.state.counter + this.props.increment,
});
```

Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция
получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в
качестве второго аргумента:

// Правильно

```jsx
  this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```  

Set State перестраивает весь виртуальный DOM компонента, на котором он вызван.

И всех его вложенных компонентов! А потом вносятся изменения в реальный DOM.
Поэтому - если нет необходимости - не вызывай изменения set state у родителей, чтоб лишний раз не перестраивать
виртуальный DOM всех их потомков. Т.е. верхние уровни задействуем только тогда, когда это нужно

- Какой второй аргумент может быть передан в setState? Это функция обратного вызова, вызовется когда элемент отрендерен
  Это функция обратного вызова.
  Она реализовывается строго после setState, когда элемент отрендерен, и является полностью опциональной.
  Рекомендуется отдать предпочтение другому методу, нежели данной функции, но знать о ее существовании и принципе работы
  не помешает:

```jsx
  this.setState(
        {username: 'tylermcginnis33'},
        () => console.log('setState has finished and the component has re-rendered.')
)   
```

**Ссылки:**

- [Дэн Абрамов - Чем функциональные компоненты React отличаются от компонентов, основанных на классах? (!)](https://habr.com/ru/company/ruvds/blog/444348/)
- [По поводу паттернов в React](https://medium.com/@abraztsov/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-react-e5092c06f019)
- [habr - Паттерны React](https://habr.com/ru/post/309422/)

<br></p>
</details>

[//]: # (Компоненты контролируемые и не контролируемые)
<details><summary><b>Компоненты контролируемые и не контролируемые</b> (controlled и uncontrolled)</summary><p>

`Контролируемые` - работают через `state`, получают и пишут данные обычно в `state`.

`Неконтролируемые` - работают напрямую с виртуальным DOM-деревом, обычно через ссылку ref.

React делает упор на контролируемых компонентах.

В HTML элементы формы, такие как `input`, `textarea` и `select`, обычно поддерживают свое собственное состояние и
обновляют его на основе пользовательского ввода. Когда пользователь отправляет форму, значения из элементов, упомянутых
выше, отправляются вместе с формой.

Таким образом сам элемент формы становится `источником истины` — хранит информацию о своём состоянии.<br>
Это неправильно с точки зрения `Flux-архитектуры`.

В React это работает по-другому.<br>
Компонент, содержащий форму, будет отслеживать значение ввода в своем состоянии (local state или Redux) и повторно
визуализировать компонент каждый раз, когда вызывается функция обратного вызова `onChange`, например, при обновлении
состояния.<br>
Пользователь ввёл букву в input - она не отобразилась, но сработал обработчик `onChsnge` этого input. Данные о новой
букве ушли в стейт -> стейт обновился -> форма перерисовалась -> в input видна новая буква.

Элемент ввода формы, значение которого контролируется React, таким образом называется «контролируемым компонентом».

**Ссылки:**

- [Контролируемые и неконтролируемые компоненты в React ](https://dev-gang.ru/article/kontroliruemye-i-nekontroliruemye-komponenty-v-react-lo65aat2do/?ysclid=l7pi9fcywn122899507)
- [По поводу паттернов в React](https://medium.com/@abraztsov/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-react-e5092c06f019)
- [habr - Паттерны React](https://habr.com/ru/post/309422/)

<br></p>
</details>

[//]: # (PureComponent, React.memo  todo: доработать)
<details><summary><b>PureComponent, React.memo </b></summary><p>

Особый способ создания классовых компонент.<br>
Изменяет lifecycle-метод `shouldComponentUpdate`, автоматически проверяя, нужно ли заново отрисовывать компонент.

PureComponent будет вызывать функцию `render()`, только если обнаруживает изменения в `props` или в `state`.
В некоторых случаях `React.PureComponent` более эффективен и определенно уменьшает количество кода.

По сути, вариант реализации метода `shouldComponentUpdate` - поверхностно сравниваются все старые/новые `props` и все
старые/новые `state`. Если хоть что-то поменялось - перерисовываем компонент

Разница между `Component` и `PureComponent` заключается в методе `updating lifecycle: shouldComponentUpdate`.<br>
`Component` не реализует `shouldComponentUpdate()`, `PureComponent` реализует его поверхностным сравнением пропсов и
состояния.

В Component этот метод выглядит так:

```
shouldComponentUpdate(){
 return true;
}
```

В PureComponent:

```
shouldComponentUpdate(nextProps, nextState) {
 return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
}
```

Что такое `shallowEqual`? Это по сути сравнение оператором === каждого элемента из prevProps с каждым элементом из
nextProps.

Метод `shouldComponentUpdate()` базового класса `React.PureComponent` делает только поверхностное сравнение объектов.
Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то
есть, различий, не выраженных на поверхности структуры).

Наследуйте класс` PureComponent` только тогда, когда вы ожидаете использовать простые пропсы и состояние, или
используйте `forceUpdate()`, когда знаете, что вложенные структуры данных изменились. Также подумайте об использовании
иммутабельных объектов, чтобы упростить процесс сравнения вложенных данных.

Кроме того, метод `shouldComponentUpdate()` базового класса `React.PureComponent` пропускает обновление пропсов для
всего поддерева компонентов. Убедитесь, что все дочерние компоненты также являются «чистыми».

Важное замечание: `PureComponent` нужно использовать только для так называемых `presentational` components, т.е. для тех
компонент, которые НЕ обёрнуты в вызов `redux connect()`.

Для `container components` (т.е. тех компонент, которые обёрнуты в `redux connect()`) нет смысла наследоваться
от `PureComponent`, т.к. метод `connect()` оборачивает ваш компонент своей реализацией `shouldComponentUpdate`, которая
также использует `shallowEqual`. Если вы по недосмотру унаследуете container component от `PureComponent` - ошибок не
будет, но это не имеет никакого смыла, т.к. ваш код по сути будет дважды делать `shallowEqual`, а зачем делать лишнюю
работу?

Важно помнить, что `PureComonent` пропускает отрисовку не только самого компонента, но и всех его “детей”, так что
безопаснее всего применять его в presentational-компонентах, без “детей” и без зависимости от глобального состояния
приложения.

В случае, если pure-компонент имеет детей, все дочерние компоненты, зависящие от смены контекста, не будут реагировать
на изменения, если в родительском pure-компоненте не будет объявлен contextTypes.

**React.memo**

Если я хочу использовать функциональный компонент вместо классового — аналогичную оптимизацию даёт
использование `React.memo`

```jsx
const Item = React.memo(props => {
  return 'some JSX'
})
```

**UNSORTED**

Важно: при вызове render() перерисовывается не только родительский компонент, но и все дочерние (хотя, в них свойства
могли и не поменяться). Т.е. если у родительского компонента внутри render есть дочерние компоненты - они будут
перерисовываться. Соотвественно, если мы вызываем render на родительском компоненте - перерисуем всё приложение. Чтоб
решить этот вопрос - используем создание компонента от PureComponent

Даже если я создал класс от PureComponent - это не гарантирует отсутсвие лишних ренедров при тех же данных. Одна из
причин - анонимные функци (они при каждом рендере новые).

```
//Неверно:
<Component onClick= {() => this.hangleClick}>

//Верно:
<Component onClick= {this.hangleClick}>
```

автоматически проверяет, должен ли компонент обновляться. Не нужно писать shouldComponentUpdate самостоятельно.

PureComponent будет вызывать функцию render(), только если обнаруживает изменения в props или в состоянии.
В некоторых случаях React.PureComponent более эффективен и определенно уменьшает количество кода.

Если в props вы передаёте объекты которые иногда мутируются, т.е. по ссылке они равны ===, но внутри какие-то данные
поменялись (что само по себе выглядит странно в экосистеме redux + reselect, но вполне возможно технически), тогда
использование PureComponent вам всё поломает, т.к. на экране какие-то компоненты перестанут перерисовываться!

Если же у вас всё по уму, данные которые передаются через props являются скалярными типами (string, int, float, bool)
или immutable объектами, тогда смело используйте PureComponent - в некоторых случаях он поможет избавиться от лишних
вызовов render.

Важное замечание: PureComponent нужно использовать только для так называемых presentational components, т.е. для тех
компонент, которые НЕ обёрнуты в вызов redux connect().

Для container components (т.е. тех компонент, которые обёрнуты в redux connect()) нет смысла наследоваться от
PureComponent, т.к. метод connect() оборачивает ваш компонент своей реализацией shouldComponentUpdate, которая также
использует shallowEqual. Если вы по недосмотру унаследуете container component от PureComponent - ошибок не будет, но
это не имеет никакого смыла, т.к. ваш код по сути будет дважды делать shallowEqual, а зачем делать лишнюю работу?

По сути, вариант реализации метода shouldComponentUpdate - поверхностно сравниваются все старые/новые property и все
старые/новые state. Если хоть что-то поменялось - перерисовываем компонент

Подводя итог, рецепт такой:

- presentational components наследуем от React.PureComponent
- container components (которые обёрнуты в redux connect()) наследуем от старого доброго React.Component

Важно помнить, что PureComonent пропускает отрисовку не только самого компонента, но и всех его “детей”, так что
безопаснее всего применять его в presentational-компонентах, без “детей” и без зависимости от глобального состояния
приложения.
В случае, если pure-компонент имеет детей, все дочерние компоненты, зависящие от смены контекста, не будут реагировать
на изменения, если в родительском pure-компоненте не будет объявлен contextTypes.

**Ссылки**

- [Оф. документация - React.PureComponent](https://ru.reactjs.org/docs/react-api.html#reactpurecomponent)
- [habr - Разбор: как и зачем применять PureComponent в React](https://habr.com/ru/company/redmadrobot/blog/318222/)
- [PureComponent и Components](https://medium.com/frontend-notes/purecomponent-%D0%B8-components-5c15cf206ba7)
- [csssr - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
- [YouTube - Какие props портят производительность](https://www.youtube.com/watch?v=zSDOxWhPG_U)
- [totser](https://toster.ru/q/384870)
- [habr - Оптимизация производительности в React](https://habr.com/ru/post/319536/)
- [IT-Kamasutra #87 - shouldComponentUpdate, PureComponent, memo ](https://youtu.be/YEqCI9NMoLI)

<br></p>
</details>

[//]: # (HOC. Компоненты высшего порядка. Отличия от декораторов Higher Order Components, )
<details><summary><b>HOC (Higher Order Components)</b> Компоненты высшего порядка</summary><p>

HOC — функция.<br>
Принимает компонент и возвращает новый контейнерный компонент (функциональный или классовый).<br>
Если функция возвращает JSX - это компонент. Если возвращает другую компоненту - это HOC.

HOC — способ повторного использования логики, кода.<br>
Позволяет создавать однотипные контейнерные компоненты, передавая в них презентационные компоненты (те, которые надо
обернуть).

HOC часто называют с префиксом «with» — `withRedirect`, `withAuth`...<br>
В зависимости от того, какую функциональность добавляет данный HOC.
<br>
<br>

  **Примеры:**
  - Компонент, возвращает JSX
  ```jsx
    let User = (props) => {
      return <div>
        <h1>[props.name]</h1>
      </div>
    }
  ```
  - Компонент, возвращает JSX (который отрисовывает другой компонент)
  ```jsx
    let UserContainer = (props) => {
      return <User example="text" />
    }
  ```
  - HOC — принимает компонент, возвращает другой компонент (контейнерный)
  ```jsx
    let HOComponent = (User) => {
      return UserContainer
    }    
  ```
  - Если точнее, HOC будет выглядеть примерно так:
  ```jsx
    let HOComponent = (Component) => {
      let WrapperContainer = (props) => {
        return <Component example="text" />
      }
      return WrapperContainer
    }    
  ```
  - `Connect` из Redux - это тоже HOC. Ну, если быть точным - он возвращает HOC
  - `withRouter` из React Router - это тоже HOC.
  <br>
  <br>

  **Декораторы**<br>  
  Ещё есть декораторы. Декораторы и HOC делают одно и то же. 
  
  Основные отличия от HOC: 
  - после добавления декоратора свойство/класс можно использовать только в его оформленной форме. HOC pattern оставляет доступными для использования как компоненты более высокого, так и более низкого порядка.
  - декораторы используются для мутации переменной, a HOC рекомендуется так не использовать. 
  - HOC должен представлять компонент, в то время как декораторы могут возвращать разные вещи в зависимости от реализации.

  Ссылки по декораторам:
  - [Декораторы в React или как оптимизировать ваши компоненты](https://webtricks-master.ru/reactjs/dekoratory-v-react-ili-kak-optimizirovat-vashi-komponenty/)
  - [В чем разница между HOC и декоратором? (en)](https://stackoverflow.com/questions/48686826/react-js-what-is-the-difference-betwen-hoc-and-decorator)
    <br>
    <br>

**Ссылки**
- [Оф. документация - Компоненты высшего порядка](https://ru.reactjs.org/docs/higher-order-components.html)
- [YouTube - IT Kamasutra 69](https://www.youtube.com/watch?v=7W4PD4BN3eY)
- [YouTube - IT Kamasutra 70](https://www.youtube.com/watch?v=tf4E6tw8ZVw)
- [По поводу паттернов в React](https://medium.com/@abraztsov/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-react-e5092c06f019)
- [habr - Паттерны React](https://habr.com/ru/post/309422/)
- [Разбираемся с Render Props и HOC в React](https://medium.com/nuances-of-programming/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-react-render-props-%D0%B8-hoc-263f498ac841)
- [Путь Самурая 2.0 - #15. Hooks, оно нам надо?](https://youtu.be/UR7YwFevxb4)

<br></p>
</details>

[//]: # (Render props todo: осмыслять)
<details><summary><b>Render props, Render Callbacks (Функция в render)</b></summary><p>

Ещё один способ сделать логику переиспользуемой. Это становится возможным при помощи передаваемого children-а в виде
функции.

**Ссылки**

- [Разбираемся с Render Props и HOC в React](https://medium.com/nuances-of-programming/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-react-render-props-%D0%B8-hoc-263f498ac841)
- [По поводу паттернов в React](https://medium.com/@abraztsov/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%B2-react-e5092c06f019)
- [habr - Паттерны React](https://habr.com/ru/post/309422/)

  <br></p>

</details>

[//]: # (Компоненты — советы по организации кода)
<details><summary><b>Компоненты — советы по организации кода</b></summary><p>

- Компоненты обычно располагаются в папке src/components.
- На каждый компонент обычно заводят отдельный файл.
- Название файла обычно = названию компонента, также с большой буквы. Например: `src/components/Article.js`
- Каждый раз добавляя новую функциональность - думать чтоб вынести её в отдельный компонент.
- Каждый раз дублируя код - думать чтоб вынести её в отдельный компонент/функцию.

<br></p>
</details>

<br></p>
</details>

[//]: # (Компоненты. Жизненный цикл)
<details><summary><h3>Компоненты. Жизненный цикл</h3></summary><p>

---
[//]: # (Общее)
<details><summary><b>Общее</b></summary><p>

Методы, которые React вызывает при разных событиях из жизни компонента (появление, удаление...)<br>
Каждый классовый компонент имеет несколько «методов жизненного цикла».<br>
Можно переопределить методы для запуска кода в определённое время в процессе работы приложения.<br>
Единственный обязательный метод в подклассе React.Component — render(). Все остальные методы, описанные ниже, являются
необязательными.<br>

**Префикс в названии**

- will - вызываются прямо перед тем, как что-то происходит,
- did - вызываются сразу после того, как что-то происходит.
- should - должен

**Ссылки**

- [Оф. документация](https://ru.react.js.org/docs/react-component.html)
- [Mentanit.com - Жизненный цикл компонента](https://metanit.com/web/react/2.6.php)
- [Habr - Понимание жизненного цикла React-компонента (2018)](https://habr.com/ru/post/358090)
- [WebDev - Методы жизненного цикла](https://youtu.be/O8f6aXqpGHw)

<br></p>
</details>

---
**1. Монтирование** - когда экземпляр компонента создаётся и монтируется в DOM

[//]: # (constructor)
<details><summary><b>constructor()</b> - конструктор, в котором происходит начальная инициализация компонента</summary><p>

Если вы не инициализируете состояние и не привязываете методы, вам не нужно реализовывать конструктор для вашего
компонента React.

Конструктор компонента React вызывается до его монтирования. При реализации конструктора подкласса React.Component вы
должны вызвать super(props) перед любым другим оператором. В противном случае this.props не будет определен в
конструкторе, что может привести к ошибкам.

Как правило, в React конструкторы используются для двух целей:

- Инициализация локального состояния путем присвоения объекта this.state.
- Привязка методов-обработчиквов событий к экземпляру.

Вы не должны вызывать setState() в constructor(). Вместо этого, если вашему компоненту нужно использовать локальное
состояние, присвойте начальное состояние this.state непосредственно в конструкторе

<br></p>
</details>

[//]: # (static getDerivedStateFromProps)
<details><summary>static getDerivedStateFromProps()</summary><p>

[static getDerivedStateFromProps()](https://ru.react.js.org/docs/react-component.html#static-getderivedstatefromprops)

<br></p>
</details>

[//]: # (render)
<details><summary><b>render()</b> - рендеринг компонента</summary><p>

чистый, не пихать сюда ничего. Только для того, чтобы строить виртуальный DOM компонента

<br></p>
</details>

[//]: # (componentDidMount)
<details><summary><b>componentDidMount()</b> - после рендеринга компонента. Здесь можно выполнять запросы к удаленным ресурсам.</summary><p>

- реагируем на появление компонента в реальном DOM.
- Например получить размеры, позиционирование, подписаться на изменение данных, повесить свои listener на
  DOM-элементы...
- происходит один единственный раз - при отрисовке компоненты на странице. При обновлении - не вызывается.
- Все сайд-эффекты делать в ComponentDidMount() Например, там вызываются запросы на сервак, AJAX-запросы, setTimeout и
  все манипуляции с DOOM

Т.е. Реакт вызывает у компонента метод `render()`, получает из него `JSX`, выводит этот `JSX->HTML` на странице.
И потом вызывает у компонента метод `componentDidMount()`

<br></p>
</details>

---
**2. Обновление** - когда компонент перерисовывается. Может быть вызвано изменениями в state или props

[//]: # (static getDerivedStateFromProps)
<details><summary>static getDerivedStateFromProps()</summary><p>

Заменяет componentWillReceiveProps()

Вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при обновлениях. Должен
вернуть объект для обновления состояния или null, чтобы ничего не обновлять.

Этот метод запускается при каждом рендере, независимо от причины.

Метод существует для редких случаев, когда state компонента зависит от изменений в props. Т.е. когда состояние
компонента должно меняться, в зависимости от изменений props, который переадёт родитель.

Как и метод render, getDerivedStateFromProps должен быть чистой функцией props и state.

Есть более простые альтернативы, при прочих равных лучше использовать их. Убедитесь, что вы знакомы с простыми
альтернативами:

- Чтобы выполнить побочный эффект при изменении пропсов (например, сетевой запрос или анимацию) используйте
  componentDidUpdate.
- Чтобы повторно вычислить данные при изменении пропсов, используйте функцию мемоизации.
- Чтобы «сбросить» некоторое состояние при изменении пропсов, используйте управляемые компоненты или неуправляемые
  компоненты с ключом.

  В большинстве случаев от применения getDerivedStateFromProps (и его предшественника componentWillReceiveProps) можно
  избавиться, перемещая управление состоянием в родительский компонент.

  Помните, что большинство компонентов не нуждаются в getDerivedStateFromProps. Он не предназначен для использования
  точь в точь, как componentWillReceiveProps.

  **Ссылки**
- [static getDerivedStateFromProps()](https://ru.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)
- [React v16.4.0: события указателя](https://learn-reactjs.ru/updates/react-v16.4.0-pointer-events)
- [YouTube - React 16.3 news (субтитры)](https://www.youtube.com/watch?v=XqFCMObsyKk)

  <br></p>

</details>

[//]: # (shouldComponentUpdate)
<details><summary><b>shouldComponentUpdate()</b> - каждый раз при обновлении объекта props или state</summary><p>

- позволяет оптимизировать приложение в ручном режиме, управляя тем, нужно ли перестраивать виртуальный DOM для этого
  компонента или нет?
- т.е. позволяет оптимизировать перерисовку виртуального DOM - если в это компоненте ничего не поменялось, не
  перерисовываем
- Вызывается при изменении родителей, и при смене setState в самом компоненте.
- Не забывать, про сравнение ссылочных типов. Не должно быть мутации данных
    - Каждый раз, когда меняются данные, должна создаваться новая ссылка.
      либо заменяем все мутабельные операции на аналогичные иммутабельные операции,
      либо создаем новую ссылку и затем уже её мутируем.
    - Новая ссылка должна создаваться только тогда, когда меняются данные.
- Предупреждает, что сейчас будем перестраивать виртуальный DOM этого компонента.
  Можно отреагировать на изменения - загрузить текст для статьи, которая открывается и т.д. Вызывается и при изменении
  родителей, и при смене setState в самом компоненте.

**Ссылки:**

- [YouTube - Оптимизация приложений, shouldComponentUpdate](https://www.youtube.com/watch?v=Jw1zocLDnnc)
- [IT-Kamasutra #87 - shouldComponentUpdate, PureComponent, memo ](https://youtu.be/YEqCI9NMoLI)

<br></p>
</details>

[//]: # (render)
<details><summary><b>render()</b></summary><p>

- чистый, не пихать сюда ничего.
  Только для того, чтобы строить виртуальный DOM компонента
- Использовать его для обновления компонента. Можно, при создании компонента, наследовать его от компонента
  PureComponent - тогда сравниваются ВСЕ props (старые и новые) и ВСЕ элементы state (старые и новые).
  Т.е. не надо каждый раз объявлять «отслеживай ещё изменения этого параметра» — он будет следить по-умолчанию.
  Но, без необходимости лучше не использовать — могу вылезти сложные баги

<br></p>
</details>

[//]: # (getSnapshotBeforeUpdate)
<details><summary>getSnapshotBeforeUpdate()</summary><p>

[getSnapshotBeforeUpdate()](https://ru.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate)

<br></p>
</details>

[//]: # (componentDidUpdate)
<details><summary><b>componentDidUpdate(prevProps, prevState, snapshot) </b> - сразу после обновления компонента (если shouldComponentUpdate возвращает true</summary><p>

Вызывается сразу после обновления.
Не вызывается при первоначальной отрисовке.

Реакт вызывает у компонента (точнее объекта) метод `render()`, получает из него `JSX`, выводит этот `JSX->HTML` на
странице (делает `append`).<br>
И потом вызывает у компонента метод `componentDidMount()`.<br>
В компоненте что-то изменилось (пришли новые props, или обновился локальный state).<br>
Реакт снова вызывает метод `render()`, получает новый `JSX`, выводит этот `JSX->HTML` на странице (но делает уже
не `append`, а `update`).<br>
И потом вызывает у компонента метод `componentDidUpdate()`.<br>

В качестве параметров передаются старые значения объектов props и state.<br>
Третий параметр - значение, которое возвращает метод getSnapshotBeforeUpdate

Вызывается после того как отработал `render`, в каждом цикле перерисовки.<br>
Это означает — можно быть уверенным, что компонент и все его дочерние компоненты уже перерисовали себя.

В связи с этим эта функция является единственной функцией, что гарантировано будет вызвана только раз в каждом цикле
перерисовки, поэтому любые сайд-эффекты рекомендуется выполнять именно здесь. Как componentWillUpdate и
componentWillRecieveProps в эту функцию передается предыдущие props, состояние (state) и контекст, даже если в этих
значениях не было изменений. Поэтому разработчики должны вручную проверять переданные значения на изменения и только
потом производить различные апдейт операции.

ДЕЛАЙТЕ:

- Выполняйте сайд-эффекты (Вызовы AJAX и т.д.)

НЕ ДЕЛАЙТЕ:

- Не вызывайте this.setState т.к. это будет вызывать циклическую перерисовку.

Чаще всего нужен:

- если нас интересуют составляющие реального DOM (размер компонента, позиционирование...)
- хорошее место для выполнения сетевых запросов, если вы сравниваете текущие свойства с предыдущими свойствами (
  например, не нужно делать сетевой запрос, если свойство не изменилось).

Можно вызывать `setState()`, но этот вызов должен находится в условии. Иначе можно устроить бесконечный цикл.

`componentDidUpdate()` не будет вызываться, если `shouldComponentUpdate()` возвращает `false`.

- [Оф. документация - метод жизненного цикла componentDidUpdate()](https://ru.react.js.org/docs/react-component.html#componentdidupdate)

<br></p>
</details>

---
**3 Демонтирование** - когда компонент удаляется из DOM

[//]: # (componentWillUnmount)
<details><summary><b>componentWillUnmount()</b> - перед удалением компонента из DOM.</summary><p>

предупреждает что компонент будет удалён.

Подчищаем подписки, проводим логику деструктуризации компонента

Например, остановить и обнулить таймер

<br></p>
</details>

---
**4 Обработка ошибок** - при возникновении ошибки

[//]: # (componentDidCatch)
<details><summary><b>componentDidCatch()</b></summary><p>

Вызывается при ошибках:

- ошибки во время отрисовки
- ошибки в методе жизненного цикла
- ошибки в конструкторе любого дочернего компонента.

<br></p>
</details>

---
**Устаревшие методы. Избегайте их:**

[//]: # (1. componentWillMount)
<details><summary>1. componentWillMount() - непосредственно перед рендерингом компонента</summary><p>

Часто используется для получения данных (отправка запроса за статьёй на сервер и т.д.)

Вместо него лучше использовать componentDid Mount

На самом деле:

- если нужно выставить изначальное состояние компоеннта - делайте это в конструкторе
- если нужно изменять DOM - делайте это в componentDid Mount

<br></p>
</details>

[//]: # (2. componentWillReceiveProp)
<details><summary>2. componentWillReceiveProps()</summary><p>

При обновлении props, до монтирования новых.

Вместо него добавляется новый - getDerivedStateFromProps

Здесь надо обновлять state компонента из приходящих props

Тут приходят новые props.

Вызывается до монтирования новых пропсов в компонент.

Обычно в этой функции устанавливаются свойства компонента (в том числе из this.state), которые зависят от значений из
пришедших в компонент props

React передаёт новые props, которые можно сравнить с текущими. Вызывается только если поменялся кто-то из родителей и
буду меняться какие-то props.

Два основных варианта использования:

- поменялись важные данные и надо отреагировать. Например пришла новая статья и надо загрузить её с сервера
- мы завязали состояние компонента на porps (не лучшая практика, но иногда оптимальная) - теперь надо следить за
  изменениями в props, и приводить state к нужному виду. Например, состояние статьи (свёрнута/развёрнута) приходят в
  компонент из другого компонента, через props. Тогда надо отслеживать -изменились ли эти props, и перерисовывать
  состояния статьи

<br></p>
</details>

[//]: # (2. componentWillUpdate)
<details><summary>2. componentWillUpdate()</summary><p>

перед обновлением компонента (если shouldComponentUpdate вернул true)

Вместо него рекомендуется использовать componentDidUpdate

<br></p>
</details>
  
<br>

**I. Другие API (есть у каждого компонента)**<br>
  - setState()
  - forceUpdate()

**II. Свойства класса**

- defaultProps
- displayName

**III. Свойства экземпляра**

- props
- state

---
[//]: # (Unsorted)
<details><summary>Unsorted</summary><p>

1. Сначала определяется шаблон React.js для создания элементов из компонента.
2. Указывается где он будет использован. К примеру, внутри вызова функции рендера иного компонента или с помощью
   ReactDOM.render.
3. Реакт создает экземпляр элемента и передает ему набор свойств (props), доступ к которым будет доступен через
   this.props.
4. Поскольку описанное является JavaScript-ом, будет вызван метод конструктора класса (если он определен). Это первый из
   методов, которые называются методами жизненного цикла компонента.
5. React обрабатывает результат вызова функции рендера.
6. Затем React осуществит монтирование компонента: взаимодействуя с браузером через DOM API, React выполнит рендеринг.
7. Следом, Реакт вызывает другой метод жизненного цикла, который называется componentDidMount. Этот метод можно
   использовать, чтобы что-то сделать в дереве документа. Весь DOM, с которым мы работали ранее был виртуальным.
8. Демонтирование. Жизненный цикл некоторых компонентов заканчивается уже на этом этапе. Компоненты могут быть
   демонтированы из документа по разным причинам. Однако, перед этим Реакт вызывает другой метод – componentWillUnmount.

Реакт контролирует состояние каждого компонента на случай изменений. Для того, чтобы React действовал эффективно, необходимо изменить поле состояния с помощью API React и функции this.setState.
   
Входными данными для render() являются свойства (props) и внутреннее состояние, которое может быть обновлено в любое время.
   
Когда для render меняются входные данные, меняется и результат ее выполнения.
   
React.js ведет запись жизненного цикла компонента. Когда React.js видит, что один рендер отличается от другого, он переводит разницу между своим виртуальным представлением в операции с DOM API, которые будут отрисованы в документе.
   
Теперь, когда мы знаем, что за магия происходит при изменении состояния компонента, рассмотрим оставшиеся концепции.
  
1. Компонент может быть необходимо повторно отрисовать, если его состояние будет обновлено, либо, если родительский элемент изменит свои свойства.
2. Если были изменены свойства, React.js вызовет метод жизненного цикла componentWillReceiveProps.
3. Если объект или его свойства были изменены, React.js вызывает еще один метод – shouldComponentUpdate, который, по сути, является вопросом. Так что, если есть необходимость самостоятельно настроить процесс рендера, вы можете ответить на этот вопрос вернув true или false.
4. Если shouldComponentUpdate не объявлен, Реакт вызовет безусловный componentWillUpdate и рассчитает различия между текущим компонентом и его новым видом, с учетом изменений.
5. Если никаких изменений не зафиксировано, React.js ничего не сделает.
6. Если разница есть, фреймворк отрисует компонент.
7. Так как процесс обновления в любом случае произошел, Реакт вызовет метод componentDidUpdate.

  
1. Сначала мы определяем шаблон для React для создания элементов из компонента.
2. Затем мы указываем React где будем его использовать. Например, внутри вызова функции render другого компонента или с помощью ReactDOM.render.
3. Затем React создает экземпляр элемента и передает ему набор props, к которым мы можем получить доступ с помощью this.props. Эти props — это то, что мы передали на шаге 2.
4. Поскольку это все JavaScript, то будет вызван метод конструктора (если он определен). Это первый метод из тех, что мы называем методами жизненного цикла компонентов.
5. Затем React обрабатывает результат вызова функции render (получает виртуальный узел DOM).
6. Поскольку это первый раз, когда React выполняет рендеринг элемента, React будет взаимодействовать с браузером (от нашего имени, используя DOM API), чтобы отобразить в нем элемент. Этот процесс широко известен как монтирование.
7. Затем React вызывает другой метод жизненного цикла, называемый componentDidMount. Мы можем использовать этот метод, чтобы, например, сделать что-то в DOM, который, как мы знаем, существует в браузере. До этого метода жизненного цикла, DOM, с которым мы работали, был виртуальным.
8. Некоторые истории компонентов заканчиваются здесь. Компоненты демонтируются из DOM браузера по разным причинам. Но перед тем как это произойдет, React вызывает другой метод жизненного цикла, componentWillUnmount.
9. Состояние любого смонтированного элемента может измениться. Родитель этого элемента может быть повторно отрисован.
   Также смонтированный элемент может получить другой набор props. И здесь начинается магия React и наступает именно тот
   момент, когда React нам так необходим! Честно говоря, до этого он нам особо и не был нужен.
10. История этого компонента не заканчивается, но прежде чем продолжить, нам нужно понять, что же это за состояние, о
    котором я говорю.

**Ссылки**

- [Схема (en)](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
- [Оф. документация - React.Component](https://reactjs.org/docs/react-component.html)
- [https://metanit.com/web/react/2.6.php](https://metanit.com/web/react/2.6.php)
- [https://learn-reactjs.ru/reference/react-component](https://learn-reactjs.ru/reference/react-component)
- [Основные концепции React.js, о которых стоит знать](https://proglib.io/p/react-js-concepts/)
- [YouTube - React 16.3 news (субтитры) ](https://www.youtube.com/watch?v=XqFCMObsyKk)

<br></p>
</details>

<br></p>
</details>

[//]: # (setState API)
<details><summary><h3>setState() API</h3></summary><p>

По умолчанию, когда состояние или свойства вашего компонента изменяются, компонент будет перерисован. Если метод
render() зависит от некоторых других данных, вы можете указать React, что компонент нуждается в повторной отрисовке,
вызвав forceUpdate().

Вызов forceUpdate() приведёт к выполнению метода render() в компоненте, пропуская shouldComponentUpdate(). Это вызовет
обычные методы жизненного цикла для дочерних компонентов, включая метод каждого дочернего элемента
shouldComponentUpdate(). React по-прежнему будет обновлять DOM только в случае изменения разметки.

Обычно вам стоит пытаться избегать все виды использования forceUpdate() и только читать из this.props и this.state в
render().

**Ссылки**

- [Оф. документация - Другие API](https://ru.react.js.org/docs/react-component.html)

<br></p>
</details>

[//]: # (forceUpdate API)
<details><summary><h3>forceUpdate() API</h3></summary><p>

`setState ()` ставит в очередь изменения в состояние компонента и указывает React, что этот компонент и его дочерние
элементы должны быть повторно отрисованы с обновлённым состоянием. Это основной метод, который вы будете использовать
для обновления пользовательского интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о `setState()` как о запросе, а не как о команде немедленного действия для обновления компонента. Для лучшей
очевидной производительности React может задержать выполнение, а затем обновить несколько компонентов за один проход.
React не гарантирует незамедлительного применения изменений в состоянии.

`setState()` не всегда сразу обновляет компонент. Этот метод может группировать или откладывать обновление до следующего
раза. Это делает чтение `this.state` сразу после вызова `setState()` потенциальной ловушки. Вместо этого используйте

- `componentDidUpdate()`
- или обратный вызов `setState() (setState (updater, callback))`, любой из которых может быть запущен после того, как
  обновление было применено.
- Если вам нужно обновить состояние на основе предыдущего состояния, прочитайте ниже аргумент `updater`.

`setState((state, props) => stateChange, callback)`

```js
this.setState((state, props) => {
  return {counter: state.counter + props.step};
}, aomeCallback);
```

`setState()` имеет два параметра:

- функция updater `(state, props) => stateChange`. Принимает предыдущий state, props. Возвращает новый объект
- необязательный колбэк, вызываемый после завершения работы setState. Далее компонент будет повторно отрисован. Обычно
  для подобной логики рекомендуют использовать `componentDidUpdate()`.

**Ссылки**

- [Оф. документация - Другие API](https://ru.react.js.org/docs/react-component.html)

<br></p>
</details>

[//]: # (Context API)
<details><summary><h3>Context API</h3></summary><p>

---

[//]: # (Что такое контекст и зачем он нужен?)
<details><summary><b>Что такое контекст и зачем он нужен?</b></summary><p>

Объект, который создаётся у родителя и доступен всем детям.

Контекст предоставляет способ делиться данными между компонентами без необходимости явно передавать пропсы через каждый
уровень дерева.

Может содержать некоторые очень глобальные данные - активный язык приложения (ru/en), активную тему оформления (
ночь/день), store... Т.е. что-то, что редко меняется

Что попало туда пихать не надо, только очень глобальные вещи.

Контекст нужен чтобы не пробрасывать некоторые данные по длинной цепочке только для того, чтоб они пришли в компоненту
нижнего уровня - эти данные помещаются в контекст а компонента нижнего уровня берёт их сразу оттуда, не из props. Обычно
контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По
возможности не используйте его, так как это усложняет переиспользование компонентов.

Раньше был [старый синтаксис](https://ru.reactjs.org/docs/legacy-context.html) Context, его использовать не надо

<br></p>
</details>

[//]: # (Context API: createContext, Provider, Consumer)
<details><summary><b>Context API: createContext, Provider, Consumer</b></summary><p>

- Функция React.createContext, которая создает объект Context
- Provider (возвращается createContext) - устанавливает «шину» для прямой передачи данных, проходящую через дерево
  компонентов
- Consumer (возвращается createContext) - впитывается в «шину» для извлечения данных

<br></p>
</details>

[//]: # (Provider)
<details><summary><b>Provider</b></summary><p>

Provider очень похож на Provider в React-Redux. Он принимает значение, которое может быть всем, чем хотите (это может
быть даже store Redux… но это было бы глупо). Скорее всего, это объект, содержащий ваши данные и любые actions, которые
вы хотите выполнить с данными.

<br></p>
</details>

[//]: # (Consumer)
<details><summary><b>Consumer</b></summary><p> 

Consumer работает немного похоже как функция connect в React-Redux, подключаясь к данным, и сделав их доступными для
компонента, который их использует.

<br></p>
</details> 

**Ссылки**

- [Оф. документация - Контекст](https://ru.reactjs.org/docs/context.html)
- [https://habr.com/ru/post/419449/](https://habr.com/ru/post/419449/)

<br></p>
</details>

[//]: # (Хуки)
<details><summary><h3>Хуки</h3></summary><p>

---

[//]: # (Хук в программировании)
<details><summary>Хук в программировании</summary><p>

`Hooking` (перехват) — технология изменения поведения программы путем перехвата вызовов функций.
Используется повсеместно - в операционных системах, CMS и т.д.<br>

Позволяет отследить событие Х в системе и вызвать в этот момент свою функцию. <br>
Система сообщает: *сейчас я буду делать то-то, есть желающие в этот момент выполнить свою логику?*  <br>
Если какие-то сторонние функции на это событие/хук «подписаны» — они в этот момент будут вызваны.<br>

Т.е. это заложенная в систему возможность:

- уведомлять другие программы/процессы о своих событиях
- вызывать их функции (в момент наступления данных событий)
- как-то обработать и применить то, что эти функции делают.<br>

`Hook` (крючок, перехватчик)— код, который обрабатывает эти перехваченные вызовы функций или события.<br>
Т.е. та часть основной программы, которая обрабатывает пришедшую со стороны функцию.

<br></p>
</details>

[//]: # (Хук в React)
<details><summary>Хук в React</summary><p>

Хуки в React — функции для работы со state и методами жизненного цикла в функциональных компонентах.

React содержит около 15 [встроенных хуков](https://ru.reactjs.org/docs/hooks-reference.html).
Можно создавать собственные.

Хуки не работают в классовых компонентах, только в функциональных.

Название хука обычно начинается с `use`: `useState`, `useRef`, `useId`, `useИмяСамодельногоХука`...

Не вызывайте хуки из обычных JS-функций.<br>
Только одно исключение, откуда можно вызывать хуки — это ваши пользовательские хуки.

Хуки это функции => между ними можно передавать информацию.

Вызывайте хуки только на верхнем уровне. Не вызывайте внутри циклов, условий или вложенных функций.

Хуки удобно повторно использовать их в других компонентах.<br>
Позволяют повторно использовать логику состояния, а не само состояние (state).

**Изолированное состояние (state)**<br>
Каждое обращение к хуку обеспечивает совершенно изолированный state. Один хук можно использовать несколько раз в
компоненте.

В классовом компоненте (т.е. без хуков) я бы создал локальный state, записал в его свойство данные. Если мне нужно
хранить
что-то еще - надо это свойство менять, или добавить новое.<br>

Например:

- в классовом компоненте несколько счётчиков, Они пишут свои значения в локальный стэйт
- они либо затирают значения друг-друга,
- либо мы вводим под каждый счётчик отдельное значение в стэйте

Если же я использую хуки - я могу вызывать несколько раз один хук, и он будет по каждый вызов создавать разные
локальные стэйты, которые независимо хранят данные для каждого счётчика. Как-то так.

**Хранение данныз о хуках в React**

React запоминает вызовы функций, которые использовали хуки + запоминает вызовы этих хуков + хранит где-то у себя данные,
свзяанные с работой этих хуков (state и т.д.)

При этом, функция, как и прежде, «умирает» после того как вернула JSX (или нет?).<br>
В этом отличие от классовых компонент - там объект, созадный классовой компонентой, продолжал жить в памяти, его методы
и state находились в нём.

<br></p>
</details>

[//]: # (useEffect)
<details><summary>useEffect и useLayoutEffect </summary><p>

Хук `useEffect` и `useLayoutEffect ` совершать какие-то операции на разных стадиях жизни компонента
`useEffect` принимает в себя два аргумента:
- callback. Внутри него вся полезная нагрузка, которую мы хотим описать. Например, можно делать запросы на сервер,
задание обработчиков событий на документ или что-то ещё;
- массив, состоящий из аргументов. При изменении значения внутри любого из них будет запускаться наш callback. Именно
благодаря этому аргументу мы можем имитировать методы жизненного цикла.
**Ссылки**

- [Оф. документация - Хук useRef](https://ru.reactjs.org/docs/hooks-reference.html#useref)
- [Mentanit - Хук useRef](https://metanit.com/web/react/6.4.php)
- [Hexlet - Хук useRef ](https://ru.hexlet.io/courses/js-react-hooks/lessons/use-ref/theory_unit)
- [Умный способ использования хука useRef() в React](https://bookflow.ru/umnyj-sposob-ispolzovaniya-huka-useref-v-react/)

<br></p>
</details>

[//]: # (useRef)
<details><summary>useRef</summary><p>

Хук `useRef` позволяет сохранить некоторый объект, который можно изменять и который хранится в течение всей жизни
компонента.

useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (
initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

**Ссылки**

- [Оф. документация - Хук useRef](https://ru.reactjs.org/docs/hooks-reference.html#useref)
- [Mentanit - Хук useRef](https://metanit.com/web/react/6.4.php)
- [Hexlet - Хук useRef ](https://ru.hexlet.io/courses/js-react-hooks/lessons/use-ref/theory_unit)
- [Умный способ использования хука useRef() в React](https://bookflow.ru/umnyj-sposob-ispolzovaniya-huka-useref-v-react/)

<br></p>
</details>

[//]: # (Пользовательские хуки)
<details><summary>Пользовательские хуки</summary><p>

функция, имя которой начинается с «use», и которая может вызывать другие хуки.

**Ссылки**

- [Оф. документация](https://ru.reactjs.org/docs/hooks-custom.html)
- [Hexlet - React hooks](https://ru.hexlet.io/courses/js-react-hooks)

<br></p>
</details>

[//]: # (Пример хука состояния useState)
<details><summary>Пример хука состояния (useState)</summary><p>

  ```javascript
  import React, {useState} from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);

    return (
      <div>
        <p>Вы кликнули {count} раз(а)</p>
        <button onClick={() => setCount(count + 1)}>
          Нажми на меня
        </button>
      </div>
    );
  }
  ```

Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние.<br>
Поэтому мы пишем const [count, setCount] = useState().<br>
Это похоже на this.state.count и this.setState в классах, с той лишь разницей, что сейчас мы принимаем их сразу в
паре.<br>

В классовой компоненте это выглядело бы так:
  ```javascript
    class Example extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          count: 0
        };
      }

      render() {
        return (
          <div>
              <p>Вы кликнули {this.state.count} раз(а)</p>
              <button onClick={() => this.setState({count: this.state.count + 1})}>
                  Нажми на меня
              </button>
          </div>
        );
      }
}
  ```  

Чтоб прочитать state из хука мы используем переменную, которую ранее объявили<br>
Например:

```javascript
  <p>Вы кликнули {count} раз(а)</p>
```

В классовой компоненте это было бы так:

```javascript
  <p>Вы кликнули {this.state.count} раз(а)</p>
```

Чтобы обновить state:<br>

```javascript
  <button onClick={() => setCount(count + 1)}>
    Нажми на меня
</button>
```

В классовой компоненте это было бы так:

```javascript
    <button onClick={() => this.setState({count: this.state.count + 1})}>
    Нажми на меня
</button>
```

В отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет
слияние.

**Ссылки**

- https://ru.reactjs.org/docs/hooks-state.html

<br></p>
</details>

**Ссылки**
- [Habr - React Hooks простыми словами](https://habr.com/ru/company/simbirsoft/blog/652321)
- [Оф. документация](https://ru.reactjs.org/docs/hooks-intro.html)
- [Оф. документация - список хуков](https://ru.reactjs.org/docs/hooks-reference.html)
- [Дэн Абрамов - Полное руководство по useEffect (!)](https://habr.com/ru/company/ruvds/blog/445276/)
- [IT-Kamasutra #84 - hook, useState, хуки](https://youtu.be/EbqQg0K4wbo)
- [Habr - React Hooks простыми словами](https://habr.com/ru/company/simbirsoft/blog/652321/)
- [Matanit.com - Хуки. Управление функциональными компонентами](https://metanit.com/web/react/6.1.php)
- [WebDev - React видеокаст #2. Полное введение в хуки](https://youtu.be/X6j7Y7tp3_c)
- [WebDev - React видеокаст #3. Релиз хуков](https://youtu.be/19EmLE2mZ1Q)

<br></p>
</details>


[//]: # (JSX)
<details><summary><h3>JSX</h3></summary><p>

---

[//]: # (Что такое JSX?)
<details><summary>Что такое JSX?</summary><p>

JavaScript XML (JSX) - расширение синтаксиса JavaScript, "синтаксический сахар" для JS. Позволяет использовать похожий
на HTML синтаксис для описания структуры интерфейса.<br>
https://learn.javascript.ru/screencast/react#03-jsx<br>
При помощи Babel он компилируется в обычный JS. В JSX пишется и html-содержимое компонентов.<br>
Расширение .jsx использовать только для компонент. Не использовать для редьюсеров и т.д.т<br>
JSX - синтаксическое расширение JavaScript.<br> 
JSX производит React-элементы. <br>
Можно работать с React на обычном JS, без JSX. <br>
Babel компилирует JSX в вызовы React.createElement().<br>

  <br></p>
</details>

[//]: # (Зачем нужен JSX?)
<details><summary>Зачем нужен JSX?</summary><p>

React учитывает тот факт, что логика отрисовки связана с другой логикой пользовательского интерфейса: как обрабатываются события, как изменяется состояние со временем и как данные подготавливаются для отображения.

Вместо того чтобы искусственно отделять технологии, помещая разметку и логику в отдельные файлы, React разделяет задачи , используя слабо связанные единицы, называемыми «компонентами», которые содержат и разметку, и логику. 

<br></p>
</details>

[//]: # (В JSX нельзя вывести два html-элемента рядом)
<details><summary>В JSX нельзя вывести два html-элемента рядом, вот так:</summary><p> 
    
```
    function Test() {
      return (
        <h1>Title</h1>
        <p>Text</p>
        <div></div>
      )
    }
```  

Надо так:
```javascript
      function Test() {
        return (
          <div>
            <h1>Title</h1>
            <p>Text</p>
          </div>
        )
      }
```  

Или так:
```javascript
      function Test() {
        return [
          <h1 key = 'a'>Title</h1>,
          <p  key = 'b'>Text</p>
        ]
      }
``` 

Чтоб создать в JSX пустую корневую компоненту можно сделать так:
```javascript
      return <>
        <ComponentOne />
        <ComponentTwo />
      </>
```  
Иначе - только через массив с уникальными ключами
<br></p>
</details>

[//]: # (В JSX обязательно надо закрывать открытый тэг)
<details><summary>В JSX обязательно надо закрывать открытый тэг</summary><p>

Но, можно использовать такой синтаксис `<Article />`

<br></p>
</details>

[//]: # (Соглашение о наименовании кастомных компонент)
<details><summary>В JSX есть соглашение - все кастомные (т.е. мной созданные) компоненты называются с большой буквы .</summary><p>

Пример: Aricle, MyComponent...
Т.к. компонент = класс. 
И при выводе их внутри других компонентов - тоже (`<Aricle />`, `<MyComponent />`, ...)

<br></p>  
</details>

[//]: # (Обычный JS в JSX)
<details><summary>В JXS, если надо написать кусок на обычном JS, я помещаю его в фигурные скобки.</summary><p>

Например, создаю и вывожу переменную
```javascript
      function Test() {
        const text = <p>Text</p>
        return (
          <div>
            <h1>Title</h1>
            {text}
          </div>
        )
      }
```
Лучше не злоупотреблять выводом внутри JSX фигурных скобок с JS - тяжело разбираться. 
Если нужны большие объёмы - выноси в переменные (см выше)

<br></p>
</details>

[//]: # (Аттрибуты)
<details><summary>В JXS аттрибуты html пишут так:</summary><p>

```javascript
    function Test() {
      return (
        <div className="test" style={{color: 'red'}}>
          <h1>Title</h1>
        </div>
      );
    }
```

<br></p>
</details>

[//]: # (Внутри JSX можно использовать только выражения)
<details><summary>Внутри JSX можно использовать только выражения</summary><p>

Внутри JSX можно использовать только выражения. Так, например, вы не можете использовать оператор if, но можете использовать тернарное выражение.

Переменные JavaScript также являются выражениями

Объекты JavaScript также являются выражениями.

Вы можете использовать элемент React внутри JSX, потому что это тоже выражение

Вы также можете использовать все функциональные методы JavaScript для коллекций (map, reduce, filter, concat и т. д.) внутри JSX. Опять же, потому что они возвращают выражения

<br></p>
</details>

[//]: # (JSX предотвращает атаки)
<details><summary>JSX предотвращает атаки, основанные на инъекции кода.</summary><p>

https://ru.reactjs.org/docs/introducing-jsx.html
Данные, введённые пользователем, можно безопасно использовать в JSX. 
По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. 
Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
Всё преобразуется в строчки, перед тем как быть отрендеренным. 
Это помогает предотвращать атаки межсайтовым скриптингом (XSS).

<br></p>
</details>

[//]: # (Все атрибуты элементов React именуются с помощью camelCase)
<details><summary>Все атрибуты элементов React именуются с помощью camelCase.</summary><p>

CSS-class записываем как className
tabindex = tabIndex

<br></p>
</details>

[//]: # (Внутри JSX разметки можно использовать только готовые выражения)
<details><summary>Внутри JSX разметки можно использовать только готовые выражения.</summary><p>

Нельзя, например, использовать конструкцию if/else (точно?)
но можно заменить ее тернарным оператором.

<br></p>
</details>

<br></p>
</details>

[//]: # (CSS)
<details><summary><h3>CSS</h3></summary><p>

---
[//]: # (Структура проекта)
<details><summary><b>Структура проекта</b></summary><p>

- Если нужно добавить для компонента CSS - создаю для этого компонента отдельную папку (название = названию компонента),
  в ней файл компонента (index.js) и style.css
- Есть ещё различные варианты CSS-in-JS - когда CSS хранится и генерируется прямо в JS-коде. Подходы интересные, но со
  совимим минусами. См Styled component.

  <br><p>

</details>

[//]: # (Библиотеки для работы с ClassNames: Classnames, CLSX)
<details><summary><b>Библиотеки для работы с ClassNames: Classnames, CLSX</b></summary><p>

Позволяют более простым способом объединять разные classes в зависимости от различных условий.<br>
Предположим, у вас есть 2 класса, из которых один будет использоваться каждый раз, а второй будет использоваться в
зависимости от некоторого условия.

Есть две самых популярных библиотеки для работы ClassNames:

- [classnames](https://www.npmjs.com/package/classnames)
- [clsx](https://www.npmjs.com/package/clsx)

Classnames немного популярнее, и более функциональна (читай документацию)<br>
CLSX полегче и побыстрее (потому что функциональность меньше)

Ссылки:
- [classnames](https://www.npmjs.com/package/classnames)
- [clsx](https://www.npmjs.com/package/clsx)
- [npmtrends](https://npmtrends.com/classnames-vs-clsx)
- [https://habr.com/ru/post/649381/](https://habr.com/ru/post/649381/)
- [Арек Нао - Вы не знаете библиотеку classnames](https://areknawo.com/you-dont-know-the-classnames-library)
- [Hexlet - Упрощённое использование библиотеки classnames](https://ru.hexlet.io/blog/posts/uproschyonnoe-ispolzovanie-biblioteki-classnames)

<br></p>
</details>

[//]: # (Adaptive/Responsive. Способы различения десктопа / мобильного)
<details><summary><b>Adaptive/Responsive. Способы различения десктопа / мобильного</b></summary><p>

`Адаптивный (Adaptive)` — комплекс визуальных интерфейсов, созданных под конкретные размеры экрана.<br>
`Отзывчивый (Responsive)` — единый интерфейс, который подстраивается под любой размер экрана.

Два основных подхода к реализации:

- по ширине экрана. Определяем ширину скриптом (например `window.innerWidth`), храним в `state`, сравниваем с
  константами-breakpoints, по результатам выводим нужный компонент или меняем класс)
- по user-agent

Для обоих есть модули и библиотеки.

Лучше всего использовать оба.<br>
Подход с user-agent проще, но использовать только его недостаточно. Любой, кто серьезно разрабатывал адаптивные
интерфейсы, знает про «магический поворот» iPad-ов и подобных ему девайсов, которые в вертикальном положении попадают
под определение мобильных, а в горизонтальном — десктопных, но при этом имеют user-agent мобильного устройства. Также
стоит отметить, что в рамках полностью адаптивно/отзывчивого приложения по одной лишь информации о user-agent невозможно
определить мобильность, если пользователь использует, например, десктопный браузер, но сжал окно до
«мобильного»размера.<br>
Также не стоит пренебрегать информацией о user-agent. Очень часто в коде можно встретить такие константы, как isSafari,
isIE и т.д., которые обрабатывают «особенности» этих устройств и браузеров. Лучше всего комбинировать оба подхода.

**ВАЖНО**: при использовании системы типа [Google material UI](https://mui.com/material-ui/) - используй её встроенные
возможности. Там есть `родные` методы реализации адаптивности/отзывчивости.

**Общие соображения**
- надо отслеживать мобильность и на уровне CSS (менять вёрстку) и на уровне компонент (в одних случаях выводим
  мобильные, в других десктопные, или просто изменять их).
- желательно и там и там использовать какой-то единый метод, иначе может получиться что в CSS (media-query)
  определилиась одна ширина, а в компоненте (по ширине дисплея) - другая
- при этом, из компоненты я могу добавить класс Desktop, а вот из CSS передать в компонент информацию сложно
- откуда вывод: лучше работать «от комопненты» — определять мобильность там, прописывать в глобальный стэйт, и там где
  нужен специальный css — выводить доп. класс (на основании этого знаения в state)

**Библиотеки**
- [react-use (979 199) - отслеживает кучу всего, в том числе MediaQuery и WindowSize](https://www.npmjs.com/package/react-use)
- [react-device-detect (530 267) - работает с user agent](https://www.npmjs.com/package/react-device-detect)
- [react-responsive (511 397) - работает с шириной экрана](https://www.npmjs.com/package/react-responsive)
- [mobile-detect (164 455) - работает с user agent](https://www.npmjs.com/package/mobile-detect)
- [react-media (112 694) - работает с шириной экрана](https://www.npmjs.com/package/react-media)
- [react-socks (4 401) - HOC](https://www.npmjs.com/package/react-socks)

**Ссылки**
- [Keohan J - 3 Ways To Implement Responsive Design In Your React App (2019)](https://itnext.io/3-ways-to-implement-responsive-design-in-your-react-app-bcb6ee7eb424)
- [Habr - Адаптивный или отзывчивый? Разбираем структуру React-компонентов (2020)](https://habr.com/ru/company/youla/blog/493292/)
- [Адаптивные веб-страницы с помощью React-Response и TypeScript (2022)](https://webformyself.com/adaptivnye-veb-stranicy-s-pomoshhyu-react-response-i-typescript/)
- [Build Responsive Web Pages With React-responsive and TypeScript (2021)](https://blog.openreplay.com/build-responsive-web-pages-with-react-responsive-and-typescript)

<br></p>
</details>

[//]: # (Сss-modules)
<details><summary><b>Сss-modules</b></summary><p> 

- CSS модуль — это CSS файл, в котором все имена классов и анимаций имеют локальную область видимости по умолчанию.
- Такой метод подключения CSS, при можно использовать одинаковые имена css-классов в разных компонентах, и конфликта не
  будет. Что-то типа автоматизированного BEM. При это css по-прежнему хранятся в отдельном файле и пишутся практически
  как обычно

  **Ссылки**
- [habr - Практическое руководство по использованию CSS Modules в React приложениях](https://habr.com/ru/post/335244/)
- [habr - Эволюция CSS: от CSS, SASS, BEM и CSS–модулей до styled-components](https://habr.com/ru/company/mailru/blog/319956/)
- [You-Tube - IT-Kamasutra 14. Уроки React JS (css-модули, css-modules)](https://youtu.be/bQ3UPYFHyJ0)

  <br></p>

<br></p>
</details>

[//]: # (Styled components todo: дополнить)
<details><summary><b>Styled components</b></summary><p>


Библиотека для работы со стилями методом `CSS in JS` (описание стилей в JavaScript файлах).

Аналоги:

- [Emotion](https://emotion.sh/docs/introduction)

Среди причин выбора CSS-in-JS можно назвать то, что эта технология позволяет ограничивать область видимости стилей и
отказаться от глобальной стилизации. Её удобно применять для работы с темами приложений.

В старой версии приложения я использовал библиотеку styled-components. Чем это плохо? Дело в том, что обычный CSS
быстрее и занимает меньше места. Современные браузеры умеют загружать CSS-код параллельно с JavaScript-бандлом. Кроме
того, для использования обычного CSS не нужно дополнительной библиотеки. Минифицированный вариант styled-components
занимает порядка 54 Кб. Использование обычного CSS вместо styled-components привело к тому, что код приложения быстрее
загружается, и к тому, что при изменении стилей системе приходится выполнять меньше вычислений

**Ссылки**
- [Официальный сайт проекта (en)](https://www.styled-components.com)
- [YouTube - Артём Арутюнян с докладом о библиотеке styled-components](https://www.youtube.com/watch?v=eOBz3_mQwo8)
- [Habr - Styled Components — идеальная стилизация React-приложения (2021)](https://habr.com/ru/post/591381/)
- [habr - Знакомство с Styled components](https://habr.com/ru/company/digital-ecosystems/blog/321804/)
- [habr - Эволюция CSS: от CSS, SASS, BEM и CSS–модулей до styled-components](https://habr.com/ru/company/mailru/blog/319956/)
- [habr - CSS-in-JS — мифы и реальность (на примере styled-components)](https://habr.com/ru/post/417707/)
- [habr - Анонс новой версии Styled Components v5](https://m.habr.com/ru/post/456422/)
- [habr - История четырёхкратного ускорения React-приложения](https://habr.com/ru/company/ruvds/blog/455505/)
- [Medium - Styled-components getting started (en)](https://medium.com/styled-components/styled-components-getting-started-c9818acbcbbd)
- [Medium - How to use styled components with Material UI in a React app (en)](https://medium.com/sipios/use-styled-components-with-material-ui-react-e0759f9a15ce)
- [Как использовать стилизованные компоненты в React](https://webformyself.com/kak-ispolzovat-stilizovannye-komponenty-v-react/)
- [Знакомство с библиотекой Styled Components в React](https://medium.com/nuances-of-programming/%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE-%D1%81-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%BE%D0%B9-styled-components-%D0%B2-react-8bc58cd9d07d)

<br></p>
</details>

[//]: # (React + Bootstrap)
<details><summary><b>React + Bootstrap</b></summary><p>

C Bootstrap в React можно работать как в чистом виде, так и при помощи специальных react-библиотек, которые интегрируют
Bootstrap в React.

<br></p>
</details>

[//]: # (React +  Google Material UI)
<details><summary><b>React + Google Material UI</b></summary><p>

[Material Design](https://mui.com) — фрэймворк/дизайн-система, создана Google дл быстрой разработки интрефейсов.

Есть различные js-библиотеки, которые интегрируют Material Design в React.<br>
Я использую официальную библиотеку Google - [Material UI](https://mui.com/material-ui/getting-started/overview)

Material UI использует «под капотом» библиотеку для работы со стилями — [Emotion](https://emotion.sh/docs/introduction)
либо [Styled-components](https://styled-components.com/).<br>
Какую из этих двух библиотек использовать — выбирается
при [установке npm-пакета](https://mui.com/material-ui/getting-started/installation/).

Краткий алгоритм установки/настройки

- ставим Material Ui и зависимости
  - сам Material Ui `yarn add @mui/material @mui/styled-engine-sc styled-components`
  - шрифт Roboto `yarn add @fontsource/roboto` или подключить из
    CDN (https://mui.com/material-ui/react-typography/#general)
  - SVG-иконки `yarn add @mui/icons-material`
- ставим пакеты типизации (кажется не нужно, всё работает из коробки)
- опционально: настраиваем IDE (подсветка Styled-components/Emotion и т.д.)
  - Настройки: File | Settings | Plugins
  - [Styled Components & Styled JSX](https://plugins.jetbrains.com/plugin/9997-styled-components--styled-jsx)
  - https://www.jetbrains.com/help/phpstorm/react.html
- настраиваю провайдер `theme` — объект с базовыми настройками дефолтных стилей, прокидывается по дереву проекта (или
  его части) на подобии `context`
  - https://mui.com/material-ui/customization/theming/
  - Создаю файл с темой, например muiTheme.ts
     ```js
        import { red } from '@mui/material/colors';
        import { createTheme } from '@mui/material/styles';
  
        export const theme = createTheme({
          palette: {
            primary: {
              main: red[500],
            },
          },
        });
     ```
  - оборачиваю компонент верхнего уровня в `ThemeProvider` и прокидываю в него `theme`
    ```jsx
      import React from 'react';
      import App from './components/App';
      import { ThemeProvider } from '@mui/material/styles';
      import { theme } from './config/muiTheme';
  
      root.render(
        <ThemeProvider theme = {theme}>
          <App />
        </ThemeProvider>
      );
    ```
- задаю базовую разметку страницы
  ```
    <Box>
      <Container>
        < >
      </Container>
    </Box>
  ```
- подключаю готовые стилизованные компоненты (кнопки, меню и т.д.)
- если надо - настраиваю и стилизую их

**Ссылки**

- [Оф. сайт](https://mui.com)
- [Руководство - русский перевод (Notion, 2021)](https://www.notion.so/rsgd/Material-Design-2-afad31afd1bd48ed933005bc02f4527f)
- [Руководство - русский перевод (Medium, 2021)](https://medium.com/@ruslanshgd)
- [Habr - Reactjs, Material-UI with JSS. Краткий гайд (2020, устарело)](https://habr.com/ru/post/492378/)
- [Полное руководство по React JS material-ui (2018)](https://webformyself.com/polnoe-rukovodstvo-po-react-js-material-ui/)

<br></p>
</details>

[//]: # (Заметки)
<details><summary><b>Заметки</b></summary><p>

- Если не используешь CSS-modules - CSS лучше писать по [BEM-методологии](https://ru.bem.info/methodology/)
- Про [CSS-переменные](https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties)

  <br></p>

</details>

<br></p>
</details>

[//]: # (Роутинг)
<details><summary><h3>Роутинг</h3></summary><p>

---

[//]: # (Что такое React-Router)
<details><summary>Что такое React-Router?</summary><p>

React-Router - набор компонентов определяющих на основе текущего пути, какой компонент будет выводиться.

- react-router - пакет с базовым набором функций
- router-dom - пакет с набором функций для работы в браузере

<br></p>
</details>

[//]: # (React-router-dom)
<details><summary>**React-router-dom**</summary><p>

- Модуль npm + специальная разметка в корневом компоненте
- Переключение компонентов на странице, в зависимости от адреса в адресной строке.

**Ссылки**

- [IT-Kamasutra #19 - React-router-dom](https://youtu.be/5X5ZLWdAnt4)
- [IT-Kamasutra #22 - Route-exact](https://youtu.be/HfGD5xRIiMU) — настройка роута для страниц 2 уровня - переключаем
  адрес в адресной строке,

  <br></p>

</details>

[//]: # (BrowserRouter и HashRouter)
<details><summary>BrowserRouter и HashRouter</summary><p>

Для браузерных проектов есть BrowserRouter и HashRouter компоненты.

- BrowserRouter — следует использовать когда вы обрабатываете на сервере динамические запросы. Если проект предполагает
  бекенд - бери BrowserRouter.
- HashRouter - когда у вас статический веб сайт.

Обычно предпочтительнее использовать BrowserRouter, но если ваш сайт расположен на статическом сервере(как github pages)
, то использовать HashRouter это хорошее решение проблемы.

<br></p>
</details>

[//]: # (Компонент Route)
<details><summary>Компонент Route</summary><p>

`<Route/>` - компонент, строительный блок React Router'а.
Если вам нужно рендерить элемент в зависимости от pathname URL'ов, то следует использовать компонент `<Route/>`

<br></p>
</details>

[//]: # (Как связаны Route и NavLink?)
<details><summary>Как связаны Route и NavLink?</summary><p>

Route и NavLink = два независимых элемента.

Фактически, это обычные компоненты, написанные разработчиками, и подключаемые из билиотеки. В них передаются параметры и
функции. ПРи наступлении условия X сделай то-=то (например, отрисуй компоненту такую-то)

- Route - меняет содержимое страницы, в зависимости от того, что введено в адресной строке. Следит за ней, и при
  изменениии - отрабатывает
- NavLink - при клике меняет адрес в адресной строке

<br></p>
</details>

**Ссылки**

- http://bogdanov-blog.ru/react-router-v4-notes/
- https://habrahabr.ru/post/329996/

<br></p>
</details>

[//]: # (Ducks. todo: осмыслять)
<details><summary><h3>Ducks</h3></summary><p>

**Ссылки**

- [Habr - Масштабирование Redux-приложения с помощью ducks (2020)](https://habr.com/ru/company/otus/blog/492638/?ysclid=l6sz05stk7523793176)
- [Habr - Как организовать большое React-приложение и сделать его масштабируемым (2017)](https://habr.com/ru/company/nix/blog/329060/)

<br></p>
</details>

[//]: # (Статическая типизация)
<details><summary><h3>Статическая типизация</h3></summary><p>

---
[//]: # (Про статическую типизацию)
<details><summary><b>Про статическую типизацию</b></summary><p>

При статической типизации мне необязательно напоминать компилятору, что данная переменная, например, целое число, и
всегда должно им оставаться. Эта информация хранится в программе, и даже если я, забывшись, попытаюсь изменить ее
значение на недопустимое, ничего страшного не произойдет.

Статическая типизация: Проверка типов на стадии компиляции, перед запуском программы. C, C++, C#, Java, Pascal...

Динамическая типизация: Проверка типов когда программа уже запущена. Perl, Ruby, JavaScript, Lisp, PHP, Python...

Статические языки производительнее.

Статические языки - с помощью тестирования типов легко проверить работоспособность кода еще до его выполнения.

Эффективность. Статическая типизация требует от программиста большей ответственности. Динамические языки, в свою
очередь, могут поощрять некоторую раскованность, вырабатывая у разработчика привычку следовать дурным паттернам.

В каждом случае если вы хотите использовать типы, то явно говорите инструменту, в каких файлах осуществлять проверку
типов.</summary>

- В случае TypeScript вы делаете, создавая файлы с расширением .ts вместо .js.
- В случае Flow вы указываете в начале кода комментарий @flow.

- Динамический пример на JS
  var name = "Susan",
  age = 25,
  hasCode = true;

- Статический пример на TypeScript
  let name: string = "Susan",
  age: number = 25,
  hasCode: boolean = true;

**Ссылки**

- [Оф. документация - Статическая типизация](https://ru.reactjs.org/docs/static-type-checking.html)
- [Hexlet - Введение в программирование. Типизация](https://ru.hexlet.io/courses/introduction_to_programming/lessons/types/theory_unit)
- [Wat by Gary Bernhardt (юмористическое видео про неявную типизацию)](https://www.destroyallsoftware.com/talks/wat)

<br></p>
</details>

[//]: # (Type Script)
<details><summary><b>Type Script</b> - язык (Microsoft)</summary><p>

Язык разработанный Microsoft. Совместим с JS (расширяет его). Добавляет возможности статической типизации и ООП.<br>

Представляет собой надмножество, которое компилируется в JavaScript — хотя по ощущениям TypeScript похож на новый язык
со статической типизацией сам по себе. То есть очень похож на JavaScript и не сложен в освоении.

Есть аналогичное решение от Facebook - Flow.

В Angular разработка ведётся на TypScript

Динамический пример на JS

  ```javascript
        var name = "Susan",
    age = 25,
    hasCode = true;
  ```

Статический пример на TypeScript

  ```typescript
        let name: string = "Susan",
    age: number = 25,
    hasCode: boolean = true;
   ```

Надо явно сообщить React, в каких файлах осуществлять проверку типов - создаём файлы с расширением .ts вместо .js. **
Уточнить:** кажется, это вообще отдельные от кода файлы с описанием типов.

**Ссылки**

- [habr - Использование Typescript с React – руководство для новичков](https://habr.com/ru/company/otus/blog/456124/)

<br></p>
</details>

[//]: # (Flow)
<details><summary><b>Flow</b> - библиотека (Facebook)</summary><p>

Open source библиотека для статической проверки типов.<br>
Библиотеку разработала и выпустила Facebook.<br>
Позволяет постепенно добавлять типы в ваш код JavaScript.<br>
Flow представляет собой инструмент статического анализа. Использует надмножество языка, позволяя добавлять аннотации
типов ко всему вашему коду и улавливать весь класс ошибок во время компиляции.<br>
Надо явно сообщить React, в каких файлах осуществлять проверку типов - указывать в начале кода комментарий @flow.

<br></p>
</details>

[//]: # (PropTypes)
<details><summary><b>PropTypes</b> - библиотека React</summary><p>

Очень простой - проверяет только props.

- изначально был в составе React, потом вынесли в отдельную библиотеку
- функциональность намного меньше и проще, чем у TS/Flow
- проверяет только props
- выдаёт предупреждения об ошибках типов во время запуска

PropTypes может давать вам предупреждения во время выполнения, что может быть полезно для быстрого поиска неверных
ответов, поступающих с сервера, и т.

В существующих приложениях с большими объектами, это быстро приведет к большому количеству кода. Это проблема, так как в
Реакте часто нужно передавать один и тот же объект множеству компонентов. Повторение этого процесса во множестве
компонентов нарушает принцип DRY (Don’t Repeat Yourself). Самоповторы приводят к проблемам с поддержкой.

Проблема с использованием PropTypes вместе с Flow заключается в том, что вы пишете много дубликатов кода. Оба
определения в основном содержат ту же информацию, и когда тип данных изменяется, необходимо обновить оба определения.

- propTypes - специальное свойство класса компонента (так было раньше?). Задают типы входных параметров для
  отрисовываемого компонента.

В случае несовпадения (например вместо числа пришла строка) позволяют получить ошибку в react-dev-tools и отловить этот
момент во время выполнения.

Это была встроенная возможность контроля типов для больших приложений, но с недавнего времени вынесена в отдельный
пакет.

Для некоторых приложений, вы можете использовать расширения JavaScript такие как Flow или TypeScript осуществляя
проверку типов всего вашего приложения. Но если вы не используете таковые — React предоставляет некоторые встроенные
возможности проверки типов.

Пример:

  ```javascript
  class Greeting extends React.Component {
    render() {
        return (
            <h1>Hello, {this.props.name}</h1>
        );
    }
}

Greeting.propTypes = {
    name: React.PropTypes.string
};
  ```

В целях производительности, propTypes проверяются только в режиме разработки (development). Т.е. сам код остаётся, но не
проверяется. Для удаления кода есть спец. модуль

PropTypes и defaultProps это статичные свойства. Объявлять их надо как можно выше в коде (позже вам скажут спасибо
многие разработчики).

**Ссылки:**
-[habr](https://habr.com/ru/post/319358/)
-[habr](https://habr.com/ru/post/326304)

<br></p>
</details>

[//]: # (Различия PropTypes и Flow)
<details><summary><b>Различия PropTypes и Flow</b></summary><p>

Flow - почти язык

PropTypes - едва ли библиотека

Кроме того, что и PropTypes и Flow относятся к очень широкому полю проверки типов, между ними нет особого сходства.

Flow представляет собой инструмент статического анализа, который использует надмножество языка, позволяя добавлять
аннотации типов к ко всему вашему коду и улавливать весь класс ошибок во время компиляции.

PropTypes - это базовая проверяльщик типов, который был частью React. Он не может проверять ничего, кроме типов props,
передаваемого данному компоненту.

Если вам нужен более гибкий метод проверки типов для всего проекта, то Flow/TypeScript являются подходящими.

Пока вы передаете только аннотированные типы в компоненты, вам не понадобятся PropTypes.

Если вы просто хотите проверить типы props, не делайте излишнюю усложнение остальной части своей кодовой базы и идите с
более простой опцией.

- Flow - инструмент статического анализа
- PropTypes - инструмент проверки во время запуска. Теоретически может отловить ошибки, которые могут быть пропущены
  Flow

<br></p>
</details>

**Ссылки:**

- https://ru.reactjs.org/docs/static-type-checking.html

<br></p>
</details>

[//]: # (Тестирование React-component)
<details><summary><h3>Тестирование React-component</h3></summary><p>

Есть `unit-тестирование`(проверка работы отдельных модулей самих по себе) и `e2e тестирование` (проверка всей системы
целиком).<br>
В первую очередь, все говорят про unit-тесты

**Что тестировать**

- значения приходящие в компонент через `props` должно быть доступно ей изнутри, например в её стэйте
- при рендере компонента в ней есть нужные html-тэги. Например, у компонента есть два режима - «Edit mode» и «Normal»,
  переключатся по пропсам или стэйту. В одном случае выводится <span>, в другом <button>. Проверяем, есть ли в
  разметке <span> при таком-то выводе
- в пропсах закинули статус, он должен отобразиться в <span>. Проверяем что в <span> придёт именно этот текст.
- кнопки нажимаются
- проверить работу Callback - что он вызывается и делает что надо....
- имитировать клики, хэндеры, разные пропсы... - что произойдёт

**Популярные технологии**

- [Jest](https://facebook.github.io/jest/) - delightful JavaScript testing used by Facebook to test all JavaScript code
  including React applications. Разрабатывается Facebook
- [Enzyme](https://github.com/airbnb/enzyme/) - a JavaScript Testing utility for React that makes it easier to assert,
  manipulate, and traverse your React Components’ output.
- [Mocha](https://mochajs.org/)

**На оф. сайте также упоминаются**

- [react-testing-library](https://github.com/kentcdodds/react-testing-library) - Simple and complete React DOM testing
  utilities that encourage good testing practices.
- [React-unit](https://github.com/pzavolinsky/react-unit) - a lightweight unit test library for ReactJS with very few (
  js-only) dependencies.
- [Skin-deep](https://github.com/glenjamin/skin-deep) - Testing helpers for use with React’s shallowRender test utils.
- [Unexpected-react](https://github.com/bruderstein/unexpected-react/) - Plugin for the unexpected assertion library
  that makes it easy to assert over your React Components and trigger events.

**Ссылки**

- [Википедия - модульное тестирование](https://ru.m.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
- [Оф. документация - инструменты тестирования (en)](https://ru.reactjs.org/community/testing.html)
- [habr - Тестирование React-Redux приложения (Jest)](https://habr.com/ru/post/340514/)
- [Тестирование компонентов в React с использованием Jest: основы](https://code.tutsplus.com/ru/articles/testing-components-in-react-using-jest-the-basics--cms-28934)
- [Habr - React: тестируем компоненты с помощью Jest и Testing Library (2022)](https://habr.com/ru/company/timeweb/blog/670480/)
- [Hexlet - Тестирование JSReact (платный доступ)](https://ru.hexlet.io/courses/js-react/lessons/tests/theory_unit)
- [Пацианский М - Тестирование React компонентов с помощью jest и enzyme](https://maxpfrontend.ru/vebinary/testirovanie-komponentov-s-pomoschyu-jest-enzyme/)
- [Medium - Модульное тестирование React-приложения с помощью Jest и Enzyme](https://medium.com/devschacht/berry-de-witte-unit-testing-your-react-application-with-jest-and-enzyme-6ef3658fdc93)
- [Medium - Что и как тестировать с помощью Jest и Enzyme. Полная инструкция по тестированию React-компонентов](https://medium.com/devschacht/what-and-how-to-test-with-jest-and-enzyme-full-instruction-on-react-components-testing-d3504f3fbc54)
- [learn.javascript.ru - Автоматические тесты при помощи chai и mocha](https://learn.javascript.ru/testing)
- [Знакомство с разработкой через тестирование в JavaScript (Mocha)](https://tproger.ru/translations/unit-testing-in-javascript/)
- [IT-Kamasutra #92 - тестируем компоненты, тесты, react-test-renderer - React JS](https://youtu.be/Kyc_Z_2b2Hc)

<br></p>
</details>

[//]: # (Lazy и Suspense)
<details><summary><h3>Lazy и Suspense</h3></summary><p>

«Ленивые» (lazy) компоненты - их смысл заключается в разделении приложения на небольшие фрагменты кода. Загрузка этих
фрагментов выполняется только тогда, когда они нужны.

Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: `import()`. Когда
Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения.

Функция `React.lazy` позволяет рендерить динамический импорт как обычный компонент. React.lazy принимает функцию,
которая должна вызвать динамический import(). Результатом возвращённого Promise является модуль, который экспортирует по
умолчанию React-компонент (export default).

Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет нам показать запасное
содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.

**Ссылки**

- [Оф. докуменатция - Разделение кода](https://ru.reactjs.org/docs/code-splitting.html)
- [Mentanit - Хуки в React](https://metanit.com/web/react/6.1.php)
- [Habr = Уменьшение размеров бандлов с помощью Webpack Analyzer и React Lazy/Suspense](https://habr.com/ru/company/ruvds/blog/468225/)

<br></p>
</details>

[//]: # (Рендер: на клиенте, на сервере, прогрессивный. Гидратация)
<details ><summary><h3>Рендер: на клиенте, на сервере, прогрессивный. Гидратация</h3></summary><p>

**Рендер, отрисовка**

`Рендер` — отрисовка кода веб-документа в интерактивную веб-страницу, которую пользователь видит в браузере.<br>
Процесс выполнения всех правил, прописанных в HTML-коде, JS-скриптах и CSS-стилях.

Одна из самых долгих и «дорогих» (по времени) операций в работе сайта. Чем она быстрее — тем лучше.<br>
Задержка в отрисовке страницы на 1 сек, снижает конверсию на 7%.<br>
Т.е. чем дольше грузится страница тем больше людей уйдёт не дождавшись.

**3 основных подхода**:

- `Рендеринг на клиенте` (Client Side Render, CSR) — браузер скачивает почти пустой HTML, потом выкачивает большой JS (
  возможно разбыиты на «бандлы»), только потом страница отображается. <br>
  - Пока качается JS - отображается только малая часть страницы или прелоадер. Информации на странице почти нет и
    взаимодействовать с ней нельзя.
  - [YouTube — Animated Client Side Rendering (Fruits)](https://www.youtube.com/watch?v=4-Lel1oaV7M)
- `Рендеринг на сервере` (Server Side Render, SSR) — весь HTML готовится на сервере. Браузер скачивает этот HTML и
  показывает пользователю. Потом докачивает скрипты. <br>
  - Пока пользователь разглядывает это HTML - скачиваются скрипты + дополнительный (не критичный HTML). Когда
    подгурзятся и подключатся JS-скрипты — страница становится интерактивной.
  - Первая отрисовка страницы заметно быстрее чем в SSR — пользователь сразу видит какой-то осмысленный контент, хоть и
    без интерактивности.
  - [YouTube — Animated Server Side Rendering (Fruits)](https://www.youtube.com/watch?v=0bvo6UKkNDA)
- `Прогрессивный рендеринг` на стороне сервера (Progressive Server Side Render) — мин. необходимый HTML готовится на
  сервере. Браузер скачивает этот HTML и показывает пользователю. Потом подгружаются скрипты и остальной HTML.<br>
  - Также называется `прогрессивная гидратация`
  - Основан на концепции потоковой передачи HTML.
  - Страницы делятся на осмысленные части-компонента, эти части подгружаются отдельно. Рендер компонента не происходит,
    пока он не появится в поле зрения (scroll) или не понадобится для взаимодействия с пользователем.
  - Быстрее `CSR` и `SSR`. Особенно медленном соединении
  - Чтоб ещё ускорить — применяют оптимизацию критических этапов рендеринга.

**Гидратация. Регидратация**

`Гидратация` или `регидратация` (hydration / re-hydration) — процесс, когда JS преобразует статический HTML в
динамическую веб-страницу (присоединяет обработчики событий к элементам HTML). Происходит в браузере после получения
HTMl с сервера.

Когда мы используем CSR/PSSR мы получаем с сервера HTML с контентом, и отображаем его пользователю.<br>
В это время JS работает над созданием полноценного клиентского приложения (Virtual DOM и binding интерфейса управления
им). Здесь не надо заново рендерить весь DOM на клиенте, но необходимо добавить недостающие события, методы, а иногда и
элементы, которые не рендерились на сервере.<br>
Этот процесс называется `гидратацией` или `регидратацией`.

**React hydrate() / hydrateRoot()**

`hydrate()` — отдельный метод для рендеринга на клиентской стороне.<br>
Используется когда рендеринг на клиенте основан на результатах серверного рендеринга.<br>
Ввели в 16 версии React (2017)

`hydrateRoot()` — заменил метод `hydrate()`, начиная с React 18 (2022).

**Ссылки**

- [Habr - Прогрессивный рендеринг для лучшей производительности веб-приложений](https://habr.com/ru/company/skillfactory/blog/540294/)
- [Habr - Что, черт возьми, такое гидратация и регидратация?](https://habr.com/ru/post/515100/)
- [Серверный или клиентский рендеринг на вебе: что лучше использовать у себя в проекте и почему](https://tproger.ru/translations/rendering-on-the-web/)
- [Как интегрировать серверный рендеринг в React-приложение, и зачем он вообще там нужен](https://highload.today/kak-integrirovat-servernyj-rendering-v-react-prilozhenie-i-zachem-on-voobshhe-tam-nuzhen/)
- [Прогрессивный рендеринг для повышения производительности веб-приложений](https://webformyself.com/progressivnyj-rendering-dlya-povysheniya-proizvoditelnosti-veb-prilozhenij/)
- [Wikipedia - Hydration (web development)](https://en.wikipedia.org/wiki/Hydration_(web_development))
- [Оф. документация — метод `hydrate()`](https://ru.reactjs.org/docs/react-dom.html#hydrate)

<br></p>
</details>

[//]: # (Быстродействие и оптимизация React. todo: осмыслять)
<details><summary><h3>Быстродействие и оптимизация React</h3></summary><p>

**Изменение параметров функции, side-эффекты и cloneDeep**<br>
Никогда, никогда, никогда в жизни не делайте так!
Изменения параметров функции это зашквар если честно - это сразу +50% к появлению сайд эффектов.
Изменять параметры функции можно только в одном случае, если у вас рекурсия и вы изменяете объект.

Хотите такой же объект, делайте копию.
Есть крутая штука, cloneDeep у lodash
Пользуйтесь ей - это сразу избавил вас от неожиданных последствий

Оптимизацию react приложений, я заставляю изучать всех, с кем в проектах участвую. Это сейчас «must have»

**Side-эффекты в методах жизненного цикла**<br>
В `ComponentDidMount` мы имеем право сделать сайд-эффект
Сайд-эффектами являются запросы на сервер, асинхронные операции, setTimeout, обращения к DOM-элементам напрямую
В результате компонента будет перерисована, и будет вызван уже не ComponentDidMount, а ComponentDidUpdate

В `ComponentDidUpdate` мы имеем право сделать сайд-эффект, но уже с неким условием, которое позволить его в какой-то
момент прекратить.<br>
Потому что в результате будет вызвана перерисовка компоненты, снова вызван ComponentDidUpdate... И если нет условия -
получим цикл, и приложение зависнет

**Props и производительность**

Основная опасность - увеличение количества render, которые мешают производительности

Важно: при вызове render() перерисовывается не только родительский компонент, но и все дочерние (хотя, в них свойства
могли и не поменяться). Т.е. если у родительского компонента внутри render есть дочерние компоненты - они будут
перерисовываться. Соответственно, если мы вызываем render на родительском компоненте - перерисуем всё приложение. Чтоб
решить этот вопрос - используем создание компонента от PureComponent

Даже если я создал класс от PureComponent - это не гарантирует отсутствие лишних ренедров при тех же данных. Одна из
причин - анонимные функции (они при каждом рендере новые).
Неверно:

  ```
  render() {
    return <Component onClick= {() => this.hangleClick}>
  }
  ```

Верно:

  ```
  handleClick = () => {...}
  render() {
    return <Component onClick= {this.hangleClick}>
  }
  ```

То же самое с объектами - не создаём их прямо в функции, а подключаем как константу<br>
Неверно:

  ```
    render(){
      return <Component test= {{a: 1}}>
    };
  ```

Верно:

  ```
    const obj = {a:1}
    render() {
      return <Component test= {obj}>
    }
  ```

**Ссылки**
- [YouTube - Какие props портят производительность](https://www.youtube.com/watch?v=zSDOxWhPG_U)

---

**Ссылки**

- [Гайд по оптимизации веб- приложений в 2017](https://medium.com/@abraztsov/%D0%B3%D0%B0%D0%B9%D0%B4-%D0%BF%D0%BE-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B2%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-5684280a445d)
- [habr - ](https://habr.com/ru/company/ruvds/blog/455505/)
- [habr - ](https://habr.com/ru/company/ruvds/blog/442650/)
- [habr - ](https://habr.com/ru/company/ruvds/blog/343888/)
- [habr - ](https://habr.com/ru/company/ruvds/blog/426053/)
- [habr - ](https://habr.com/ru/company/ruvds/blog/340034/)
- [CSSSR - Основы производительности React-приложений](https://blog.csssr.ru/2016/12/07/react-perfomance)
- [Habr - Оптимизация производительности в React](https://habr.com/ru/post/319536/)
- [Habr - Несколько способов оптимизировать React-Redux приложение](https://habr.com/ru/post/490526/)
- [Habr - Как организовать большое React-приложение и сделать его масштабируемым (2017)](https://habr.com/ru/company/nix/blog/329060/)
- [IT-Kamasutra #87 - shouldComponentUpdate, PureComponent, memo ](https://youtu.be/YEqCI9NMoLI)
- [см. раздел «Redux» - Быстродействие и оптимизация Redux](Redux.md)

<br></p>
</details>

[//]: # (Ещё разное про React todo: разбирать и дополнять)
<details><summary><h3>Ещё разное про React</h3> </summary><p>

---
**React JS и React Native**

- React JS - js-библиотека для создания UI (2013)
- React Native - платформа для разработки мобильных приложений, создает мобильные приложения с помощью React.js (2015)

Мобильные приложения имеют некоторые преимущества по сравнению с сайтами. Их можно использовать без соединения с
Интернетом. Они имеют доступ к таким возможностям устройства, как всплывающие уведомления. Также они позволяют быть в
контакте с вашими пользователями в режиме 24/7. React Native — это фреймворк, который позволяет вам создавать мобильные
приложения, используя React. Логика приложения пишется на JavaScript, таким образом, программисту не нужно отказываться
от привычных приемов веб-разработчика. Все что нужно — научиться писать специфичный для устройства код, который
адаптирует компоненты, ранее созданные для веб-сайта к новой среде обитания.

Если мы сравним затраты на разработку разных видов мобильных приложений, мы получим примерно следующие результаты:

- В случае с нативными приложениями вы можете надеяться на довольно высокую производительность, но стоимость разработки
  будет довольно высокой;
- Если вы предпочтете фреймворки, которые позволяют использовать HTML5, CSS3 и JavaScript, например PhoneGap, вы можете
  снизить стоимость. Но в этом случае уровень производительности будет гораздо ниже;
- В случае React вы можете достигнуть уровня производительности, сравнимого с нативными приложениями. При этом стоимость
  разработки сравнима с предыдущим примером.

Если вы планируете создать корпоративное веб-приложение и не вполне уверены, будет ли разработка мобильной версии этого
же приложения хорошей идеей, вот что вы должны помнить. React Native позволяет использовать уже имеющуюся логику
веб-приложения при создании мобильного приложения. Это значит, что команда разработчиков может использовать тот же код,
который был использован в процессе создания сайта вместо того, чтобы начинать с чистого листа.

React.js использует Virtual DOM, в то время как React Native использует собственные API

- [React Native и React.js — что и как, в чем разница, где применять](https://webonrails.ru/post/react-native-i-react-js-chto-i-kak-v-chem-raznica-gde-primenjat/)

**Связывание данных**<br>
Связывание данных - функция, которая синхронизирует данные между состоянием (моделью) приложения и представлением.

- Односторонняя привязка данных - любое изменение модели автоматически обновляет представление. Но не наоборот.
- Двусторонняя привязка данных - любое изменение модели автоматически обновляет представление. И наоборот.

В React однонаправленная привязка - свойства передаются от родительских компонент к дочерним ("сверху вниз"). Состояние
компонента инкапсулируется и недоступно для других компонентов. Если только оно не передается дочернему компоненту в
качестве props (т.е. состояние компонента становится props дочернего компонента).

Компоненты получают свойства как неизменяемые (immutable) значения. Поэтому компонент не может напрямую изменять
свойства, но может вызывать изменения через callback функции. Такой механизм называют «свойства вниз, события наверх».

**Реактивность**<br>
Вообще, определённый подход к созданию кода, парадигма программирования.
Полезно почитать немного про это дело:

- [habr - Реактивность в JavaScript: простой и понятный пример](https://habr.com/ru/company/ruvds/blog/418633/)
- [habr - Основы реактивного программирования с использованием RxJS](https://habr.com/ru/post/438642/)

**Рендеринг на стороне сервера**<br>

- Рендеринг на стороне сервера - браузер шлёт серверу запрос, сервер присылает весь HTML-файл. Браузер только выводит
  его пользователю.
- Рендеринг на стороне клиента - браузер запрашивает у сервера много JS и сырые данные из базы. Генерация HTML идёт в
  браузере (клиенте).

Рендеринг на стороне клиента имеет недостатки, например плох для SEO. Поэтому можно настроить React для рендеринга на
сервере. React может выполняться на стороне клиента и, при этом, рендерится на стороне сервера, и эти части могут
взаимодействовать друг с другом. Поэтому он широко используется для создания высокопроизводительных веб-приложений и
пользовательских интерфейсов.

React может рендерить компоненты сайта как на серверной, так и на клиентской стороне. Хорош для создания изоморфных
приложений - позволяет переиспользовать почти весь клиентский код для рендеринга на сервере, в зависимости от масштаба
приложения. Это возможно т.к.: 1) и на сервере и на клиенте используется JS; 2) и там и там не критичен реальный DOM
браузера - сам React работает с виртуальным.

**Изоморфность**<br>
При первом обращении к сайту все операции выполняются на сервере и в браузер передается HTML (как обычный статический
сайт). После загрузки JS сайт превращается в «одностраничное приложение», и работает соответственно.

Это полезно для SEO + пользователи сразу видят страницу, а не ждут пока загрузятся все данные и отрисуется нужная
информация

Когда пользователь открывает сайт, содержимое страницы должно быть загружено с сервера. В случае с SPA это может занять
некоторое время. Во время загрузки пользователи видят либо пустую страницу, либо анимацию загрузки. Учитывая, что по
современным стандартам ожидание в течение более чем двух секунд может быть весьма заметным неудобством для пользователя,
сокращение времени загрузки может оказаться крайне важным.

Virtual DOM позволяет React легко создавать изоморфные приложения. В других JS-фрэймворках клиентская часть кода часто
полагается на DOM браузера, которого нет на серверной стороне => нельзя использовать один код и на клиенте, и на
сервере. React же дает нам абстракцию браузерного DOM'а в виде виртуального DOM'а.

Это дает два основных преимущества:

- код, который работает с виртуальным DOM в React не зависит от браузера и может выполняться на сервере;
- React может оптимизировать операции над документами и снизить количество обращений к браузерному DOM и за счет этого
  значительно ускорить работу фронтенда.

Одной из основных особенностей React является то, что он может выполняться на стороне клиента и, при этом, рендериться
на стороне сервера, и эти части могут взаимодействовать друг с другом. Поэтому он широко используется для создания
высокопроизводительных веб-приложений и пользовательских интерфейсов.

[//]: # (todo: разобраться какая часть системы отвечает за преобразование JS в HTML? Скорее всего - браузер)


[//]: # (устанавливая пакет - дописывать в конце `--save`)
<details><summary>устанавливая пакет - дописывать в конце `--save`</summary><p>

Означает, что нужно внести запись в package.json
`npm install react-router-dom --save`

<br></p>
</details>

[//]: # (В React мы никогда не лезем в DOM напрямую.)
<details><summary>В React мы никогда не лезем в DOM напрямую.</summary><p>

Никаких getElementById и т.д. Мы работаем с VirtualDOm, а уже сам React занимается связкой Virtual DOM & DOM

<br></p>
</details>

[//]: # (Избегать циркулярных зависимостей)
<details><summary>Избегать циркулярных (циклических) зависимостей</summary>

Например:

- файл a.js импортирует в себя файл b.js,
- при этом внутри b,js есть импорт файла a.js.
- То есть фалы импортируются друг в друга.

Это плохой код, идущий в разрез с принципами функционального программирования.
Т.е не должно быть именно взаимных импортов.

Но, можно вызвать функцию из другого файла, и в качестве данных отдать в неё свою функцию. Т.е. использовать callback.

**Ссылки**

- https://www.youtube.com/watch?v=iN6QXbHedQc

<br></p>
</details>

[//]: # (Избегать изменения элементов/данных по ссылке)
<details><summary><b>Избегать изменения элементов/данных по ссылке</b></summary><p>

https://www.youtube.com/watch?v=NhT5nMvve4Q

мы не знаем где ещё он используется.

работать надо с локальными переменными.

Никогда не менять внешние переменные, и тем более - ничего, что приходит в props.

Работать с иммутабельными данными (теми, которые не меняются по ссылке). Если нужно поменять что-то - мы не меняем по
ссылке локальную переменную (например массив), а создаём новый массив с нужными параметрами

- Про JS-Объекты (и массивы). При копировании объект в памяти остаётся то же, на него просто создаётся новая ссылка.
  Поэтому, если измнеить что-то в объекте-копии, оригинальный объект тоже изменится (т.к. у нас есть только один объект,
  с двумя разными ссылками на него).
  Если объект одноуровневый - можно сделать его полноценную копию так (через спред-оператор):
  newObject = {...oldObject}
  Но, если в объекте oldObject были вложенные объекты/массивы - они передадутся опять по ссылке, а не создадут
  полноценной копии.

  <br></p>

</details>

[//]: # (При работе с функциями, мы передаём фактическую ссылку на функцию, а не строку.)
<details><summary>При работе с функциями, мы передаём фактическую ссылку на функцию, а не строку.</summary>
</details>

[//]: # (Передача аргументов в обработчики событий)
<details><summary>Передача аргументов в обработчики событий</summary><p>

Внутри цикла часто нужно передать дополнительный аргумент в обработчик события.
Например, если id — это идентификатор строки, можно использовать следующие варианты:

<button onClick={(e) => this.deleteRow(id, e)}>Удалить строку</button>
<button onClick={this.deleteRow.bind(this, id)}>Удалить строку</button>

Две строки выше — эквивалентны, и используют стрелочные функции и Function.prototype.bind соответственно.

В обоих случаях аргумент e, представляющий событие React, будет передан как второй аргумент после идентификатора.
Используя стрелочную функцию, необходимо передавать аргумент явно, но с bind любые последующие аргументы передаются
автоматически.

**Ссылки**

- https://ru.reactjs.org/docs/handling-events.html

<br></p>
</details>

[//]: # (Деструктуризация)
<details><summary>Деструктуризация</summary><p>

- [learn.javascript.ru - Деструктуризация](https://learn.javascript.ru/destructuring)
- [Деструктуризация в ES6. Полное руководство](https://medium.com/@stasonmars/%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-es6-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-b865bb71f376)
- [Habr - Вы не знаете деструктуризацию, пока](https://habr.com/ru/company/otus/blog/530248/)
- [Medium - Learn the basics of destructuring props in React](https://www.freecodecamp.org/news/the-basics-of-destructuring-props-in-react-a196696f5477/)
- [IT-Kamasutra #90 - Про деструктуризацию props в функциональных компонентах](https://youtu.be/JtbSOJKRJAI?t=1785)
- [IT-Kamasutra #90 - Про деструктуризацию props в классовых компонентах](https://youtu.be/JtbSOJKRJAI?t=3352)
- [Дэн Абрамов - Чем функциональные компоненты React отличаются от компонентов, основанных на классах? (см. про деструктуризацию props)](https://habr.com/ru/company/ruvds/blog/444348/)

<br></p>
</details>


[Habr - Техники повторного использования кода и разбиения сложных объектов на составные](https://habr.com/ru/post/545368/)

<br><p>
</details>

[//]: # (Ссылки)
<details><summary><h3>Ссылки</h3></summary><p>

- [Офф. сайт]( https://ru.reactjs.org/)
- [Блог Дэна Абрамова (en)](https://overreacted.io/)
- [Агапов Е - База знаний в GitHub](https://github.com/harryheman/my-js)
- [Агапов Е - База знаний на my-js.org](https://my-js.org/)

**Курсы**

- [Reactjs.org (офф. сайт) - учебный курс ]( https://ru.reactjs.org/tutorial/tutorial.html)
- [IT-Kamasutra - курс «React JS. Путь самурая (часть 1)» (YouTube). Лучший учебный курс, 100 уроков](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8)
- [IT-Kamasutra - курс «React JS. Путь самурая (часть 2)» (YouTube)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM3z1XqMw0kPuxpbyMo3HvN)
- [LearnJS - Курс](https://learn.javascript.ru/screencast/react )
- [Code.mu - Курс](http://code.mu/ru/javascript/framework/react/book/prime/)
- [Bob Ziroll (habr) - учебный курс (27 статей, ru)](https://habr.com/ru/company/ruvds/blog/432636 )
- [Hexlet - курсы React](https://ru.hexlet.io/courses/js-redux-toolkit/lessons/data-normalization/theory_unit)
- [Monsters - курс](https://monsterlessons.com/project/series/react-dlya-nachinayushih )
- [FDS - курс (6 месяцев)](https://ptchk.typeform.com/to/qZXOYF)

**IT-Kamasutra (YouTube)**
- [IT-Kamasutra - ReactJS - Путь Самурая 2.0 (YouTube, 23 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM3z1XqMw0kPuxpbyMo3HvN)
- [IT-Kamasutra - JS+React для Juniors (YouTube, 4 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DMuHec4RCfGuMwiij2_IvFR)
- [IT-Kamasutra - React JS - путь самурая 1.0 (YouTube)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8)
- [IT-Kamasutra - GIT (YouTube, 2 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DPgk3pH7vDxoMh2C5fM8fXP)
- [IT-Kamasutra - JS в деталях (YouTube, 48 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DN2nTU8Q10SvAn4k8NpMJvh)
- [IT-Kamasutra - Уроки JavaScript с нуля (YouTube, 29 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DPD5sRK3lw4bjBsKdgY2bPi)
- [IT-Kamasutra - React - Кабзда как подробно (YouTube, 3 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM49Jb2XZSf4READ3kO4UFL)
- [IT-Kamasutra - Todolist - React, TypeScript (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DMM8zDacOPhWfVitvOa_Fhu)
- [IT-Kamasutra - Ajax в деталях (YouTube, 9 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNDDIp2MGbv8cMYsoUO1lew)
- [IT-Kamasutra - addEventListener в деталях (YouTube, 4 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNwI9PyQ_IFW_dLpqBIuIyu)
- [IT-Kamasutra - react-четверг (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DN-JSjyJDFtGdRlsapKDpp9)
- [IT-Kamasutra - JavaScript для собеседований (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DMu_yc4R9btXnbbn4XqEwWj)
- [IT-Kamasutra - TypeScript Камасутра (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DM6f9AdaI8bUctNuGiAYKpO)
- [IT-Kamasutra - React English (YouTube, 1 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DOOi7Wqsv7ia5GJ_S9YlfDg)

**Best practices**
- [Паттерны React](https://habr.com/ru/post/309422/)
- [Гайд как писать на React в 2017](https://medium.com/@abraztsov/%D0%B3%D0%B0%D0%B9%D0%B4-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BD%D0%B0-react-%D0%B2-2017-8128906dae80)
- [11 советов для тех, кто использует Redux при разработке React-приложений](https://habr.com/ru/company/ruvds/blog/456336/)
- [9 принципов, которые должен знать новичок в React.js](https://medium.com/@apolyntsev/9-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BD%D0%BE%D0%B2%D0%B8%D1%87%D0%BE%D0%BA-%D0%B2-react-js-454e964062b)
- [Почему не надо сохранять props в state](https://riptutorial.com/ru/reactjs/example/15854/%D0%BE%D0%B1%D1%89%D0%B8%D0%B9-%D0%B0%D0%BD%D1%82%D0%B8%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD)
- [Как не надо писать React: неправильные шаблоны и проблемы в React](https://webformyself.com/kak-ne-nado-pisat-react-nepravilnye-shablony-i-problemy-v-react/)
<br></p>
</details>

<br>
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*