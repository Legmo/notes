# Шпаргалка по Redux #

#
<details><summary><b>Что такое Redux</b></summary><p>

- Разработан в Facebook 2013
- Библиотека (а не фреймворк) для управления state. Реализует Flux-архитектуру.
- Её надо инсталлировать отдельно (не идёт в комплекте с React b т.д.)
- Позволяет создавать свой store и удобно работать с ним
- В частности, уменьшает связность - позволяет передавать данные не по цепочке props, а сразу в нужную компоненту

Есть несколько библиотек, которые очень хорошо дополняют Redux:<br>
- Immutable.js — немутабельные структуры данных для JavaScript! Используйте их для хранения состояния, чтобы быть уверенным, что оно не меняется там, где не должно, а также чтобы сохранить функциональную чистоту редьюсеров
- redux-thunk — используется когда нужно, чтобы действия (actions) имели какой-либо побочный эффект в дополнение к обновлению состояния приложения. Например, вызов REST API, или установка маршрутов (routes), или даже вызов других действий.
- reselect — используется для создания составных, лениво исполняемых отображений. Например для конкретного компонента вам может потребоваться:
  1. вставить только определенную часть глобального состояния, а не полностью
  2. вставить дополнительные производные данные, например "итого" или "результаты валидации данных", не сохраняя все это в состоянии

**Ссылки**
- [Хабр - Введение в Redux & React-redux](https://habr.com/ru/post/498860/)
- [Изучаем Redux на примере создания мини-Redux](https://medium.com/devschacht/jakob-lind-learn-redux-by-coding-a-mini-redux-d1a58e830514)
- [Создаем свой собственный Redux, часть 2: функция connect](https://medium.com/devschacht/jakob-lind-code-your-own-redux-part-2-the-connect-function-d941dc247c58)
- [Build Yourself a Redux (en)](https://zapier.com/engineering/how-to-build-redux/)

<br></p>
</details>

<details><summary><b>Базовые понятия (кратко)</b></summary><p>

- `State` (состояние) — объект хранящий актуальное состояние системы.
- `Store` (хранилище) — объект, хранящий `state` и методы для работы с ним.
  - Методы = как его менять, как получить актуальное состояние хранилища (`getstate`), как подписаться на изменения (`subscriber`)... Их может быть много.
- `Dispatch` (отправка) — один из методов `store`. Объединяет все методы для правки `state`.
  - Хотим произвести любые изменения в `state` - вызываем метод `dispatch`
- `Actions` — объекты которые мы из UI (React) передаем в метод `dispatch()`.
  - Единственный способ внесения правок в `state` — вызывать `dispatch`, внутри которого некий `action`
- `Type` и `Payload` — параметры объекта `action`
  - `type` — строка, имя метода который будет менять `state`. По нему Redux понимает — что именно мы хотим сделать с `state`
  - `payload` — данные, которые нужны для изменений `state`.  Их может и не быть — например просто поменяли состояние системы на "Жду данных с сервера".
- `ActionCreators()` — функции, создают объект `Action`. Принимают данные-payload нужные для правки `state`, и возвращают объект `action` (с нужным type и payload).
  - Передавать `action` напрямую в `dispatch()` — плохой тон, код грязный и можно ошибиться.  `ActionCreators()`
  - Мы диспатчим не `ActionCreator` - диспатчится его вызов. Т.е. запустится функция `dispatch()`, выполнит `ActionCreator`, и уже потом выполнится  `dispatch()` с переданными в него результатами работы  `ActionCreator`  (т.е. с переданным объектом  `Action`)
- `Reducers()` — функции внутри `dispatch()`. Отвечают за правку опр. части `state`.  Принимают `action` и `state`, возвращают новый `state`
  - Принимают все `actions` входящие в `dispatch()`, и какой-то отдельный кусок `state` (например, отвечает за отдельную страницу).
  - Внутри стоит конструкция switch...case. Если `type` объекта `action` описан в этом switch - применяются изменения. Иначе - просто игнорируются
  - Нужны чтоб упростить работу со `state` — проще работать с каким-то небольшим объектом (например, описывающим состояние отдельной страницы). Для этого большой `state` дробят на части при помощи `reducers()`
  - Внутри `reducer` — набор методов для изменения данной части `state`.
  - `Reducer'у`  делегировано преобразование веток `state`. Та самая "простынь" с кучей `switch`/`case`. Туда же пихают `actionCreator`.
- `Thunk()` — функция, делает какой-то асинхронный код и умеет  `dispatch(actions)` . Нужна для асинхронных запросов.
  - Вызывается из UI (React), как обычный `dispatch()`
  - Внутри себя выполняет асинхронный код и диспатчит обычные  `actions` .
  - React Thunk — отдельная библиотека, уже включена в Redux Toolkit. Добавляется в Redux и позволяет использовать асинхронный код внутри `dispatch()`.
  - В программировании `thunk` — это подпрограмма, используемая для ввода вычисления в другую подпрограмму. В основном используются для задержки вычисления до тех пор, пока не потребуется его результат, или для вставки операций в начале или конце другой подпрограммы.
  - Термин `thunk` возник как причудливая форма глагола _думать_ (разговорная форма прошедшего времени think.). Это относится к первоначальному использованию thunks в компиляторах ALGOL 60, что требовало специального анализа (размышления), чтобы определить, какой тип подпрограммы генерировать.
  - [Hexlet - Асинхронные запросы (Thunk). React: Redux Toolkit](https://ru.hexlet.io/courses/js-redux-toolkit/lessons/async-thunks/theory_unit)
- `ThunkCreator()` — функция-обёртка `thunk()`. Нужна чтоб передать в `thunk()` данные-payload для правки `state` .
  - `Thunk` берёт данные из замыкания, образуемого `ThunkCreator()`. https://youtu.be/eWdnjfRu9Io?t=1087
  - Как и с  `ActionCreator`, мы диспатчим не `ThunkCreator` - диспатчится его вызов. Т.е. запустится функция `dispatch()`, выполнит `ThunkCreator`, и уже потом выполнится  `dispatch()` с переданными в него результатами работы  `ThunkCreator`  (т.е. с переданным `Thunk` который через замыкание получил нужные данные)
- `Saga()` — альтернатива `thunk`. Тоже библиотека. Сложнее, более продвинутая
  - https://habr.com/ru/post/351168/
  - Redux-saga — библиотека. Нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.
  - Саги — дизайн паттерн проектирования. Пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.
  - Узнать больше
    - посмотреть [Применения паттерна Сага](https://www.youtube.com/watch?v=xDuwrtwYHu8) от Caitie McCaffrey,
    - [статья](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.93.7258&rep=rep1&type=pdf), которая первая описывает саги в отношении распределенных систем (если вы амбициозны)
  - Альтернативы redux-saga. Две самых популярных:
    - [redux-observable](https://github.com/redux-observable/redux-observable) (базируется на [RxJS](https://github.com/ReactiveX/rxjs))
    - [redux-logic](https://github.com/jeffbski/redux-logic) (базируется на RxJS наблюдателях, но даёт свободу писать логику в [других стилях](https://github.com/jeffbski/redux-logic#tldr)).
- `Middleware()` — функция-обёртка `dispatch()`. Нужна чтоб выполнить асинхронный код между отправкой из UI и `dispatch()`
  - В `store` приходит что-то (`action` или `thunk`). Это что-то не сразу попадает в `store`, а вначале обрабатывает функцией-обёрткой вокруг `Dispatch` — `Middleware`. Если это `Action` - `Middlewear` сразу пропустит его в `store`. Но, если это `thunk` — `middlewear` вначале выполнит его, дождётся ответа (если код был асинхронный), получит ответ и снова проверит — пришёл `action`, или ещё одни `thunk` (так тоже бывает). И так пока не придёт `action`.
  - Зачем это? Проблема в том, что `store` умеет работать только с `actions` (объектами). Если в него попадёт `thunk` (функция, да ещё с асинхронными методами) — он ничего сделать не сможет. Поэтому, надо всю эту асинхронную логику где-то выполнить — между отправкой из UI и приходом в метод `store`. Для этого и сделали обёртку вокруг `store`.
  - Выполнять асинхронные запросы внутри `reducer` нельзя потому что
    - `reducer` должен быть чистой функцией
    - `reducer` должен отдавать новый `state` мгновенно, т.е. никаких ожиданий завершения асинхронного запроса
  - Redux предоставляет нам такую штуку как middleware, которая стоит между диспатчом экшена и редюсером.
  - Существует две самые популярные middleware библиотеки для асинхронных экшенов в Redux, это — Redux Thunk и Redux Saga..
  - Middleware компонуемы — несколько мидлваров можно объединить вместе, где каждый мидлвар не должен знать, что происходит до или после него в цепочке.
  - https://rajdee.gitbooks.io/redux-in-russian/content/docs/api/applyMiddleware.html

**Итого**
  - `state` — объект хранящий актуальное состояние
  - `store` — объект-хранилище всего что связано с состоянием
  - `subscriber` — метод для подписки на изменения в стэйте
  - `dispatch` — метод, для изменения стэйта. Все манипуляции со стэйтом делаем через dispatch
  - `action`  — объект, который мы снаружи отправляем в метод dispatch. Содержит тип (какое изменение произвести) и, если надо, данные
  - `reducer` — функция, которая получает отдельный кусок стэйта и action. Если нужно - применяет этот экшен к стейту и возвращает обновлённый кусок стэйта (потом из кусков собирается новый стэйт)

<br></p>
</details>

<details><summary><b>React-redux</b></summary><p>

- Отдельная библиотека, выступает как прослойка между React и Redux.
- Позволяет работать с Redux не заморачиваясь кучей сложностей.
- Инкапсулирует часть вещей, прячет от нас всякие детали связанные с контекстом, store, dispatch, subscribe...
- Обладает очень простым интерфейсом.
- Самое интересное:
  - `<Provider store>` — позволяет создавать обёртку для React-приложения и делать состояние Redux доступным для всех компонентов-контейнеров в его иерархии.
  - `connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])` — позволяет создавать компоненты высшего порядка. Это нужно для создания компонентов-контейнеров на основе базовых компонентов React.

**Ссылки**
- [Оф. документация React-redux (en)](https://react-redux.js.org/)
- [Оф. документация React - State и жизненный цикл](https://ru.reactjs.org/docs/state-and-lifecycle.html)
- [Redux и Thunk вместе с React. Руководство для чайников.](https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov)

<br></p>
</details>

<details><summary><b>Redux Toolkit</b></summary><p>

- Библиотека от разработчиков Redux.
- Релиз — 2019.
- Аналог «Create React App» для React — можно работать и без неё, но с ней намного удобнее. До релиза библиотека называлась «redux-starter-kit»<br>

Зачем:
- помогает быстро начать использовать Redux;
- упрощает работу с типичными задачами и кодом Redux;
- позволяет использовать лучшие практики Redux по умолчанию;
- предлагает решения, которые уменьшают недоверие к бойлерплейтам.

Наиболее значимые функции:
- configureStore — функция, предназначенная упростить процесс создания и настройки хранилища;
- createReducer — функция, помогающая лаконично и понятно описать и создать редьюсер;
- createAction — возвращает функцию создателя действия для заданной строки типа действия;
- createSlice — объединяет в себе функционал createAction и createReducer;
- createSelector — функция из библиотеки Reselect, переэкспортированная для простоты использования.

**Ссылки**
- [Оф. документация React-redux (en)](https://redux-toolkit.js.org/)
- [Оф. документация React-redux (ru)](https://rajdee.gitbook.io/redux-toolkit-in-russian/soderzhanie/quick-start)
- [Habr - Redux Toolkit как средство эффективной Redux-разработки](https://habr.com/ru/company/inobitec/blog/481288/)

<br></p>
</details>

<details><summary><b>State (состояние)</b></summary><p>

Cпециальный js-объект <внутри компонента>. Хранит данные, которые могут изменятся с течением времени.

Это инструмент, позволяющий обновлять пользовательский интерфейс, основываясь на событиях.

Задачи компоненты - отрисовывать какие-то данные. Эти данные всегда называются state (состояние приложения).

Узнать состояние компонента можно с помощью конструкции this.state.

Изменить состояние можно с помощью this.setState(), если передадим этой функции объект, представляющий новое состояние.

- **State-managment - управление данными**<br>
  Задумывая архитектуру нового приложения, первым делом всегда думать - как я собираюсь организовать state-managment (управление данными)?
  Чаще всего выбор зависит от того, в чём больше опыта.
  State (Business Logic Layer) важнее чем UI.
  Какие есть подходы к state-managment?
  - local state of class component - локальный state классовых компонент. Используется не всегда. Для простых, небольших задач, маленьких проектов.
  - Redux (одна из реализаций FLUX) - функциональное програмирование
  - MobX - ООП
  - и ещё много других

- **Не изменяйте state напрямую**<br>
  // Неправильно
  `this.state.comment = 'Привет';`

  Вместо этого используйте setState():
  // Правильно
  `this.setState({comment: 'Привет'});`

  Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.

  - **Обновления state могут быть асинхронными**<br>
    React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.

    Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.

    Например, следующий код может не обновить счётчик:

    // Неправильно
    ```
    this.setState({
      counter: this.state.counter + this.props.increment,
    });
    ```

    Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:

    // Правильно
    ```
    this.setState((state, props) => ({
      counter: state.counter + props.increment
    }));
    ```

- **Однонаправленный поток данных**<br>
  В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента.
  Также не важно, как был создан определённый компонент — с помощью функции или класса.
  Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.
  Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов:

  `<h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>`

  Своё состояние можно передать и другому пользовательскому компоненту:

  `<FormattedDate date={this.state.date} />`

  Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения:
  ```
    function FormattedDate(props) {
      return <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>;
    }
  ```

Этот процесс называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.

Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.

**Ссылки**
- https://ru.reactjs.org/docs/state-and-lifecycle.html

<br></p>
</details>

<details><summary><b>Store (хранилище)</b></summary> 

ООП-объект, который управляет state (объект хранящий состояние приложения)

Там лежит:
- сам state
- методы для работы с ним

Создаётся при помощи метода(?) createStore(reducers)

<br></p>
</details>

<details><summary><b>Dispath (отправка)</b></summary><p> 

- https://youtu.be/AyCBG4LcUSA?t=141
- англ. "отправка"
- Метод объекта store, который предназначен для вызова всех методов, изменяющих store
- Т.е. вместо того чтобы прокидывать кучу разных методов, мы отдаём один единственный - disptach.
- В него передаём объект action, у которого указан type и есть нужные данные. Dispatch, на основе этого type и данных, вносит правки в store (прежде всего - в state)

Метод объекта store, через который вызываем все другие методы объекта Store (что изменить state, т.е. состояние приложения)

Мы вводим в наш объект store один единственный метод, через который будем вызывать все другие методы объекта.

Он принимает некий объект action. Выглядит так: dispath(action).

У action обязательно должно быть текстовое свойство type='' - в нём передаётся название требуемого действия (т.е. метода).

Эти текстовые названия всегда пишутся заглавными.

State всегда меняется через dispath(action)

<br></p>
</details>

<details><summary><b>Action</b></summary><p> 

- объект, который через метод dispath передаётся в наш объект store, и там производит некие действия с данными (state)

У action есть как минимум одно свойство, type.
По type dispath определяет, какие именно действия надо произвести со state (какую ветку действий выбрать)

<br></p>
</details>

<details><summary><b>Action Creator</b></summary><p> 

- вспомогательная функция, которая создаёт нужный объект-action. В компоненте хотим вызвать dispatch с каким-то экшеном, чтоб изменить стэйт. Для этого заранее создали в редьюсере экшен-криэйтор для данного экшена. Этот экшен-криэйтор импортировали в компоненту. В компонененте вызвали dispatch(экшен_криэйтор(payload)). Зачем надо? Сложно сказать. По идее. у action может быть сложная структура объекта. Чтоб каждый раз её заново не писать - сделали такую штуку.

Функции, которые возвращают объект action. То, что передаётся в mapDispatchToProps

Содержит action - type и список данных, которые может получать.

Пример:
export const updateTaskStatus = (status, id) => ({
type: UPDATE_TASK_STATUS,
newStatus: status,
taskId: id,
});

<br></p>
</details>

<details><summary><b>Reducer (уменьшатель)</b></summary><p>

Чистая функция, принимает state и action. Та самая простынь, где много switch

Применяет action к этому state (если нужно) и возвращает новый state (если не изменился - тот же).

Позволяет разделить метод dispath на отдельные куски, чтоб с ним было удобнее работать.

Обычно каждый reducer отвечает за какую-то ветку state - например этот работает с одной страницей, а тот с другой; или один работает с цитатами, а другой с пользователями.

Reducers - это отдельные функции, а не методы объекта store. Они лежат отдельно от store. Поэтому store (и его метод dispatch) не в курсе, какой action какому reducer нужен - мы отправляем любой входящий action всем имеющимся reducers. Для работы reducer ему кроме action нужен ещё и state. Но, мы не отправляем весь state целиком каждому reducer - нет, каждому мы отправляем только ту ветку, с которой он работает.

Reducer - только преобразователь. Он не вызывает subscriber и другие callbacks.

Если тип action неизвестен - выдаём изначальный state

  ```javascript
  const task_tables_reducer = (state = initialState, action) => {
  switch(action.type) {
    case IS_PAGINATION: {
      return {...state};
    }
    default:
      return state;
  }
}
  ```  
<br></p>
</details>

<details><summary><b>connect(mapStateToProps, mapDispatchToProps)</b></summary><p>
  - API-функция предоставляемая пакетом react-redux.<br> 

Позволяет создавать контейнерные компоненты

Пробрасывает в презентационную компоненту данные из store, в виде props. Благодаря mapStateToProps

Подписывает презентационную компоненту на все изменения state, которые мы объявили в mapStateToProps

Позволяет контейнерной компоненте изменять store, благодаря mapDispatchToProps

Connect автоматически делает подключенные компоненты «чистыми», то есть они будут повторно рендериться только при изменении их props — тоесть, когда изменяется их срез состояния Redux. Это предотвращает ненужный ре-рендер и ускоряет работу приложения.

Connect() используется для создания компонентов-контейнеров, которые подключены к хранилищу Redux. Хранилище, к которому осуществляется подключение, получают от самого верхнего предка компонента с использованием механизма контекста React.

Если вам, в React-компоненте, нужно получать данные из хранилища, или требуется диспетчеризовать действия, или нужно делать и то и другое, вы можете преобразовать обычный компонент в компонент-контейнер, обернув его в компонент высшего порядка, возвращаемый функцией connect() из react-redux.

Вы можете создать компонент-контейнер самостоятельно и вручную подписать компонент на хранилище Redux, используя команду store.subscribe(). Однако использование функции connect() означает применение некоторых улучшений и оптимизаций производительности, которые, вы, возможно, не сможете задействовать при использовании других механизмов.

Функция connect(), кроме того, даёт разработчику дополнительную гибкость, позволяя настраивать компоненты-контейнеры на получение динамических свойств, основываясь на свойствах, первоначально им переданных. Это оказывается очень кстати для получения выборок из состояния, основываясь на свойствах, или для привязки генераторов действий к конкретной переменной из свойств.

Если ваше React-приложение использует несколько хранилищ Redux, то connect() позволяет легко указывать конкретное хранилище, к которому должен быть подключён компонент-контейнер.

Прежде чем преобразовывать обычный компонент React в компонент-контейнер с использованием connect(), нужно создать хранилище Redux, к которому будет подключён этот компонент.

Функция connect(), предоставляемая пакетом react-redux, может принимать до четырёх аргументов, каждый из которых является необязательным. После вызова функции connect() возвращается компонент высшего порядка, который можно использовать для оборачивания любого компонента React.

  ```javascript
  connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) 
  ```

**mergeProps**<br>
Если функции connect() передаётся аргумент mergeProps, то он представляет собой функцию, которая принимает следующие три параметра:
- stateProps — объект свойств, возвращённый из вызова mapStateToProps().
- dispatchProps — объект свойств с генераторами действий из mapDispatchToProps().
- ownProps — исходные свойства, полученные компонентом.

Эта функция возвращает простой объект со свойствами, который будет передан заключённому в обёртку компоненту. Это полезно для осуществления условного маппинга части состояния хранилища Redux или генераторов действий на основе свойств.

Если connect() не передают эту функцию, то используется её стандартная реализация:

  ```javascript  
    const mergeProps = (stateProps, dispatchProps, ownProps) => {
      return Object.assign({}, ownProps, stateProps, dispatchProps)
    }
  ```

**options**<br>
Объект с параметрами. Необязательный объект, передаваемый функции connect() в качестве четвёртого аргумента.

Содержит параметры, предназначенные для изменения поведения этой функции. Так, connect() представляет собой специальную реализации функции connectAdvanced(), она принимает большинство параметров, доступных connectAdvanced(), а также некоторые дополнительные параметры.

[Страница документации](https://react-redux.js.org/api/connect) - какие параметры можно использовать с connect(), и как они модифицируют поведение этой функции.

**Ссылки**
- [Использование функции connect() из пакета react-redux](https://habr.com/ru/company/ruvds/blog/423157/)
- [Оф. документация React-redux (en)](https://react-redux.js.org/)
- [Создаем свой собственный Redux, часть 2: функция connect](https://medium.com/devschacht/jakob-lind-code-your-own-redux-part-2-the-connect-function-d941dc247c58)

<br></p>
</details>

<details><summary><b>mapStateToProps</b></summary><p>

Функция, возвращает либо обычный объект, либо другую функцию.

Передача mapStateToProps в качестве аргумента для функции connect() приводит к подписке компонента-контейнера на обновления Redux Store. mapStateToProps будет вызываться каждый раз, когда состояние Store изменяется. Если слежение за обновлениями состояния не нужно - передайте connect() в качестве значения этого аргумента undefined или null.

[//]: # (todo: разбираться со вторым примером)
mapStateToProps() объявляется с двумя параметрами, второй из которых является необязательным:
- Первый параметр представляет собой текущее состояние хранилища Redux.
- Второй параметр (ownProps), если его передают, представляет собой объект свойств, переданных компоненту


  ```javascript
      const mapStateToProps = (state, ownProps) => ({
      coin: coinSelector(state, ownProps),
      isLoading: isCoinsLoadingSelector(state),
    });
  ```

**ownProps**<br>
Это свойства компонента.

Как уже было сказано, функции mapStateToProps и mapDispatchToProps, переданные connect(), могут быть объявлены со вторым параметром ownProps, представляющим собой свойства компонента.

Однако тут есть одна проблема. Если число обязательных параметров объявленной функции mapStateToProps меньше, чем 2, тогда ownProps передаваться не будет. Но если функция объявлена с отсутствием обязательных параметров или, как минимум, с 2 параметрами, ownProps будет передаваться.

  ***  
Если из mapStateToProps будет возвращён обычный объект, то возвращённый объект stateProps объединяется со свойствами компонента.

Если же mapStateToProps возвращает функцию, то эта функция используется как mapStateToProps для каждого экземпляра компонента. Это может пригодиться для улучшения производительности рендеринга и для мемоизации.

**Ссылки**
- [Использование функции connect() из пакета react-redux](https://habr.com/ru/company/ruvds/blog/423157/)

<br></p>
</details>

<details><summary><b>mapDispatchToProps</b></summary><p>

Объект, содержащий набор actionCreators.<br>

Может быть либо объектом, либо функцией, которая возвращает обычный объект или другую функцию.

Используется в connect

Позволяет контейнерной компоненте диспатчить изменения в store

Если в качестве аргумента mapDispatchToProps используется объект, то каждая функция в объекте будет воспринята в качестве генератора действий Redux и обёрнута в вызов метода хранилища dispatch(), что позволит вызывать его напрямую. Получившийся в результате объект с генераторами действий, dispatchProps, будет объединён со свойствами компонента.

При использовании в качестве аргумента mapDispatchToProps функции программист должен самостоятельно позаботиться о возврате объекта dispatchProps, который осуществляет привязку генераторов действий с использованием метода хранилища dispatch(). Эта функция принимает, в качестве первого параметра, метод хранилища dispatch(). Как и в случае с mapStateToProps, функция также может принимать необязательный второй параметр ownProps, который описывает маппинг с исходными свойствами, переданными компоненту.

Если эта функция возвращает другую функцию, то возвращённая функция используется в роли mapDispatchToProps, что может быть полезным для целей повышения производительности рендеринга и мемоизации.

**Ссылки**
- [Использование функции connect() из пакета react-redux](https://habr.com/ru/company/ruvds/blog/423157/)

<br></p>
</details>

<details ><summary><b>Селекторы, библиотека reselect</b></summary><p>

Функция, принимает весь стэйт целиком, достаёт и обрабатывает какие-то данные и передаёт их в `mapStateToPros` (и дальше в UI).

Отдельный архитектурный слой, занимается получением, комбинированием и преобразованием данных. Например, данные из этого куска стэйта надо как-то обработать, объединить с данными из другого куска стэйта, отфильтровать, убрать дубли и только потом передать в React.

Зачем нужны - чтобы разделить структуру данных в стэйте (BLL) и React (UI). Если мы поменяем структуру данных в стэйте, например переименуем какой-то объект, разделим его на несколько и т.д.- хорошо бы иметь одно место, где можно внести изменения. Иначе придётся прыгать по всем `mapStateToPros` приложения и менять структуру вручную.

`mapStateToPros` - предоставляется библиотекой React-Redux.

**Проблемы селекторов**
В Redux нельзя подписаться на изменение конкретного кусочка данных. Изначально, можно лишь узнать о том, что "где-то что-то изменилось".<br>
Т.к.  'mapStateToProps' вызывается в каждом компоненте при каждом изменении стэйта — каждый селектор тоже будет вызываться при каждом изменении стэйта. Даже если меняется совсем другая ветка. А если селектор плюс ко всему делает `.map()`, `.filter()`, `.reduce()` и т.д. — он ещё и создаёт новый объект (даже если данные в него пришли те же) => будет ненужный ре-рендер страницы. <br>
Основные проблемы:
- Могут вызывать ненужные ре-рендеры страниц при каждом изменении в глобальном стэйте.
- Могут иметь сложную логику вычислений => будут создавать большую нагрузку, долго вычислять (вызываются при каждом изменении в глобальном стэйте).
- Трудны в отладке - debugger поставленный в селекторе вызывается при каждом изменении в глобальном стэйте, а не тогда когда меняется что-то в части стэйта с которой работает данный селектор.

**Библиотека `reselect`**
[GitHub - Reselect](https://github.com/reduxjs/reselect).<br>
Библиотека для создания мемоизированных "селекторных" функций.<br>
Мемоизация = сохранение результатов выполнения функций для предотвращения повторных вычислений.<br>
Селектор по-прежнему вызывается каждый раз когда хоть что-то меняется в глобальном стэйте. Но результаты работы селектора сохранены, и при каждом новом вызове отдаётся этот сохранённый результат.<br>
При этом объявлены «зависимости» - от каких частей стэйта зависит данный селектор. Если эти части меняются - результат работы селектора вычисляется и запоминается заново.
Т.е.:<br>
- мы возвращаем тот же массив, а не его копию - не будет ре-рендера
- мы не запускаем вычисления внутри селектора - не будет тратиться время и вычислительная мощность
- мы не запускаем вычисления внутри селектора - не попадаем в саму функцию, а значит debugger лишний рах не вызывается

Не используйте reselect там, где не происходит вычислений.<br> 
Не надо лишний раз засорять память, reselect трудно ускорить, и кеширование тут не поможет.<br>
Отдавая кеширование на откуп библиотеке, вы рискуете по неосторожности загадить память кешом. В браузере у вас один пользователь, да и страничка живет недолго, а на сервер приходит много пользователей, и процесс там живет долго.

**Ссылки**
- [Habr - Готовим селекторы в Redux](https://habr.com/ru/post/564004/)
- [Habr - Несколько способов оптимизировать React-Redux приложение](https://habr.com/ru/post/490526/)
- [It-Kamasutra - React JS - селекторы (reselect part 1)](https://youtu.be/qzxL8qdPMgU)
- [It-Kamasutra - React JS - mapStateToProps (reselect часть 2)](https://youtu.be/_jyrQh0ZdTA)
- [It-Kamasutra - React JS - mapStateToProps (reselect часть 3)](https://youtu.be/nDh92Vnf3_k)
<br></p>
- [GitHub - Reselect](https://github.com/reduxjs/reselect)

</details>

<details><summary><b>Provider</b></summary><p>

Компонент, оборачивается вокруг корневой компоненты (<App>). Позволяет передавать store всем потомкам - теперь у connect() есть доступ к store

Пакет react-redux предоставляет разработчику компонент <Provider>, который можно использоваться для оборачивания корневого компонента приложения. Он принимает свойство store. Предполагается, что оно представляет собой ссылку на хранилище Redux, которое планируется использовать в приложении. Свойство store передаётся, в соответствии с иерархией приложения, компонентам-контейнерам, с использованием механизма контекста React:

<br></p>
</details>

<details><summary><b>Compose</b></summary><p>

Подход из функционального программирования
Реализацию этой функции предоставляет, в частности, Redux

Позволяет объединить несколько последовательных вызовов функций. Полезно в ситуации конвейера - мы передаём данные в функцию A, результат её работы передаётся в функцию B, результат работы B передаётся в C... и так далее

  ```javascript
  compose(
        connect(mapStateToProps, mapDispatchToProps),
        withAuthRedirect
)
(component)
  ```

Оборачивание идёт "снизу вверх" - вначале обернёт withAuthRedirect(), потом connect(mapStateToProps, mapDispatchToProps)()

**Ссылки**
- [YouTube - IT Kamasutra 70](https://www.youtube.com/watch?v=tf4E6tw8ZVw)

<br></p>
</details>

<details><summary><b>Connect</b></summary><p>

connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])

API react-redux connect() используется для создания компонентов-контейнеров, которые подключены к хранилищу Redux.

Если вам, в React-компоненте, нужно получать данные из хранилища, или требуется диспетчеризовать действия, или нужно делать и то и другое, вы можете преобразовать обычный компонент в компонент-контейнер, обернув его в компонент высшего порядка, возвращаемый функцией connect() из react-redux.

Если ваше React-приложение использует несколько хранилищ Redux, то connect() позволяет легко указывать конкретное хранилище, к которому должен быть подключён компонент-контейнер.

**Ссылки**
- [Habr - Использование функции connect() из пакета react-redux](https://habr.com/ru/company/ruvds/blog/423157/)

<br></p>
</details>

<details ><summary><b>Быстродействие и оптимизация Redux</b></summary><p>

**Ссылки**
- [Habr - Несколько способов оптимизировать React-Redux приложение](https://habr.com/ru/post/490526/)
- [Habr - Готовим селекторы в Redux](https://habr.com/ru/post/564004/)
- [Почему не надо сохранять props в state](https://riptutorial.com/ru/reactjs/example/15854/%D0%BE%D0%B1%D1%89%D0%B8%D0%B9-%D0%B0%D0%BD%D1%82%D0%B8%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD)
- [Как не надо писать React: неправильные шаблоны и проблемы в React](https://webformyself.com/kak-ne-nado-pisat-react-nepravilnye-shablony-i-problemy-v-react/)
- [см. раздел «React» - Быстродействие и оптимизация React](React.md)

<br></p>
</details>

<details><summary><b>Ссылки</b></summary><p>

- [Оф. документация React-redux (en)](https://react-redux.js.org/)
- [Оф. документация React-redux (ru)](https://rajdee.gitbooks.io/redux-in-russian/content/)
- [Изучаем Redux на примере создания мини-Redux](https://medium.com/devschacht/jakob-lind-learn-redux-by-coding-a-mini-redux-d1a58e830514)
- [Создаем свой собственный Redux, часть 2: функция connect](https://medium.com/devschacht/jakob-lind-code-your-own-redux-part-2-the-connect-function-d941dc247c58)
- [Build Yourself a Redux (en)](https://zapier.com/engineering/how-to-build-redux/)
- [Redux и Thunk вместе с React. Руководство для чайников](https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov)

<br></p>
</details>

#
<details><summary><b>AJAX и асинхронные операции</b></summary>
  
---
<details><summary><b>Асинхронные операции</b></summary><p> 

  Асинхронные операции - операции, требующие некоторого времени для завершения. 
  Например - функция, которая делает запрос API на сервер. Она не возвращает результат немедленно, для получения ответа от сервера требуется несколько секунд. 
  Поэтому, если вы вызываете эту функцию и присваиваете ее значение для некоторой переменной, она будет undefined не определено. Поскольку Javascript не знает, что функция обрабатывает некоторые операции async.
  
  Про декларативное программирование и функциональные/классовые компоненты
  В мире реакта мы используем декларативное программирование. То есть мы не описываем что нужно убрать этот текст или напротив - добавить текст в HTML. Мы описываем состояние компонента.
  Для того, чтобы описывать состояния компонента, нам недостаточно использовать такой простой синтаксис описания компонента в виде функции. Такой синтаксис подходит только для очень простых компонентов, которые имеют небольшую часть логики Stateless компоненты.
  Для того, чтобы добавить описание состоянию компонента нам придется использовать второй синтаксис с использование классов ES6

  <br></p>
</details>

<details><summary><b>Запрос внутри actionCreator</b></summary><p> 

- Самый простой вариант - делаем запрос внутри actionCreator
- Например, при помощи fetch:

  ```javascript
    const fetchDog = (dispatch) => {
    dispatch(requestDog());
    return fetch('https://dog.ceo/api/breeds/image/random')
          .then(res => res.json())
          .then(
                  data => dispatch(requestDogSuccess(data)),
                  err => dispatch(requestDogError())
          );
    };
  ```

Это простой, но очень негибкий подход.

Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных.

В случае асинхронного вызова, надо сначала дождаться ответа и затем (если не было ошибок) обновить состояние. А  если у приложения сложная логика?

Для этого Redux использует промежуточные слои (middlewares) - код, который выполняется после отправки действия, но перед вызовом редюсера.

Промежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие)

<br></p>
</details>

<details><summary><b>Middlewares</b></summary><p>

- Промежуточные слои Redux. Используются для реализации асинхронности в Redux
- функция, которая запускается каждый раз при отправке action’а
- Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных.
- На каждое действие, в хранилище (store) посылается объект, описывающий что произошло, затем вызывается редюсер (reducer) и состояние (state) сразу обновляется.
- Промежуточный слой это кусок кода, который выполняется после отправки действия, но перед вызовом редюсера.
- Промежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие)
- Для асинхронных операций, Redux предлагает использовать redux-thunk промежуточный слой.
  <br>

Написание собственной middleware не так сложно, как может показаться, и позволяет использовать некоторые мощные средства.
Например:
- Хотите посылать API-запрос каждый раз, когда имя action’a начинается с FETCH_? Вы можете сделать это с помощью middleware.
- Хотите централизованное место для логирования событий в вашем аналитическом ПО? Middleware — хорошее место для этого.
- Хотите предотвратить запуск action’a в определенный момент времени? Вы можете сделать это с помощью middleware, невидимого для остальной части вашего приложения.
- Хотите перехватить action, имеющий токен JWT, и автоматически сохранить его в localStorage? Да, middleware.

<br></p>
</details>

<details><summary><b>Redux-thunk</b></summary><p>

- библиотека, один из вариантов реализации middleware (промежуточный слой) для React-Redux

- thunk = преобразователь (англ)
- стандартный путь выполнения асинхронных операций в Redux.
- вводит понятие функции-преобразователя, которая вызывается внутри dispatch и уже по завершении своей работы возвращает нормлаьный dispatch (вызовет необходимый метод для изменения store)
- вызываем dispatch, как обычно. Но передаем в него не обьект, а функцию-1, которая возвращает функцию-2.
  В возвращаемой функции-2 есть аргумент dispatch.
  Теперь мы можем в этой функции-1 делать любые асинхронные операции и вызывать dispatch тогда, когда нам нужно.
- Преимуществом использования redux-thunk является то, что компонент не знает, что выполняется асинхронное действие.
  Т.к. промежуточный слой автоматически передает функцию dispatch в функцию, которую возвращает генератор действий, то снаружи, для компонента, нет никакой разницы в вызове синхронных и асинхронных действий (и компонентам больше не нужно об этом беспокоиться)

- thunk = функция, которая выполняет асинхронную операцию и на выходе диспатчит какие-то action в reducers.
  Саму функцию thunk тоже можно задиспатчить
  По сути, thunk = название функции, в которой происходит какая-то логика.
  Эта функция производит какие-то асинхронные действия и при этом умеет вызывать различные dispatch по результатам этих асинхронных действий.
  Чтобы она могла вызывать метод dispatch, он должен прийти в неё - т.е. dispatch надо передать в параметрах этой функции при её вызове
  Функцию thunk запускает Redux. Мы её диспатчим, а Redux store её запустит и закинет в неё свой метод dispatch.

  А откуда функция thunk получит данные, которые должна обработать? Например, текст сообщения, которое она должна послать AJAX'ом на сервер? Передать эти данные как параметр функции мы не можем, т.к. вызывать её будет store.
  Эти данные она возьмёт из замыкания.
  Чтоб возникло замыкание, функцию thunk надо вернуть из некоей родительской функции (тогда thunk получит доступ к данным родительской функции).
  Используем родительскую функцию ThunkCreator:
  - В ThunkCreator передаём данные (для передачи AJAX'ом на сервер, например),
  - ThunkCreator вернёт нам thunk (уже с замыканием в котором есть нужные данные).
  - полученную функцию thunk мы диспатчим в Redux store
  - Redux при вызове thunk передаст в неё метод dispatch (чтоб thunk могла по результатам своей работы что-то задиспатчить в store)
    Т.е. по факту, мы:
  - диспатчим вызов ThunkCreator, в который передаём данные
  - ThunkCreator вызовет thunk (данные уже в нём благодаря замыканию),
  - thunk выполнит AJAX-логику
  - и по результатам вызовет какие-то dispatch, которые уйдут в reducers.

  Один момент: store не умеет принимать функции (он ждёт объект со свойством type, чтоб раскидать по reducers).
  То есть, store не может принять thunk :(
  Поэтому, приходится использовать middleware (промежуточный слой) - он вклинивается между приёмником dispatch в store и моментом передачи диспатчей по reducers.
  Мы должны при создании store немного его перенастроить, чтоб добавить middleware в цепочку.
  Получается такая логика:
  - если на вход поступил обычный dispatch - он проходит middleware насквозь и уходит в reducers.
  - но, если на входе пришла функция (thunk) - она обрабатывается middleware, и её результаты снова отправляются на вход Store.
  - если эти результаты = ещё один thunk, то процесс повторяется (да, thunk могут быть вложенными)
  - если эти результаты = dispatch, то он проходит middleware насквозь и уходит в reducers.


- По умолчанию, экшены в Redux являются синхронными, что, является проблемой для приложения, которому нужно взаимодействовать с серверным API, или выполнять другие асинхронные действия. К счастью Redux предоставляет нам такую штуку как middleware, которая стоит между диспатчом экшена и редюсером. Существует две самые популярные middleware библиотеки для асинхронных экшенов в Redux, это — Redux Thunk и Redux Saga.
- Это библиотека нацеленная делать сайд-эффекты проще и лучше
- Это middleware библиотека, которая позволяет вам вызвать action creator, возвращая при этом функцию вместо объекта. Функция принимает метод dispatch как аргумент, чтобы после того, как асинхронная операция завершится, использовать его для диспатчинга обычного синхронного экшена, внутри тела функции.
- Обычно Redux-Thunk используют для асинхронных запросов к внешней API, для получения или сохранения данных.
- Например, у нас есть обычное todo приложение. Когда мы нажимаем «добавить todo», обычно, сперва диспатчится экшен, который сообщает о старте добавления нового todo. Затем, если todo элемент успешно создан и возвращен сервером, диспатчится другой экшен, с нашим новым todo элементом, и операция завершается успешно. В случае, если сервер по каким то причинам возвращает ошибку, то вместо добавления нового todo диспатчится экшен с ошибкой, что операция не была завершена.  
- Давайте посмотрим, как это может быть реализовано с помощью Redux-Thunk. В компоненте, экшен диспатчится как обычно
- В самом экшене дело обстоит намного интереснее. Здесь мы будем использовать библиотеку [Axios](https://alligator.io/react/axios-react/), для ajax запросов
- Мы будем делать POST запрос на адрес — jsonplaceholder.typicode.com/todos
- Наш **addTodo** action creator возвращает функцию, вместо обычного экшен объекта. Эта функция принимает аргумент dispatch из store.
- Внутри тела функции мы сперва диспатчим обычный синхронный экшен, который сообщает, что мы начали добавление нового todo с помощью внешней API. Простыми словами — запрос был отправлен на сервер. Затем, мы собственно делаем POST запрос на сервер использую Axios. В случае утвердительного ответа от сервера, мы диспатчим синхронный экшен, используя данные, полученные из сервера. Но в случае ошибки от сервера мы диспатчим другой синхронный экшен с сообщением ошибки.
- Функция, возвращаемая асинхронным action creator'ом с помощью Redux-Thunk, также принимает getState метод как второй аргумент, что позволяет получать стейт прямо внутри action creator'а
- Использование getState может быть действительно полезным, когда надо реагировать по разному, в зависимости от текущего стейта. Например, если мы ограничили максимальное количество todo элементов до 4, мы можем просто выйти из функции, если этот лимит превышается:
- https://habr.com/ru/post/483314/

**Ссылки**
- https://habr.com/ru/post/351168/
- https://monsterlessons.com/project/lessons/reduxjs-asinhronnye-eksheny-s-pomoshyu-redux-thunk
- https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov
- https://www.youtube.com/watch?v=eWdnjfRu9Io
- [Redux и Thunk вместе с React. Руководство для чайников.](https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov)

<br></p>
</details>

<details><summary><b>Redux saga</b></summary><p>

- другая библиотека, для реализации middleware (промежуточный слой) React-Redux
- Для упрощения и улучшения сайд-эффектов в приложениях React-Redux. Прежде всего - асинхронные запросы (извлечение данных и т.д.) и нечистые вещи (доступ к кешу браузера и т.д.)
- Их легче тестировать, на них легче реализовать сложную логику (задержки, параллельные задачи, отмена задач,)
- Саги это дизайн паттерн, который пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.
- Работают на основе функций-генераторов
- Если говорить в общем, мы имеем сагу чья работа это следить за отправленными действиями (dispatched actions). И ещё одна сага-рабочий
- Сага-наблюдатель (watcher saga) является ещё одним неявным слоем. Дает больше гибкости для реализации сложной логики, но иногда лишняя для простых приложений.
- Effects. Методы внутри саг(?) возвращают не dispatch action, а объекты с инструкциями для промежуточного слоя (middleware) —  отправить действие. Эти возвращаемые объекты называются Эффекты (Effects)

- Есть альтернативы redux-saga, которые стоит попробовать. Две самых популярных это:
  - redux-observable (который базируется на RxJS)
  - redux-logic (также базирующийся на RxJS наблюдателях, но дающий свободу писать вашу логику в других стилях).

<br></p>
</details>

<details><summary><b>Axios</b></summary><p>

- инструмент для отправки ajax-запросов, основанный на промисах, очень похожий на jQuery.
- Альтернативы: got, fetch, SuperAgent, jQuery

<br></p>
</details>

<details><summary>Вариант организации AJAX (IT-Kamasutra)</summary><p>

- для работы с серверным API & AJAX - используем axios
- Изначально у нас в стэйте нет данных (например, списка задач) - мы должны получить их с сервера
- Берём reducer, в котором эти данные выводятся и соответствующий action
- Создаём новый action = setTasks //получить-установить задачу
- В reducer пишем реакцию на этот action - добавить в state данные из объекта, который приходит с этим action
- В контейнерной компоненте, в функции mapStateToProps добавляем в state компоненты задачи из общего state
- В контейнерной компоненте, в функции mapDispatchToProps создаём callback для вызова этого action. При вызове этого action - он добавит задачи в state
- Сам факт захода пользователя на страницу со списком задач = действие (т.е. диспатч), которое вызывает этот action.

**Ссылки**
- https://www.youtube.com/watch?v=c34P8-9YVMQ&list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8&index=51

<br></p>
</details>

**Ссылки**
- [Лучшие практики React AJAX](https://tuhub.ru/posts/luchshie-praktiki-react-ajax)
- [Redux и Thunk вместе с React. Руководство для чайников.](https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov)

<br></p>
</details>
<br>
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*