<h1> Шпаргалка по JavaScript </h1>

[//]: # (Ресурсы по JS)
<details><summary><h3>Ресурсы по JS</h3></summary><p>

- [MDN - Повторное введение в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript)
- [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/)
- [Habr - Подводные камни JavaScript](https://habr.com/ru/post/159313)

- [learn.javascript.ru](https://learn.javascript.ru)
- [doka.guide](https://doka.guide/js)
- [metanit.com](https://metanit.com/web/javascript/)
- [Schoolsw3](https://www.schoolsw3.com/js)
- [ITchief](https://itchief.ru/javascript/)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript)
- [code.mu - Учебник JS: основной](https://code.mu/ru/javascript/book/prime/)
- [code.mu - Учебник JS: высший](https://code.mu/ru/javascript/book/supreme/)
- [code.mu - Учебник JS: ООП](https://code.mu/ru/javascript/book/oop/)
- [code.mu - Справочник JavaScript](https://code.mu/ru/javascript/manual/)
- [code.mu - Практика JS](https://code.mu/ru/javascript/book/practice/)
- [webref.ru - Знакомство с JavaScript (2015-2019)](https://webref.ru/dev/learn-javascript)
- [professorweb.ru - Учебник JavaScript](https://professorweb.ru/my/javascript/js_theory/level1/javascript_index.php)

**Видео**

- [IT-Kamasutra - JS в деталях (48 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DN2nTU8Q10SvAn4k8NpMJvh)
- [IT-Kamasutra - Уроки JavaScript с нуля (ну ваще с нуля) (429 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DPD5sRK3lw4bjBsKdgY2bPi)
- [WebDev - JavaScript (15 видео)](https://www.youtube.com/playlist?list=PLNkWIWHIRwMHKLotIS_d-wyj00pg0AnUg)
- [WebDev - ES6 (19 видео)](https://www.youtube.com/playlist?list=PLNkWIWHIRwMGLJXugVvdK7i8UagGQNaXD)
- [code.mu - Видео-уроки JS](https://code.mu/ru/javascript/video/lesson)

**Есть отдельные статьи**

- [Habr.com](https://habr.com/ru/search/?q=javascript)
- [medium.com](https://medium.com/)
- [proglib.io](https://proglib.io/search?q=Javascript)
- [webformyself.com](https://webformyself.com/category/javascriptajax-2/javascriptajax/)

**Прочее**

- [Hexlet - Бесплатный курс JS](https://ru.hexlet.io/courses/js-basics)
- [Официальная спецификация - актуальная (en)](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
- [Официальная спецификация - черновик и предложения (en)](https://tc39.github.io/ecma262)

<br></p>
</details>

[//]: # (Версии JS. Что нового)
<details id="new"><summary><h3>Версии JS. Что нового</h3></summary><p>

[//]: # (ES13 2022)
<details><summary><b>ES13 (june 2022)</b></summary><p>

- Методы `findLast()` и `findLastIndex()` — поиск в массивах «с конца». <br>
  - `findLast()` — возвращает значение последнего элемента в массиве, который удовлетворяет функции тестирования
  - `findLastIndex()` — возвращает индекс последнего элемента в массиве, который удовлетворяет функции тестирования
- Метод `at()` для массивов — обращаться к массивам с конца. И строкам тоже
  - ```js
    const arr = [1, 2, 3, 4]
    arr.at(-2) // 3
  
    const str = "1234"
    str.at(-2) // '3'
    ```
  - ```js
    //Раньше было так
    const arr = [1, 2, 3, 4]
    arr[arr.length - 2] // 3
    arr.slice(-2)[0]    // 3
    ```
- Свойство `cause` у объекта `Error` — причина ошибки.<br>
  - Позволяет указать какая ошибка спровоцировала другую ошибку.
- Оператор `await` можно использовать вне функции (без `async`).<br>
  - Полезно для загрузки модулей динамически или условно?
- Индексы совпадения регулярных выражений
- Метод `Object.hasOwn()` — проверяет: принадлежит ли св-во этому объекту? Или оно унаследовано / не существует?
- Для классов
  - Объявления полей классов
    - Можно напрямую инициализировать значение свойства по умолчанию,
  - Приватные методы и поля класса - добавляем символ~~~~ `#`<br>
    - Недоступны снаружи класса.
  - Проверка существования приватных полей в классе - `in`
  - Статические поля класса и статические приватные методы - `static`<br>
    - Статические методы могут обращаться к другим закрытым/общедоступным статическим членам класса с помощью `this`.
    - Методы экземпляра могут получить к ним доступ с помощью `this.constructor`
  - Статический блок класса - `static`.
    - Выполняются только один раз, при создании класса.

**Ссылки**

- [Habr - 4 важных нововведения в ES2022](https://habr.com/ru/post/651161/)
- https://www.c-sharpcorner.com/article/amazing-new-javascript-features-in-es13/
- https://www.ecma-international.org/publications-and-standards/standards/ecma-262/

<br></p>
</details>

[//]: # (ES12 2021)
<details><summary><b>ES12 (2021)</b></summary><p>

- Логические операторы присваивания `&&=`, `||=`, `??=` — «присвоить если...»<br>
  - `user &&= 'A'` — если user === true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp; *user && (user = 'A')*
  - `user ||= 'A'` — если user === false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp; *if(!user)(user = 'A')*
  - `user ??= 'A'` — если user === null или undefined
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *if(user === null || user === undefined)(
    user
    = 'A')*
- Метод `replaceAll(A, B)` для строк — замена всех подстрок А на B;
- Разделители разрядов `1_000` — для лучшей читаемости. Работает и с BigInt<br>
  - `let num = 152000000` = `let num = 152_000_000`
- Метод `Promise.any` — принимает n промисов и возвращает первый успешно завершившийся<br>
  - `Promise.any([promise1, promise2]).then(val => console.log(val)`
- Объект `AggregateError` — новый тип ошибок.<br>
  - Представить n ошибок в виде одной комбинированной.
  - Например для Promise.any(), если все promises завершились в rejected
- Приватные методы экземпляров классов и доступа к св-вам — префикс `#`. <br>
  - `#`-методы экземпляров классов доступны только изнутри экземпляра
    класса (`class User { #generateAPIKey() {/**/} }`)<br>
  - `#`-методы доступа к свойствам объектов = приватные геттеры и сеттеры (`get #newPass(){}` и `set #newPass(){}`).
- API сборщика мусора
  - `WeakRef  API` — обращение к целевому объекту, которое позволяет корректно обработать его сборщиком
    мусора
  - `FinalizationRegistry API` (финализатор) - управление регистрацией операций очистки, при обработке
    объекта сборщиком мусора;<br>
    Регистрируем callback-«финализатор», он запускается когда сборщик мусора уничтожает объект.
- `Array.prototype.sort` стал более точным.
  - уменьшило количество случаев, которые приводят к сортировке, определяемой реализацией.

<br></p>
</details>

[//]: # (ES11 2020)
<details><summary><b>ES11 (2020)</b></summary><p>

- `BigInt` примитив — работа с целыми числами произвольной длины (длиннее чем 2^53).<br>
  - ```js
    const bigint = 1234567890123456789012345678901234567890n;
    const sameBigint = BigInt("1234567890123456789012345678901234567890");
    const bigintFromNumber = BigInt(10); // то же самое, что и 10n
    ```
- Оператор опциональных цепочек `?` (Optional Chaining Operator)
  - при обращении к свойству объекта сразу проверяем, существует ли оно.
  - ```js
    const obj = {body: {a: 1, b: 2}}
    const value = obj.body?.a
    ```
- `??` оператор нулевого слияния — `(if a === nul || a === undefined)(...)`<br>
  - `const foo = null ?? 'default string'`
- Объект `globalThis` — доступ к глобальному объекту. <br>
  - В Node.js это global, Worker это self, в браузере это window. Если приложение исполняется в N средах — писали
    условия.
  - ```js
    //Раньше
    let global = function () {
      if (typeof self !== 'undefined') {
        return self;
      }
      if (typeof window !== 'undefined') {
        return window;
      }
      if (typeof global !== 'undefined') {
        return global;
      }
      throw new Error('unable to locate global object');
    };
    //Теперь
    GlobalThis == this
    ```
- Динамический импорт — можно импортировать модули в виде промиса
  - ```js
    import('module.js')
      .then(module => {/**/})
      .catch(err => {/**/});
    //Или так
    (async function () {
      const module = await import('module.js')
      /**/
    })();
    ```
- Комбинатор `Promise.allSettled()` — возвращает промис с массивом состояний промисов.<br>
  - Условие выполнения данного промиса — выполнение всех исходных промисов.
  - Все промисы должны быть завершены (с любым статусом).

<br></p>
</details>

[//]: # (ES10 2019)
<details><summary><b>ES10 (2019)</b></summary><p>

- Методы строк `trimStart()` и `trimEnd()` — удаление пробелов в начале/конце строки
- Методы массивов `flat()` и `flatMap()` — рекурсивно сгладить массивы до заданной глубины и вернуть новый массив.
  - Т.е. многомерный массив сделать одномерным.
  - Все элементы подмассива (до указанной глубины) рекурсивно объединяются (`Array.prototype.flat(depth=1)`)
- Метод `Object.fromEntries` — преобразует список пар ключ-значение в объект.
  - Обратное методу `Object.entries`. .
- Переменная в `catch` в выражении `try… catch` теперь не обязательна.
  - `Catch Binding` стал опциональным — теперь не обязательно иметь привязку переменной исключения к оператору catch.
- `Array.sort` — изменения.
  - Теперь гарантировано будет стабильным, что означает, что элементы с одинаковым приоритетом сортировки появятся в
    списке.
- Описание свойства для объектов `Symbol` — при создании Symbol можно добавить описание (для отладки)
  <br>

**Ожидания**
- **JSON** - подкорректированы символы разделителя строк и абзацев
- **JSON.stringify** - представление кодов с помощью escape-последовательностей JSON
- **.toString()** - теперь возвращает точные фрагменты текста исходного кода, включая пробелы и комментарии.
- **import.meta**
- **Строковый метод matchAll()**
- **Стандартизированный Hashbang** для приложений с интерфейсом командной строки (CLI)

**Ссылки**

* [Что нового в JavaScript ES2019](https://m.habr.com/ru/post/439532/)
* [Что нового в JavaScript 2019](https://medium.com/web-standards/es2019-417d8b406346)

<br></p>
</details>

[//]: # (ES9 2018)
<details><summary><b>ES9 (2018)</b></summary><p>

* Оператора `rest` — выглядит как `...`.
  * Извлекать свойства объекта. Используется в левой части выражения.
  * Для литералов объектов
* Оператор `spread` — тоже выглядит как `...`.
  * Для создания новых объектов. Используется в правой части выражения со знаком присваивания.
    Для литералов объектов
* Асинхронная итерация, цикл `for-await-of` — создавать циклы, работающие с асинхронным кодом.
  * Вызывать асинхронные функции, возвращающие промисы (или обрабатывать массивы, содержащие промисы) в цикле.
* Метод `finally()` у объектов Promise — выполнять коллбэк после resolve() или reject().
  * Чтобы корректно завершать операции (например, высвобождая ресурсы).
* Устранение ограничений тегированных шаблонных строк
  * Больше свободы, что писать в шаблонных строках.
  * Раньше \u запускал переход к unicode, \x запускал переход к хекс, а символ \, за которым следовали цифры, обозначал
    переход к восьмеричным значениям. Это делало невозможным создание определенных строк, таких как путь к файлу Windows
    C:\uuu\xxx\111.
* Регулярки.
  * Флаг `dotAll` — изменили настройки регулярок. Чтоб работать в новом формате - устанавливаем спец.
    флаг.
  * Захват именованных групп — позволяет писать регулярные выражения с назначением имён (идентификаторов) для групп.
    Облегчает работу с группами.
  * Ретроспективная проверка — узнать, существует ли некая строка сразу перед некоторой другой строкой.
  * Улучшена поддержка Unicode — можно использовать спец. конструкцию для поиска символов не-латинских
    языков(хинди, греческий...)

**Ссылки**

* [Официальная спецификация (en)](http://www.ecma-international.org/publications/standards/Ecma-262.htm)
* [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)
* [Что нового в ES2018 JavaScript](https://webformyself.com/chto-novogo-v-es2018-javascript/)

<br></p>
</details>

[//]: # (ES8 2017)
<details><summary><b>ES8 (2017)</b></summary><p>

- Конструкция `Async/Await` — асинхронные функции, работают на основе promise
- Методы строк `padStart()` и `padEnd()` — дополнения строк до заданной длины.
  - подставляет заданные символы в начало строки или её конец.
- `Висячие запятые` в параметрах функций — теперь их можно ставить после последнего параметра функции.
- `Разделяемая память` (shared memory) и `атомарные операции` (atomics) — касается ядра JS-движков.
  - Можно самостоятельно управлять памятью, не отдавая выполнение всех аспектов этой задачи JS-движку.
  - Позволяет писать высокопроизводительные параллельные приложения.
- Для Объектов
  - Метод `Object.values()` — возвращает все значения собственных свойств объект. Исключает любые значения прототипов.
  - Метод `Object.entries()` — возвращает массив с ключами и значениями.
  - Метод `Object.getOwnPropertyDescriptors()` — возвращает все сведения для всех св-в объекта. В т.ч. данные о геттерах
    и сеттерах.
    - Можно создавать мелкие копии объектов и клонировать объекты, создавая новые объекты (копируя при этом геттеры и
      сеттеры, кроме прочего).
      - Упрощает выполнение операций с объектами в циклах, или преобразование обычных объектов в Map.

**Ссылки**

* [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/8.0/index.html)
* [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

<br></p>
</details>

[//]: # (ES7  2016)
<details><summary><b>ES7 (2016)</b></summary><p>

- Метод `Array.prototype.includes()` — проверяем есть ли в массиве некий элемент.
- Оператор возведения в степень — `**`. Заменяет `Math.pow()`.

**Ссылки**

* [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/7.0/index.html)
* [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

<br></p>
</details>

[//]: # (ES6 2015)
<details><summary><b>ES6 (2015)</b></summary><p>

- const
- let
- шаблонные строки
- параметры функции по умолчанию
- стрелочный функции
- ? map
- ? spred оператор
- Деструктурирующее присваивание
- Promises (обещания) - объекты, которые помогают выполнять асинхронные операции (запрос API, обработка файлов, загрузка
  изображений и т. д.)

* [Переменные: let и const](https://learn.javascript.ru/let-const)
* [Деструктуризация](https://learn.javascript.ru/destructuring)
* [Функции](https://learn.javascript.ru/es-function)
* [Строки](https://learn.javascript.ru/es-string) - введены шаблоны, улучшена поддержка Unicode, добавлены методы
* [Объекты и прототипы](https://learn.javascript.ru/es-object)
* [Классы](https://learn.javascript.ru/es-class)
* [Тип данных Symbol](https://learn.javascript.ru/symbol) - для создания уникальных идентификаторов
* [Итераторы](https://learn.javascript.ru/iterator) - можно сделать "перебираемым любой" объект
* [Set, Map, WeakSet и WeakMap](https://learn.javascript.ru/set-map) - новые типы коллекций
* [Promise](https://learn.javascript.ru/promise) - способ организации асинхронного кода
* [Генераторы](https://learn.javascript.ru/generator) - новый вид функций. Могут приостанавливать своё выполнение,
  возвращать промежуточный результат и далее возобновлять выполнение позже.
* [Модули](https://learn.javascript.ru/modules) - введён официальный стандрат поддержки модулей в JS
* [Proxy](https://learn.javascript.ru/proxy) - особый объект, перехватывает обращения к другому объекту и, при
  необходимости, модифицирует их.

**Ссылки**

* [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/6.0/index.html)
* [learn.js](https://learn.javascript.ru/es-modern)
* [code.mu](http://code.mu/books/javascript/advanced/novovvedeniya-v-es6-dlya-novichkov.html)
- [Хабр - Обзор базовых возможностей ES6 (2016)](https://habr.com/ru/post/313526/)

<br></p>
</details>

[//]: # (ES5 2009)
<details><summary><b>ES5 (2009)</b></summary><p>

Среди изменений:

* поддержка строгого режима (strict mode);
* аксессоры getters и setters;
* возможность использовать зарезервированные слова в качестве ключей свойств и ставить запятые в конце массива;
* многострочные строковые литералы;
* поддержка JSON
* и ещё очень много всего - 10 лет готовили...

**Ссылки**

* [Официальная спецификация (en)](http://ecma-international.org/ecma-262/5.1/)
* [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
* [ES5 руководство по JavaScript](https://habr.com/ru/post/281110/)
* [Перевод спецификации EcmaScript 5 с аннотациями](https://es5.javascript.ru/)

<br></p>
</details>

[//]: # (История версий JS/ES)
<details><summary><b>История версий JS/ES</b></summary><p>

JS создавался как скриптовый язык для Netscape. 1997 год<br>
Разработкой занимались Брендан Эйх, Марк Андрессен и Билл Джой.<br>
Был отправлен для стандартизации в ассоциацию «ECMA International». Стандартизированная версия называется `ECMAScript`,
описывается стандартом `ECMA-262`.

ECMAScript — стандарт<br>
JavaScript — самая популярная реализация этого стандарта.</br>
Среди других реализаций: SpiderMonkey, V8 и ActionScript.

С 2015 язык обновляется ежегодно.

* ES1 - 1997
* ES2 - 1998
* ES3 - 1999
* ES4 - не выпущена
* ES5 - 2009
* ES6 - 2015
* ES7 - 2016
* ES8 - 2017
* ES9 - 2018
* ES10 - 2019
* ES11 - 2020
* ES12 - 2021
* ES13 - 2022
  *`ES.Next` — динамический термин, автоматически ссылается на новую версию ECMAScript.

**Про обновления**

- Стандарт `ECMAScript` развивается и поддерживается
  ассоциацией [ECMA International](http://www.ecma-international.org/memento/index.html). Есть «Ecma International
  Technical Committee 39» (TC39) — занимается поддержкой и обновлением спецификации `ECMAScript`. Работают с
  синтаксисом, семантикой, библиотеками и сопутствующими технологиями, на которых основан язык.
- Предложения о добавлении новых возможностей анализируются командой «T39». Если одобряются — описания новых
  возможностей переносятся в [черновик](https://tc39.github.io/ecma262), а затем публикуются
  в [спецификации](https://www.ecma-international.org/publications/standards/Ecma-262.htm).
- Разработчики JS-движков сами решают, какие предложения реализовать в первую очередь. Могут заранее добавить поддержку
  функций, которые ещё находятся в черновике. Могут отложить разработку функций, которые уже перенесены в спецификацию.
  Часто в движке (например браузер) реализуется только часть стандарта. Текущее состояние поддержки различных
  возможностей JS можно проверить
  здесь: [https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/)

**Ссылки**

* [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
* [Официальная спецификация - актуальная (en)](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
* [Официальная спецификация - архив (en)](https://www.ecma-international.org/publications/standards/Ecma-262-arch.htm)
* [Разъяснения насчёт JavaScript, ECMA–262, TC39 и транскомпиляторов ECMAScript](https://www.frontender.info/javascript-ecma-262-tc39-and-ecmascript-transpilers-explained/)
* [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

- [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript (2017)](https://tproger.ru/translations/wtf-is-ecmascript/)
- [Wikipedia - ECMAScript(en)](https://en.wikipedia.org/wiki/ECMAScript#12th_Edition_%E2%80%93_ECMAScript_2021)
- [Хабр - Чем отличаются JavaScript и ECMAScript?](https://habr.com/ru/company/nix/blog/342904/)

<br></p>
</details>

<br></p>
</details>

---

[//]: # (Работа движка JS. Окружение)
<details id="engine"><summary><b>Работа движка JS. Окружение</b></summary><p>

***
В паре слов:

- есть `движок` и `окружение`
- в движке конвейер:
  - `парсер` -> `абст. синтакс. дерево` -> `интерпретатор` -> `компилятор`  -> `машинный код`
- код попадает в `очередь`. Упомянуть `микро/макро задачи`, `web workers`
- задачи из очереди по одной уходят в `стэк`
  - стр-ра данных в движке. Стопка тарелок, LIFO
- стек работает синхронно, окружение асинхронно.
- асинхронные операции выполняются в окружении.
  - ждёт нужный момент и ставит задачу в очередь стэка. Дальше всё как обычно.
- всё работает в бесконечном «событийном цикле» `event loop`:
  - `макрозадача 1` -> все `микрозадачи` -> `отрисовка страницы` (рендер) -> `макрозадача 2`

[//]: # (Движок. Окружение / Среда)
<details><summary><b>Движок. Окружение (Среда)</b></summary><p>

`Движок` (JS Engine) — программа для обработки JS кода и конвертирования его в конкретные команды для выполнения.

- v8 (Chrome, Edge, node.js)
- SpiderMonkey (Mozilla)
- JavaScriptCore (фреймворк WebKit, на нём работает Safari)
- Hermes (для React Native, от Facebook)
- JerryScript (суперлегкий движок, используемый для интернета вещей, весит менее 200 КБ - нужно мало памяти на уст-ве).
- Chakra (IE)
- Nitro (старые Safari)

`Окружение / Среда` (JS Run-time Enviroment) — надстройка над движком. <br>

- Chrome
- Firefox
- node.js

Окружение отвечает за создание экосистемы с возможностями, сервисами и поддержкой.<br>
Поддержка Document Object Model, Browser Object Model, CSSOM (спецификация для CSS), ключевых библиотек и т.п.<br>
Окружения определяют различия между браузером и node.js, например. <br>
Используя один и тот же движок v8:

- на `node.js` мы пишем сетевые приложения или обращаемся напрямую к жесткому диску,
- а из `Chrome` перехватываем клики по кнопкам

Все браузеры выполняют JS по-разному, но под капотом, они все работают по одной модели: стэк вызова, куча, event loop,
Web API...

<br></p>
</details>

[//]: # (Парсер, интерпретатор, компилятор)
<details><summary><b>Парсер, интерпретатор, компилятор</b></summary><p>

<img src="/Assets/Img/js-schema-1.png" title="Схема 1" alt="Схема 1" />

Внутри движок устроен как конвейер: `парсер` -> `интерпретатор` -> `компилятор` -> `машинный код`<br>
В разных движках это конвейер устроен по-разному — количество компиляторов, различные оптимизации и т.д.<br>
Но общая схема примерно одна.

Исходный код проходит через `парсер`.<br>
В результате возникает внутреннее представление кода — `абстрактное синтаксическое дерево` (AST).

Дальше работает `интерпретатор`. Их может быть несколько <br>
Он построчно выполняет код программы.<br>
Отдельные функции при исполнении преобразуются в `байт-код` — спец. код для вирутальной машины.<br>
При этом копится статистика использования JS-функций. Если какая-то вызывается часто, её передают `компилятору` для
оптимизации.

`Компилятор` генерирует `машинный код` — 0 и 1, язык самого процессора (очень быстрый).<br>
Машинный код сильно завязан на типы входных значений.

Допустим, есть функция `foo(a, b)` и мы вызываем её много раз с числовыми параметрами `a` и `b`. <br>
В какой-то момент функция будет передана компилятору и станет выполняться быстрее.<br>
Потом вызовем её со строковым аргументом — движок выполнит «деоптимизацию»: вернёт функцию от компилятора
интерпретатору, а готовый машинный код будет выброшен.

`Интерпретатор` просматривает код построчно и выполняет его.<br>
`Компилятор` сначала готовит весь код, потом выполняет.<br>
`Компилятор Just-In-Time` (JIT) — промежуточное положение. Разновидность динамической компиляции. Быстрый и гибкий

<br></p>
</details>

[//]: # (Event loop. Микро- и макро-задачи)
<details><summary><b>Event loop. Микро- и макро-задачи</b></summary><p>

`Event Loop` (Cобытийный цикл) — бесконечный цикл, в котором движок JS ожидает задачи, исполняет их и снова ожидает
появления новых.

Примеры задач:

- Когда загружается внешний скрипт <script src="...">, задача — это выполнение этого скрипта.
- Когда пользователь двигает мышь, задача — сгенерировать событие mousemove и выполнить его обработчики.
- Когда истечёт таймер, установленный с помощью setTimeout(func, ...), задача — это выполнение функции func

Задачи поступают на выполнение – движок выполняет их – затем ожидает новые задачи<br>
Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.

**Микрозадачи**

- Приходят только из кода (не от движений мышкой и т.д.)
- Обычно создаются промисами
  - выполнение обработчика .then/catch/finally,
  - используются «под капотом» await (форма обработки промиса).
- После каждой макрозадачи движок исполняет все задачи из очереди микрозадач.
  - Перед тем, как выполнять следующую макрозадачу, отобразить изменения на странице, или сделать что-то ещё.
  - Это важно — гарантирует, что общее окружение остаётся одним и тем же между микрозадачами. Не изменены координаты
    мыши,
    не получены новые данные по сети и т.п.
- Исполняются непрерывно одна за другой
  - События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются
  - Их можно вызывать если надо запустить функцию асинхронно (после текущего кода), но до отображения изменений и до
    новых событий.
  - Т.е. для асинхронного выполнения функции в том же состоянии окружения
- Длобавление в очередь новой микрозадачи:
  - Используйте `queueMicrotask(f)`.
  - Используйте обработчики промисов.
  - process.nextTick,
  - MutationObserver.

**Макрозадачи**

- Все остальные
- Работают в нормальной очереди (см. выше)
- Добавление в очередь новой макрозадачи
  - `setTimeout(f)` с нулевой задержкой.
    - Этот способ можно использовать для разбиения больших вычислительных задач на части — чтобы браузер мог реагировать
      на пользовательские события и показывать прогресс выполнения этих частей.
    - Также используется в обработчиках событий — для отложенного выполнения действия после того, как событие полностью
      обработано (всплытие завершено).
  - setTimeout
  - setInterval
  - setImmediate
  - ...

**Алгоритм Event loop**

1. Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
2. Исполнить все микрозадачи:
1. Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
3. Отрисовать изменения страницы, если они есть.
4. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5. Перейти к шагу 1.

**Детали**

- Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Изменения в DOM
  отрисовываются только после того, как задача выполнена.
- Блокировка браузера — если задача выполняется долго, браузер предлагает «убить» её. <br>
  Браузер не может выполнять другие задачи, обрабатывать пользовательские события - заблокирован. <br>
  Например в скрипте много сложных вычислений или ошибка «бесконечный цикл».
- `Web workers` — способ исполнить код в другом, параллельном потоке. <br>
  Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.<br>
  Web Workers могут обмениваться сообщениями с основным процессом, но имеют свои переменные и свой событийный цикл.<br>
  Web Workers не имеют доступа к DOM. Основное применение – вычисления. Позволяют задействовать N ядер процессора.

**Ссылки**

- [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
- [learn.javascript.ru -Микрозадачи](https://learn.javascript.ru/microtask-queue)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
- [YouTube - Филипп Робертс: Что за чертовщина такая event loop? (26 мин) Он же?](https://youtu.be/8aGhZQkoFbQ) - Очень
  просто и понятно.
  Рекомендую
- [Habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
- [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
- [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
- [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
- https://habr.com/ru/post/439620/
- https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing

<br></p>
</details>

[//]: # (Стэк вызовов)
<details><summary><b>Стэк вызовов</b></summary><p>

<img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
<br>

<img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />
<br>

`Стек вызовов` — структура данных, хранит информацию о том, какой участок кода сейчас выполняется. Часть движка.<br>
Движок JS линейно и последовательно обрабатывает операции, которые берёт из стека вызовов (1). <br>
Последним пришёл первый вышел. LIFO (last in — first out). Как стопка тарелок.<br>
Удалить операцию из стека нельзя, можно только прервать поток выполнения.<br>
Поток выполнения прерывается, если вызвать что-то типа alert или «исключение».

Стэк используется для хранения контекстов выполнения, создаваемых в ходе работы кода (какой участок кода сейчас
обрабатываем).<br>
Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий
стек. <br>
При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в
верхнюю часть стека.

Движок выполняет функцию, контекст выполнения которой находится в верхней части стека.<br>
Когда работа функции завершается, её контекст извлекается из стека.<br>
Управление передаётся контексту, который находится в предыдущем элементе стека.

<br></p>
</details>

[//]: # (Асинхронность. Очередь вызовов)
<details><summary><b>Асинхронность. Очередь вызовов</b></summary><p>

<img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
<br>

<img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />
<br>

*Cтек вызовов работает синхронно, а web API/Окружение асинхронно!*<br>
*Это очень важно!*

`Окружение` и `JS движок` работают независимо.<br>
Асинхронные операции выполняются не в движке, а в `окружении` (5,6). <br>
**Есть вариант**: *можно из стека вызовов сразу же положить функцию в очередь вызовов. Таким образом чистый движок тоже
будет работать асинхронно.*

Чтобы создать асинхронный вызов, в `окружение` передается ссылка на функцию, которая выполнится позже (или не выполнится
вовсе).

Окружение получает код и само решает, в какой момент передать функцию в `очередь вызовов` (2, queue, «кью»).<br>
По сути, очередь - это часть `стэка`
В очереди вызовов нельзя отменять отдельные операции. Это делается в окружении (removeEventListener — в качестве
примера).<br>

Функции из очереди вызовов попадают в JS-движок, где выполняются по одной. <br>
Выполнение происходит в том же порядке, в котором функции попали в очередь.<br>
Функции из очереди добавляются в стек выполнения (выполняются) не раньше, чем стек вызовов закончит работу над текущей
функцией.<br>

<br></p>
</details>

[//]: # (Функции и контекст)
<details><summary><b>Функции и контекст</b></summary><p>

<img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />
<br>

Каждая операция содержит `контекст` — область памяти, из которой доступны данные.

Контексты расположены в памяти в виде «дерева». <br>
Каждому дочернему контексту («листу» в дереве) доступны области видимости, которые определены в родительских ветках и в
корне (глобальной области видимости). Это достигается за счёт того что в дочернем контексте есть специально
свойство-ссылка на родительский. Поэтому мы можем от любого дочернего контекста найти всех родителей вплоть до корня.

Функции в JavaScript — это данные<br>
Они хранятся в памяти именно как данные и поэтому передаются как переменные или возвращаются из других функций.

У функции есть свой контекст или своя область памяти (3), в которой она определена. <br>
Функция имеет доступ к этой области памяти и ко всем родителям этой области памяти. Такие функции называются
замыканиями. С этой точки зрения, все функции в JavaScript — замыкания, так как все они имеют контекст.

<br></p>
</details>

[//]: # (Картинки)
<details><summary><b>Картинки</b></summary><p>

<img src="/Assets/Img/js-schema-1.png" title="Схема 1" alt="Схема 1" />
<br>

<img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
<br>

<img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />

<br></p>
</details>

**Ссылки**

- [Medium - Движки JavaScript. Часть 1: парсинг](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-%D0%BF%D0%B0%D1%80%D1%81%D0%B8%D0%BD%D0%B3-754a8d60df23)
- [Medium - Движки JavaScript. Часть 2: генерация кода и базовые оптимизации](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-fb66fd238769)
- [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
- [learn.javascript.ru -Микрозадачи](https://learn.javascript.ru/microtask-queue)
- [learn.javascript.ru - Браузерное окружение, спецификации](https://learn.javascript.ru/browser-environment)
- [Habr - Как работает JS (19 статей)](https://habr.com/ru/company/ruvds/blog/337042/)
- [Habr - Знакомство с WebAssembly](https://habr.com/ru/post/342180/)
- [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
- [YouTube - Филипп Робертс: Что за чертовщина такая event loop? (26 мин) Он же?](https://youtu.be/8aGhZQkoFbQ) - Очень
  просто и понятно.
  Рекомендую
- [Habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
- [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
- [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
- [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
- https://habr.com/ru/post/439620/
- https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing
- https://doka.guide/js/async-in-js/

<br></p>
</details>   

[//]: # (Асинхронность в JS todo: упростить)
<details id="asynchrony"><summary><b>Асинхронность в JS</b></summary><p>

***

[//]: # (Однопоточность)
<details><summary><b>Однопоточность</b></summary><p>

JS - однопоточный язык.<br>
Это означает, что только один блок кода может запускаться за раз. Делает одну задачу в один момент времени<br>
С DOM-деревом работают в одном потоке, чтобы гарантировать целостность и непротиворечивость данных. Представьте себе -
два параллельных потока пытаются наперегонки поменять один и тот же узел в DOM... Плохая идея.

<br></p>
</details>

[//]: # (Синхронность)
<details><summary><b>Синхронность</b></summary><p>

Что означает синхронность?<br>
Например: есть 2 строки кода. Первая идет за второй.<br>
Синхронность означает то, что строка 2 не может запуститься до тех пор, пока строка 1 не закончит своё выполнение.

Схема такая:

- функция из очереди попадает в стэк
- выполняется
- стек очищается
- в стек попадает следующая функция из очереди
  <br>

Вариант немного сложнее:

- функция 1 из очереди попадает в стек
- внутри этой функции 1 находится вызов функции 2.
- в стек попадает функция 2
- она выполняется и удаляется
- результат её выполнения записывается в функцию 1
- функция 1 выполняется
- стек очищается
- в стек попадает следующая функция из очереди

<br></p>
</details>

[//]: # (Асинхронность)
<details><summary><b>Асинхронность</b></summary><p>

`Асинхронность` — модель поведения<br>
Есть две строчки кода, первая за второй. Первая строка это инструкция, для которой нужно время. <br>
Первая строка начинает запуск этой инструкции в фоновом режиме. <br>
Второй строка запускается без ожидания завершения первой.

В JS есть возможности асинхронного выполнения кода.<br>
JS однопоточный (выполняет один блок за раз), но мы можем делать несколько действий через асинхронное исполнение
задач.<br>
Для этого и придуманы `асинхронные функции` — выполняются не сразу, а после наступления события.

асинхронное поведение нужно когда что-то тормозит.<br>
Синхронность может быть медленной. Задачи вроде обработки изображений, операций с файлами, создание сетевых запросов и
ожидание ответа — всё это может тормозить и быть долгим. Такие задачи в стеке запросов превращаются в “задержку” (
“blocking”). <br>
Когда стек запросов заблокирован, браузер препятствует вмешательству пользователя и выполнению другого кода до тех пор,
пока “задержка” не выполнится и не освободит стек запросов.<br>
В таких ситуациях используют `асинхронные колбэки` (callback)
Асинхронность позволяет пользовательскому интерфейсу веб-приложений нормально функционировать, реагировать на команды
пользователя.<br>

**Асинхронность с ипользованием коллбэков**

Есть функция `A()`, которая делает долгую операцию (запрос по сети)
Есть функция `B()`, которой надо работать с результатом `A()`.
Просто написать в коде подряд `A(); B();` мы не можем - `B()` начнёт выполняться до того как `A()` получит данные.
Вариант решения: в `A()` вторым параметром передадим `B()`, чтоб `A()` запустила его когда будет готова.

```js 
function A(B) {
  /*Some long work*/
  B();
}
```

В функцию, которая выполняет какие-либо асинхронные операции, передаём аргумент callback — функцию, которая будет
вызвана по завершению асинхронного действия.

**Примеры асинхронности**<br>

- функция `setTimeout()`
- выполнение AJAX-запросов.
  - т.к. ожидание ответа может занять много времени, запросы можно делать асинхронно. Пока клиент ожидает ответа, может
    выполняться код, не относящийся к запросу.

**Разное**

- Система «планирует» нагрузку на цикл событий таким образом, чтобы в первую очередь выполнялись операции, связанные с
  пользовательским интерфейсом.
- Ещё можно использовать `вебворкеры`, но из них нельзя менять DOM или вызывать методы объекта window. <br>
  Полезно, но не для всех случаев. Больше для вычислений

**Ссылки**

- https://habr.com/ru/post/439620/
- https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing
- https://doka.guide/js/async-in-js/
- [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
- [learn.javascript.ru -Микрозадачи](https://learn.javascript.ru/microtask-queue)

<br></p>
</details>

[//]: # (JS движок и Web API)
<details><summary><b>JS движок и Web API</b></summary><p>


Асинхронные функции - не часть JavaScript-движков. Вызов setTimeout на чистом V8 приводит к ошибке, так как в V8 нет
такой функции. Асинхронные операции выполняются не в движке, а в окружении. Например, в Web API браузера.

В принципе, мы можем из стека вызовов сразу же положить функцию в очередь вызовов и таким образом чистый движок тоже
будет работать асинхронно. Но это редкий фокус.

Web API и JS движок работают независимо. Web API решает, в какой момент функция двигается дальше, в очередь вызовов JS
движка. Т.е. окружение самостоятельно решает, когда добавить переданный ей код в очередь вызовов.

Функции в очереди вызовов попадают в JavaScript-движок, где выполняются по одной. Выполнение происходит в том же
порядке, в котором функции попадают в очередь. Функции из очереди добавляются в стек выполнения (выполняются) не раньше,
чем стек вызовов закончит работу над текущей функцией.

*Стек вызовов движка работает синхронно. Web API работает асинхронно.*

В очереди вызовов нельзя отменять отдельные операции. Это делается в окружении (пример: removeEventListener).

<br></p>
</details>

[//]: # (Контекст выполнения функции)
<details id="asynchronyContext"><summary><b>Контекст выполнения функции</b></summary><p>

У каждого вызова функции есть свой «контекст выполнения» (execution context).

Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя
локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.

При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных –
«стеке контекстов».

Специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное
место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в
данном примере) и прочую служебную информацию.

Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

**Ссылки**

- [Habr - Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/company/ruvds/blog/422089/)

<br></p>
</details>

[//]: # (Очередь - queue)
<details><summary><b>Очередь (queue)</b></summary><p>


Очередь — структура данных. Доступа к элементам организован по принципу FIFO (First In — First Out) «первый пришёл —
первый вышел» .

Добавление элемента (обозначают словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из
начала очереди (называют словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется.

<br></p>
</details>

[//]: # (Стэк - stack)
<details><summary><b>Стэк (stack)</b></summary><p>

Стек (анг. стопка) — структура данных (кусок памяти + опр правила работы с ним), представляющая из себя список
элементов. Подобен стопке тарелок - последняя поступившая кладётся сверху, и должна быть обработана, прежде чем начнётся
обработка "тарелки" под ней. LIFO (last in — first out) «последним пришёл — первым вышел»).

Вызов любой функции создает контекст выполнения.<br>
При вызове вложенной функции создается новый контекст, а старый сохраняется в специальной структуре. Так формируется
стек контекстов.

Максимальный размер стэка в в движке V8 16 000 (чего?). По достижению этого размера движок просто очищает стэк, чтоб всё
не зависло.

<br></p>
</details>

[//]: # (Event Loop. Web API)
<details><summary><b>Event Loop. Web API</b></summary><p>

Event Loop (Или цикл обработки событий) и Web API

Web API - часть браузера. Еслив стэк попадает какая-то асинхронная функция, например setTimeout - она передаётся в Web
API. А стэк продолжает работать как обычно, как будто эта функция выполнилась.

Когда придёт время (таймер сработла, или пришёл ответ AJAX) - Web API выдаст функцию обратно. Но не в стэк (чтоб не
нарушить то, над чем стэк работает сейчас) Web API поставит это в очередь выполнения задач.

Event Loop (цикл обработки событий) - смотрит состояние стэка и очереди колбэков. Как только стэк становится пуст -
EventLopp берёт первый Элемент из очереди и передаёт его в стэк. Всё. Никакой магии

Цикл событий решает одну основную задачу: наблюдает за стеком вызовов и очередью коллбэков (callback queue). Если стек
вызовов пуст, цикл берёт первое событие из очереди и помещает его в стек, что приводит к запуску этого события на
выполнение.

Подобная итерация называется тиком (tick) цикла событий. Каждое событие — это просто коллбэк

<br></p>
</details>

[//]: # (Микро и макро-задачи. Microtask и macrotask)
<details><summary><b>Микро и макро-задачи (microtask и macrotask)</b></summary><p>

[//]: # (todo: дополнить. Постоянно спрашивают на собеседованиях!)

На самом деле, очередь задач устроена несколько сложнее, чем написано выше:

- Начиная с EAS6 очередь разбита на
  - `макрозадачи` — очередь коллбеков (callback queue)
  - `микрозадачи` — очередью заданий (job queue, PromiseJobs)
- В одной итерации Event loop обрабатывается
  - **макрозадача** (т.е. классическая задача) из очереди коллбеков. <br>
    Т.е. всё что стояло в очереди обычных задач к этому моменту, например все «обычные», синхронные `console.log()` в
    скрипте.<br>
    Выполнение скрипта - это задача. А если пользователь в это время двинул мышкой - это вторая. Будет поставлена в
    очередь как отдельная макрозадача.
  - **все микрозадачи** из очереди микрозадач - обрабатываются в том же цикле, после макрозадачи. <br>
    Они как-бы «пристраиваются хвостом» к первой макрозадаче. <br>
    «Очередь заданий» (микрозадачи) присоединена к концу каждого «тика» в очереди цикла событий. <br>
    Эти микрозадачи могут добавлять в очередь другие микрозадачи. Процесс будет продолжаться, пока очередь микрозадач не
    опустеет. Т.е. до запуска следующей макрозадачи может пройти довольно много времени. Может привести к зависанию
    интерфейса.<br>
    В ECMAScript микрозадачи называют «заданиями» («jobs»).<br>
    Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.
  - *ререндер* экрана браузера. Эти события происходят около 60 раз в секунду.<br>
    Именно для того, чтоб их пропустить, рекомендуется не занимать стек большой синхронной задачей, а разбить её на
    асинхронные (например через `setInterval(callback,0)`).

Очередность

- вначале в стеке выполнятся текущие макрозадачи (например, все console.log). Пока стек не очистится.
- если в коде макрозадачи попалось что-то асинхронное (setTimeout, например) - эта асинхронная часть «выбрасывается» в
  среду, там ждёт момента выполнения (пока таймер истечёт, или придёт ответ с сервера), когда момент настал - опять
  встаёт в очередь, как обычная макрозадача
- потом из очереди микрозадач выполнятся все микрозадачи (например, обработчики промисов + те микрозадачи, которые они
  вызывают
  внутри себя)
- потом выполнится задача рендера (это макрозадача, по приоритету она ниже микрозадач)
- потом из очереди макрозадач выполнятся следущие макрозадачи

**Промисы**

Код в промисе выполняется по общим правилам.<br>
Если там синхронный код, то синхронно. Если асинхронный (timeout, например) — асинхронно.

А вот обработчики промисов (`.then`, `.catch`, `.finally`) всегда асинхронны!<br>
Даже если промис выполняется сразу (не содержит в себе асинхронной задачи), вначале выполнится код расположенный ниже
чем блоки `.then`, `.catch` `.finally`.<br>
Когда промис выполнен, его обработчики (`.then`, `catch`, `finally`) попадают в очередь микрозадач. Они пока не
выполняются. Движок
JS берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода (макрозадачи).

```js
console.log('Start');

setTimeout(function timeout() {
  console.log('Timeout');
}, 0);

const promise = new Promise(function (resolve, reject) {
  console.log('Promise'); // Выполянется как обычный синхронный код
  resolve(true);
});

promise.then(function () {
  console.log('Then'); // Очередь микрозадач
});

console.log('End');

// Вывод:
// - Start
// - Promise
// - End
// - Then
// - Timeout
```

Второй пример, Promise выполняется позже console.log:

```js
console.log('Start');

setTimeout(function timeout() {
  console.log('Timeout');
}, 0);

//В стэке отрабатывает resolve, и отправляет .then в очередь микрозадач
Promise.resolve().then(function () {
  console.log('Then');
})

console.log('End');

// Вывод:
// - Start
// - End
// - Then
// - Timeout
```

Макрозадачи планируются с помощью

- setTimeout
  - часто используют с нулевой задержкой, для разбиения больших вычислительных задач на части, чтобы браузер мог
    реагировать на пользовательские события и показывать прогресс выполнения этих частей.
  - Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью
    обработано (всплытие завершено).
- setInterval
- setImmediate
- ...

Микрозадачи

- выполнение обработчика промиса - `.then`,`catch`, `finally`
- используется в `await` (форма обработки промиса)
- функция `queueMicrotask(func)` — помещает func в очередь микрозадач. <br>
  Если хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений на экране (ререндер) и до
  новых событий (клик мыши и т.д.) — можно запланировать выполение через `queueMicrotask()`.
- process.nextTick,
- MutationObserver.

При исполнении любого файла JS-движок конвертирует содержимое в функцию и ассоциирует её с событием start или launch.
Движок инициализирует стартовое событие и добавляет события в очередь как макрозадачи.

Начиная обработку, движок JS выбирает первую макрозадачу из очереди и выполняет обработчик обратного вызова:

Микрозадачи обычно планируются для вещей, который должны исполняться моментально после текущего исполняемого сценария.
Например, реагирование на пачку действий или для того, чтобы сделать что-то асинхронно без необходимости терять
производительность на пустом месте из-за полностью новой задачи. Очередь микрозадач развёртывается в конце каждой полной
задачи, а также после колбеков в случае если никакой другой JavaScript не находится на стадии исполнения. Любые
дополнительные микрозадачи, поставленные в очередь во время развёртывания очереди микрозадач, добавляются в конец
очереди и тоже обрабатываются. Микрозадачи включают в себя колбеки Mutation observer и промисов, как в примере выше.

Как только промис решается или если он уже был решён, он ставит в очередь микрозадачу на исполнение колбека. Это даёт
уверенность, что колбеки промисов исполняются асинхронно даже если они уже решены.

**Async/await**

Сама по себе async-функция обработается по обычным правилам.<br>
А вот ключевое слово `await` в ней — поставит код «на паузу».<br>
Интерпретатор JS будет ждать, пока промис справа от `await` не выполнится.<br>
После чего оно вернёт его результат, и выполнение кода продолжится.

Ключевое слово `await` говорит движку JS приостановить код в этой строке, не блокируя остальной код скрипта за пределами
асинхронной функции.

Вроде это должно работать как обычный `.then`

- Это просто «синтаксический сахар» для получения результата промиса, аналог `promise.then`.
- Хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора.
- Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события
  и т.п.

`Await` ставит код «на паузу» — все останавливается, пока не отработает асинхронный код (промис) в `await`.
Слово `await` сообщает что:

- мы должны дождаться выполнения асинхронной функции
- не помещать ее в event loop, а выполнить прямо здесь.

Это значит, что при вызове функции перед которой стоит async - эта функция попадет в очередь контекстов и будет
исполнена.<br>
Но следующий контекст будет ждать, пока текущий завершится. <br>
Все пользовательские события, таймеры и прочие помещаемые в очередь контексты будут ждать, пока не закончатся
асинхронные await-задачи внутри async-функции.

Вроде так.

**Ссылки**

- https://habr.com/ru/post/264993/
- https://refaq.ru/voprosy/raznicza_mezhdu_mikrozadachej_i_makrozadachej_v_kontekste_czikla_sobytij
- [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
- [learn.javascript.ru - Микрозадачи](https://learn.javascript.ru/microtask-queue)

<br></p>
</details>

[//]: # (Куча - heap)
<details><summary><b>Куча (heap)</b></summary><p>

Динамически распределяемая память. Часть JS-движка. Также как и стэк

<br></p>
</details>

[//]: # (Web API's)
<details><summary><b>Web API's</b></summary><p>

Расширения браузера. не входят в состав движка JS.
Но, в движке есть возможность взаимодействовать с этими API

setTimeout, DOM, AJAX (XMLHttpRequest), геолокация, аудио, видео...

<br></p>
</details>

[//]: # (setTimeout )
<details><summary><b>setTimeout(callback(), 0)</b></summary><p>

Позволяет запланировать что-то сразу после выполнения основного кода<br>
Выполнить что-то как только стэк очистится. Т.е. в текущем потоке кода этот колбэк не запускается, и код идёт так, будто
setTimeout и его содержимого просто нет (на самом деле он вылетает из стэка в WebAPI, И оттуда сразу же встаёт в
очередь). А когда этот кусок кода закончится и стэк станет пустым - вот тогда выполнится колбэк из SetTimeout

SetTimeout гарантирует минимальную задержку.<br>
Код выполнится не раньше, чем через Х секунд. <br>
По прошествии Х он встанет в очередь и будет ждать пока:

- очистится стэк,
- освободится очередь перед кодом из таймера.

```js
console.log('1')
setTimeout(function foo() {
  console.log('2')
}, 0)
console.log('3')

//Выведет в консоль:
1
3
2
  ```

<br></p>
</details>

[//]: # (setInterval)
<details><summary><b>setInterval()</b></summary><p>

Предположим, мы кликнули мышью и в процессе этого ещё запсутили setInterval.

Пока обработчик клика мышью выполняется, срабатывает первый interval-callback. Он будет поставлен в очередь. <br>
Когда снова сработает interval, то он будет удален из очереди. Если бы все interval-callback'и попадали в очередь пока
исполняется большой кусок кода, это бы привело к тому, что образовалась бы куча функций, ожидающих вызова без периодов
задержек между окончанием их выполнения. Вместо этого браузеры стремятся ждать пока не останется ни одной функции в
очереди прежде чем добавить в очередь еще один setInterval.

<br></p>
</details>

[//]: # (Browser events)
<details><summary><b>Browser events</b></summary><p>

Какие же события происходят в браузере? Их великое множество: - клики мышкой; - скроллинг; - ввод с клавиатуры; -
загрузка скриптов; - CSS анимации; - и тд.

Браузер может реагировать на эти события. Для этого событию нужно назначить обработчик, то есть функцию, которая
сработает, когда событие произошло. Функция выполнится не сразу, она станет в конец очереди событий и выполнится, когда
придёт её время.

<br></p>
</details>

[//]: # (Unsorted)
<details><summary><b>Unsorted</b></summary><p>

Движок браузера выполняет JavaScript в одном потоке. Он не может поставить обработку события на паузу, переключиться на
другое событие, а после — возобновить выполнение первого. Все события обрабатываются последовательно и каждое — до
победного конца.

Для вышеописанного потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные)
вызываемых функций.

Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать
событие из очереди. Координирование этого процесса и происходит в event loop.

***

Любые данные от сервера запрашиваются асинхронно: отправляется запрос (XMLHttpRequest или XHR), и код не ждет его
возвращения, продолжая выполняться. Когда же сервер, наконец, отвечает, объект XHR получает уведомление об этом и
запускает функцию обратного вызова — callback, который передали в него перед отправкой запроса.

***
В любой момент времени выполняется только один контекст функции (тело функции). Вот почему JavaScript является
однопотоковым, так как единовременно может выполняться только одна команда. Обычно браузеры поддерживают этот контекст с
помощью стека — stack. Стек — структура данных, выполняемая в обратном порядке: LIFO — «последним пришёл — первым
вышел». Последнее, что вы добавили в стек, будет удалено первым из него. Это происходит из-за того, что мы можем только
добавить или удалить элементы из верхушки стека. Текущий или «выполняющийся» контекст исполнения — всегда верхний
элемент стека. Он выскакивает из стека, когда код в текущем контексте полностью разобран, позволяя следующему верхнему
элементу стека взять на себя контекст выполнения.

Кроме того, если контекст уже выполняется, это не означает, что ему нужно завершить своё выполнение, прежде чем другой
контекст выполнения сможет начать работу. Бывают случаи, когда контекст приостанавливается и другой контекст начинает
работу. Прерванный контекст может быть позже забран обратно наверх в том месте, где он был приостановлен. В любое время
один контекст может быть заменён другим, и этот новый контекст поместится в стек, став текущим контекстом выполнения.

***

У динамических языков программирования существует стековая архитектура — stack-based implementations, локальные
переменные и функции хранятся в стеке. Поэтому, во время выполнения стека, программа определяет какую переменную вы
имеете в виду. С другой стороны, статическая область видимости — это когда переменные ссылаются на контекст и
фиксируются на момент создания. Другими словами, структура исходного кода программы определяет к каким переменным вы
обращаетесь.

***
Для лучшего понимания асинхронности неплохо разобраться с тем, как устроен рантайм (браузер или Node.js) JavaScript.
JavaScript изначально появился в браузерах, и к нему предъявлялись особые требования, из-за которых он кардинально
отличается от остальных языков программирования. Браузер работает по так называемой событийной модели. Он загружает
страницу и ждёт действий от пользователя: клики, набор текста или движение мышкой. А код, загруженный на страницу,
реагирует на эти события.

Такая организация взаимодействия невозможна в синхронном коде, у которого есть понятия "запуск" и "завершение" работы.
Код в браузере не может завершиться совсем, он проходит стадию инициализации, а затем ждёт событий для реакции на них.
Технически это выглядит, как колбек, который соединён с определённым типом события. Когда событие срабатывает, то колбек
вызывается.

<br></p>
</details>

[//]: # (Картинки)
<details><summary><b>Картинки</b></summary><p>

<img src="/Assets/Img/js-schema-1.png" title="Схема 1" alt="Схема 1" />
<br>

<img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
<br>

<img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 3" alt="Схема 3" />

<br></p>
</details>

**Ссылки**

- [YouTube - Как на самом деле работает EventLoop (26 мин)](https://youtu.be/8cV4ZvHXQL4) - Очень просто и понятно.
- [YouTube - Филипп Робертс: Что за чертовщина такая event loop? (26 мин) Он же?](https://youtu.be/8aGhZQkoFbQ) - Очень
  просто и понятно.
  Рекомендую
- [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
- [Medium - Движки JavaScript. Часть 1: парсинг](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-%D0%BF%D0%B0%D1%80%D1%81%D0%B8%D0%BD%D0%B3-754a8d60df23)
- [Medium - Движки JavaScript. Часть 2: генерация кода и базовые оптимизации](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-fb66fd238769)
- [Habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
- [Habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
- [Habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
- [learnjavascript - Управление памятью в JavaScript](https://learn.javascript.ru/memory-management)
- [learn.javascript.ru (en)](https://javascript.info/async-await)
- [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
- [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
- [Стеки и очереди в JavaScript](http://shuvalov.info/2013/03/21/stack-and-queue/)
- [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
- [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
- [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
- [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://habr.com/ru/company/ruvds/blog/340508/)
- [Как эмулировать многопоточность в JavaScript](https://tproger.ru/translations/js-engine-macrotasks-microtasks/)
- [pythontutor - как работает JS код](http://pythontutor.com/javascript.html#mode=display)
- [learnjavascript - Про события и асинхронность](https://learn.javascript.ru/events-and-timing-depth)
- [Замыкания в JavaScript](https://htmlacademy.ru/blog/useful/javascript/lets-learn-javascript-closures)
- [Ад обратных вызовов](http://callbackhell.ru/)
- [Асинхронное программирование: концепция, реализация, примеры](https://proglib.io/p/asynchrony/)
- https://doka.guide/js/async-in-js/

<br></p>
</details>   

[//]: # (Use strict)
<details id="useStrict"><summary><b>Use strict</b></summary><p>

ES5 (2009)<br>
Добавлен для обратной совместимости - чтоб старые программы работали корректно.<br>
Его надо включать вручную, прописать `"use strict"` в начале скрипта или функции.<br>
Выше `"use strict"` можно писать только комментарии.

В строгом режиме:

- Нельзя `использовать необъявленные переменные`. И объекты.
  - Раньше неправильный ввод имени переменной создавал новую глобальную переменную. Теперь это вызовет ошибку.
- Нельзя `удалять переменные, объекты или функции`.
- Нельзя `удалять свойства`, которое невозможно удалить.
- Нельзя `дублировать имя параметра`
- Нельзя `присваивать значения св-вам read-only` (недоступным для записи).
  - Запись в свойства "read-only" / "get-only", несуществующие св-ва, объекты или переменные — вызовет ошибку
- Запрет `восьмеричной системы счисления` — восьмеричные числовые литералы и escape-символы не допускаются:
- Нельзя называть переменные словами `eval`, `arguments`,`with `,` `
- Зарезервированы слова: `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`
  и `yield`.
  - Нельзя задействовать эти слова для именования или обращения к переменным или аргументам.
- `eval()` запрещенно создавать переменные в области, из которой он был вызван (по соображениям безопасности)
- Ключевое слово `this` в функции ведет себя иначе.
  - Относится к объекту, который вызвал функцию. Если объект не указан,
    функции в строгом режиме вернут, undefined, а функции в нормальном режиме вернут глобальный объект (окно):

В «классах» и «модулях» строгий режим включён автоматически.<br>
Поэтому в них нет нужды добавлять директиву "use strict".

Объединение скрипта в строгом режиме со скриптом в обычном выглядит как скрипт в строгом режиме!<br>
Справедливо и обратное: объединение обычного скрипта со строгим выглядит как нестрогий скрипт.

**Ссылки**

- [learn.javascript.ru - Строгий режим](https://learn.javascript.ru/strict-mode)
- [MDN - Строгий режим](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode)
- [Schoolsw3 - JavaScript - Строгий режим](https://www.schoolsw3.com/js/js_strict.php)
- [learn.javascript.ru - Eval](https://learn.javascript.ru/eval)
- [learn.javascript.ru - Модули](https://learn.javascript.ru/modules-intro)

<br></p>
</details>

[//]: # (Типы данных)
<details id="types"><summary><b>Типы данных</b></summary><p>

- Примитивы
  - Boolean
  - String
  - Number
  - BigInt - целые числа произвольной длины
  - Symbol - уникальные идентификаторы(ES6)
  - Null - преднамеренное отсутствующее значение. 'typeof' === Object. Ошибка языка
  - Undefined - неинициализированное значение (не было изначально)
- Object
  - Массивы
  - Функции - 'typeof' выдаст function. но это объект
  - Даты
  - RegExp - регулярные выражения
  - Ошибки - несколько встроенных типов (конструктор Error создаёт объект ошибки)
  - все структуры которые создаются с ключевым словом `new`: Map, Set, WeakMap, WeakSet, Error...

**Преобразование логическое**

- `false` = пустая строка, 0, null, NaN, undefined
- `true` = все остальное

**Undefined, null, NaN**

- undefined — значение переменной, которая не была инициализирована. Единственное значение типа Undefined. Глобальная
  переменная.
- null — умышленно созданный «пустой» объект. Единственное значение типа Null. Зарезервированное слово
- NaN — спец. значение типа Number, для выражения «не чисел», «неопределенности». Переменная глобального контекста (
  объекта window).
  - например - результат деления 0 на 0, parseInt('неприводимая к числу строка'), Math.sqrt(-1)...
  - деление других чисел на 0 — это бесконечность, для которой в JS есть значения Infinity.

- Странности
  - С чем бы мы ни сравнивали `NaN`, результатом сравнения всегда будет `false`.
  - Оператор `typeof` говорит что тип необъявленной переменной — `undefined`, но при обращении к ней происходит ошибка.
    - Т.к. необъявленная (Undeclarated) переменная ещё не существует.
    - Если переменная объявлена, но не инициализирована (её не присвоено значение) — такой ошибки не будте
  - Можно читать и записывать значение `undefined` => кто-то может перезаписать его и сравнение с undefined будет
    некорректным.
    - Т.к. undefined — это не только значение undefined типа Undefined, но и глобальная переменная. Её можно
      переопределить.
  - `null` мы перезаписать не можем. Язык даёт перезаписать `undefined`, но не даёт перезаписать `null`.
    - Это не глобальная переменная, а зарезервированное слово, его перезаписать нельзя
  - При переопределении undefined всё прошло успешно, при переопределении null возникла ошибка, а при переопределении
    NaN операция не вызвала ошибки, но свойство не было переопределено.

- Советы
  - Не использовать булевы операторы с NaN. Для проверки нужно использовать функцию `isNaN`.
  - Перед обращением к переменной проверять что она объявлена. При обращении к необъявленной (Undeclared) переменной —
    ошибка.
  - Не сравнивать переменные с `undefined` — кто-то мог перезаписать глобальную переменную undefined и сравнение будет
    некорректным. Лучшее решение: сравнивать не значение переменной, а её тип (`typeof a === 'undefined'`).

**Ссылки**

- [Habr - Подводные камни JavaScript](https://habr.com/ru/post/159313)
- [doka - Преобразование типов ](https://doka.guide/js/typecasting)

<br></p>
</details>

[//]: # (Значения и ссылки)
<details id="objectReference"><summary><b>Значения и ссылки</b></summary><p>

Примитивы при присваивании переменных копируются целиком - `по значению`. Boolean, string, numbers, bigInt, symbol,
null, undefined

```js
  var message = "Привет!";
var phrase = message;
// Две независимые переменные, каждая хранит значение "Привет!"
// Изменение `message` никак не влияет на `phrase`
```

Объекты (в том числе массивы и функции) копируются `по ссылке`.<br>
В переменной, которой присвоен объект, хранится не сам объект, а «ссылка» на него (адрес его места в памяти).

Если есть две переменные с одной и той же функцией - в них не лежат копии этой функции!<br>
Обе эти переменные ссылаются на одну и ту же функцию:

```js
function func() {
  alert('!');
};

var test = func; //И `test` и `func` указывают на одну и ту же функцию. Изменим одну - изменится и вторая
``` 

**Ссылки**

- [learn.javascript.ru - Копирование объектов и ссылки](https://learn.javascript.ru/object-reference)
- [TOП-12 JavaScript-концепций: от ссылок до асинхронных операций](https://proglib.io/p/js-concepts/)
- [Передача параметров по значению и по ссылке](https://metanit.com/web/javascript/3.7.php)
- [Habr - Функции в Javascript: ссылки и вызовы](https://habr.com/ru/sandbox/18362/)

<br></p>
</details>

[//]: # (Что является объектом в JS?)
<details id="whatIsObject"><summary><b>Что является объектом в JS?</b></summary><p>
  
**Объекты**

- собственно объекты (логично)
- массивы
- функции
- RegExp
- все структуры которые создаются с ключевым словом `new`: Map, Set, WeakMap, WeakSet...

**Не совсем объекты**

- у String, Number, Boolean можно вызывать некоторые методы объектов, например `str.length` — в памяти временно
  создаётся объект

**Не объекты**

- Null — значение не определено. 'typeof' выдаст Object. Ошибка языка
- undefined — неинициализированное значение (не было изначально)
-
- BigInt — какие-то методы есть, может и такой же вариант как у String, Number, Boolean
- Symbol — какие-то методы есть, может и такой же вариант как у String, Number, Boolean

<br></p>
</details>

[//]: # (Symbol todo: упростить)
<details id="symbol"><summary><b>Symbol</b></summary><p>

ES6 (2015)

**Определения**

- уникальный идентификатор.
- примитивный тип данных, экземпляры которого уникальны и неизменяемы.
- Уникальное и иммутабельное примитивное значение, которое может быть использовано как ключ для свойства объекта.

Единственное разумное использование — сохранить символ, а затем использовать сохранённое значение для создания свойства
объекта.

```js
var myPrivateMethod = Symbol();
this[myPrivateMethod] = function () {
  //...
};
```

Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Symbol — уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств
объектов.<br> Символьный объект (анг. symbol object) — это объект-обёртка (англ. wrapper) для примитивного символьного
типа.

Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то
следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в
качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

Символы имеют два основных варианта использования:

- «Скрытые» свойства объектов.<br>
  Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать
  символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно
  обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о
  нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.<br>
  Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.
- Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать
  их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать
  Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью
можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который возвращает
все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и
синтаксических конструкций не используют эти методы.

Когда символ используется как идентификатор в присваивании свойства, свойство (например, символ) является анонимным; а
также не исчислимым. Поскольку свойство не исчислимо, оно не будет отображаться в цикле «for (... in ...)», и поскольку
свойство является анонимным, оно не будет отображаться в массиве результатов "Object.getOwnPropertyNames ()". Доступ к
этому свойству можно получить с помощью исходного значения символа, создавшего его, или путём итерирования в массиве
результатов «Object.getOwnPropertySymbols ()». В предыдущем примере кода доступ к свойству будет осуществляться через
значение, которое было сохранено в переменной myPrivateMethod.

При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

```js
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");
```

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут
разные символы. Описание – это просто метка, которая ни на что не влияет.

Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из
других частей программы. Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить
к ним идентификаторы. Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не
следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд
ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем. Кроме того, предположим,
что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект user. Этот скрипт может
быть какой-то JavaScript-библиотекой, абсолютно не связанной с нашим скриптом. Сторонний код может создать для этого
свой символ Symbol("id"). Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже
если их имена совпадают.

Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные
скобки.

```js
let id = Symbol("id");
let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
```

Символы не преобразуются автоматически в строки

Символы игнорируются циклом for…in

**Глобальные символы**

существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении
нам гарантированно будет возвращаться один и тот же символ. Когда надо чтоб символы с одинаковыми именами были одной
сущностью. Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то
же свойство.

Символы, содержащиеся в реестре, называются глобальными символами. Если вам нужен символ, доступный везде в коде –
используйте глобальные символы.

**Системные символы**
Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы
настраивать различные аспекты поведения объектов.

Эти символы перечислены в спецификации в таблице Well-known symbols:

- Symbol.hasInstance
- Symbol.isConcatSpreadable
- Symbol.iterator
- Symbol.toPrimitive
- …и так далее.

В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к
примитиву. Мы скоро увидим его применение.

***

- создавать уникальные ключи
- Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из
  других частей программы.
- Символы не преобразуются автоматически в строки
- Если мы хотим использовать символ при литеральном объявлении объекта {...} , его необходимо заключить в квадратные
  скобки.
- Символы игнорируются циклом for…in
- Object.assign , в отличие от цикла for..in , копирует и строковые, и символьные свойства:
- Глобальные символы
  - Когда хотим чтоб символы с одинаковыми именами были одной сущностью
  - существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом
    обращении нам гарантированно будет возвращаться один и тот же символ.
- Для глобальных символов, кроме Symbol.for(key) , который ищет символ по имени, существует обратный метод:
  Symbol.keyFor(sym) , который, наоборот, принимает глобальный символ и возвращает его имя.
- Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы
  настраивать различные аспекты поведения объектов.
- Эти символы перечислены в спецификации в таблице Well-known symbols :
  - Symbol.hasInstance
  - Symbol.isConcatSpreadable
  - Symbol.iterator
  - Symbol.toPrimitive
  - …и так далее.
- В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к
  примитиву
- примитивный тип данных, использующийся для создания уникальных идентификаторов.
- Символы создаются вызовом функции Symbol() , в которую можно передать описание (имя) символа.
- Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны,
  то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в
  качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.
- Символы имеют два основных варианта использования:
  1. «Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или
     библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in
     , так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением,
     так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или
     использования. Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не
     должны.
  2. Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.* . Мы можем
     использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем
     использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и
     так далее.

  - Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj)  – с его
    помощью можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj)  ,
    который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны.

**Ссылки**

- [MDN - Symbol](https://developer.mozilla.org/ru/docs/conflicting/Web/JavaScript/Reference/Global_Objects/Symbol)
- [MDN - Типы данных JavaScript и структуры данных](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)
- [learn.javascript.ru](https://learn.javascript.ru/symbol)
- [MDN - Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
- [Habr - Особенности использования типа данных Symbol в JavaScript](https://habr.com/ru/company/ruvds/blog/444340/)

<br></p>
</details>

[//]: # (Методы примитивов)
<details id="primitiveMethods"><summary><b>Методы примитивов</b></summary><p>

  ***

Конструкторы String/Number/Boolean предназначены только для внутреннего пользования!<br>
Категорически не рекомендуется самому вручную использовать конструкторы вроде `new Number(100)`.

`null` и `undefined` не имеют «объектов-обёрток», не имеют методов.

Когда создаётся объект-обёртка (на примере Number):

- если применить к числу эти методы — `(5).toFixed(3)`
- если вызвать на числе конструктор new Number() — `let num = new Number(100) // typeof num === object`

[//]: # (Boolean)
<details><summary><b>Boolean</b></summary><p>

- `valueOf()` — возвращает примитивное значение (primitive) настоящего объекта Boolean.
  - ```js
    let a = new Boolean(true);
    console.log( a ); // [Boolean: true]
    console.log( typeof a ); // object
    
    let a2 = a.valueOf();
    console.log( a2 );  // true
    console.log( typeof a2 ); // boolean
    ```
- `toString` — возвращает строку "true" или "false" в зависимости от значения объекта.
- Унаследованные из Function: `apply`, `call`, `toSource`, `toString`.

- [betacode.net - Руководство ECMAScript Boolean](https://betacode.net/12197/ecmascript-boolean)
- [MDN - Boolean](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean#methods)

<br></p>
</details>

[//]: # (String)
<details><summary><b>String</b></summary><p>

- `repeat()` — создать строку путем многократного повторения другой строки
- `indexOf()` — поиск подстроки в строке. Вернёт индекс первого вхождения подстроки
- `lastIndexOf()` — поиск подстроки в строке. Вернёт индекс последнего вхождения подстроки
- `includes()` — содержит ли строка опр. подстроку.
- `search()`— содержит ли строка указанное значение или регулярное выражение. Возвращает индекс начала совпадения.
- `substr()` — извлекает часть строки указанной длины. Устаревший метод
- `substring()` — извлекает символы из строки между двумя указанными индексами.
- `slice()` — извлекает часть строки и возвращает новую строку. Почти идентичен `substring()`, но немного «глупее»
- `toLowerCase()` — перевод символов в нижний регистр
- `toUpperCase()` — перевод символов в верхний регистр
- `charAt()` — получить определенный символ в строке по индексу
- `charCodeAt()` — получить определенный символ в строке по индексу
- `trim()` — удаление начальных и концевых пробелов в стоке
- `trimStart()` — удаляет пробел с начала строки
- `trimEnd()` — удаляет пробел с конца строки
- `trimLeft()` — удаляет пробел с левой части строки
- `trimRight()` — удаляет пробел с правой части строки
- `concat()` — объединяет две и более строк. Возвращает одну объединённую.
- `replace()` — заменяет первое вхождение одной подстроки на другую (заменяет только первое вхождение подстроки)
- `replaceAll()` — позволяет заменить все вхождения подстроки:
- `split()` — разбивает строку на массив подстрок по опр. разделителю
- `startsWith()` — возвращает true, если строка начинается с определенной подстроки.
- `endsWith()` — возвращает true, если строка оканчивается на определенную подстроку.
- `padStart()` — растянуть строку на N символов и заполнить строку слева.
- `padEnd()` — растянуть строку на N символов и заполнить строку справа.
- `join()` — Склеить массив строк в одну. **Метод массива!**
-
- `String.fromCharCode()` — Возвращает строку, созданную из указанной последовательности значений Юникода.
- `String.fromCodePoint()` — Возвращает строку, созданную из указанной последовательности кодовых точек Юникода.
- `String.raw()` — Возвращает строку, созданную из сырой шаблонной строки.
- Унаследованные из Function: `apply`, `call`, `toSource`, `toString`.
-
- Свойства
  - length указывает на длину строки
  - arity, caller, constructor, length, name
-
- [Шпаргалка - методы строк](https://tproger.ru/articles/metody-strok-v-javascript-shpargalka-dlja-nachinajushhih/)
- [Mentanit - Строки, объект String и его методы](https://metanit.com/web/javascript/6.1.php)
- [Дока - Обёртка String](https://doka.guide/js/string-wrapper/)
- [MDN - String](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String#methods)

<br></p>
</details>

[//]: # (Number)
<details><summary><b>Number</b></summary><p>

- `Number.isNaN()` — проверить значение на NaN
- `Number.isFinite()` — true это число, false если специальное значение или нечисловой тип
- `toString()` — преобразует число в строку в указанной системе счисления.
- `toFixed()` — преобразует число в строку с указанным количеством знаков после запятой. Округляет. Возвращает строку.
- `toLocaleString()` — преобразует число в строку, учитывая локаль пользователя
-
- Если надо вызвать методы на целом числе `5`:
  - `(5).toFixed(3)`
  - `5..toFixed(3)`
-
- Обёртка хранит полезные константы:
  - `Number.MAX_SAFE_INTEGER` — максимально возможное целое значение числового типа, 253-1.
  - `Number.MIN_SAFE_INTEGER` — минимально возможное целое значение числового типа, -253-1.
  - `Number.MAX_VALUE` — максимально большое число, представимое с помощью числового типа.
    - Больше, чем Number.MAX_SAFE_INTEGER, из-за особенностей хранения чисел с плавающей точкой.
  - `Number.MIN_VALUE` — минимальное положительное число, представимое с помощью числового типа.
-
- [Дока - Обёртка Number](https://doka.guide/js/number-wrapper/#formatirovanie-chisla)
- [MDN - Number](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number#methods)

<br></p>
</details>

[//]: # (BigInt)
<details><summary><b>BigInt</b></summary><p>

- `asIntN()` — оборачивает BigInt в пределах от -2width-1 до 2width-1-1
- `asUintN()` — оборачивает a BigInt в пределах от 0 до 2width-1
- `toLocaleString()` — возвращает строку с языкозависимым представлением числа. Переопределяет метод
  Object.prototype.toLocaleString().
- `toString()` — возвращает строку, представляющую указанный объект по указанному основанию системы счисления.
  Переопределяет метод Object.prototype.toString().
- `valueOf()` — возвращает примитивное значение указанного объекта. Переопределяет метод Object.prototype.valueOf().

- [MDN - BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0)

<br></p>
</details>

[//]: # (Symbol)
<details><summary><b>Symbol</b></summary><p>

- `for(key)` — ищет существующие символы по заданному ключу и возвращает его (если нашёл). Иначе создаёт новый символ
  для данного ключа в глобальном реестре символов.
- `keyFor(sym)` — получает по разделяемому символу его ключ из глобального реестра символов.
- `toString()` — Возвращает описание символа в виде строки.
- `valueOf()` — Возвращает примитивное значение символьного объекта.

Свойства

- `asyncIterator` — возвращает асинхронный итератор по умолчанию.
- `hasInstance` — определяет, распознает ли объект конструктора объект как свой инстанс.
- `isConcatSpreadable` — указывает, должен ли быть объект сплющен до элементов массива.
- `iterator` — возвращает итератор по умолчанию.
- `match` — сравнивает со строкой.
- `matchAll` — возвращает итератор, который выдает совпадения регулярного выражения со строкой.
- `replace` — заменяет совпадающие подстроки строки.
- `search` — возвращает индекс в строке, который соответствует регулярному выражению.
- `split` — разделяет строку по индексам, которые соответствуют регулярному выражению.
- `species` — создает производные объекты.
- `toPrimitive` — преобразует объект в примитивное значение.
- `toStringTag` — возвращает описание объекта по умолчанию.
- `description` — возвращает описание объекта в виде строки.

- [MDN - Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol#methods)
- [Тип данных Symbol в JS](https://codechick.io/tutorials/javascript/js-symbol)

<br></p>
</details>

- [learn.javascript.ru - Методы примитивов (общие вопросы)](https://learn.javascript.ru/primitives-methods)
-
- [MDN - Boolean](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean#methods)
- [betacode.net - Руководство ECMAScript Boolean](https://betacode.net/12197/ecmascript-boolean)
-
- [MDN - String](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String#methods)
- [Шпаргалка - методы строк](https://tproger.ru/articles/metody-strok-v-javascript-shpargalka-dlja-nachinajushhih/)
- [Дока - Обёртка String](https://doka.guide/js/string-wrapper/)
- [Metanit - Строки, объект String и его методы](https://metanit.com/web/javascript/6.1.php)
-
- [MDN - Number](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number#methods)
- [Дока - Обёртка Number](https://doka.guide/js/number-wrapper/#formatirovanie-chisla)
-
- [MDN - BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0)
-
- [MDN - Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol#methods)
- [Тип данных Symbol в JS](https://codechick.io/tutorials/javascript/js-symbol)

<br></p>
</details>

[//]: # (Замыкания)
<details id="closures"><summary><b>Замыкания</b></summary><p>

- Функция, которая содержит ссылки на переменные из родительской области видимости.
- Функция, которая запоминает свои внешние переменные и может получить к ним доступ.
- Функция вместе со всеми внешними переменными, которые ей доступны.
- Комбинация функции и лексического окружения, в котором она была объявлена.
- Способность функции запоминать контекст (LexicalEnvironment), в которой она была создана.

Приём, позволяет вызывать n экземпляров функции, и в каждом запомнить своё значение внутренних переменных.<br>
«Брать из замыкания» — из внутренней функции получаем/меняем переменные родительской функции.

Это замыкание если:
- родительская функция возвращает дочернюю функцию (через return). Именно функцию, а не результат её работы!
- дочерняя использует переменные из родительской
  <br>
  <br>


[//]: # (Описание 1)
<details><summary><b>Описание 1</b></summary><p>

- Вложенная функция запомнила значение `Х` из области своего создания (родительской функции).
- Её вызывают уже вне этой области, а она возвращает это Х.
- Т.е. она "замыкает" внешние переменные в себе.

<br></p>
</details>

[//]: # (Описание 2)
<details><summary><b>Описание 2</b></summary><p>

- есть функция `fA`
- в ней есть переменная `X` и другая функция `fB`
- функция `fB` использует эту переменную `X`
- функция `fA` возвращает в return функцию `fB`. Именно функцию, а не результат её работы. (`return fB;` а
  не `return fB();` )
- каждый запуск `fA` создаёт новую функцию `fB` с замыканием, которая хранит своё значение `X`.<br>
  `var one=fA(1); var two=fA(5);`

<br></p>
</details>

[//]: # (Описание 3)
<details><summary><b>Описание 3</b></summary><p>

Когда вызываю функцию - в ней создаются переменные локальной области видимости (т.е. доступные только самой функции)
.<br>
Под эти переменные движок JS выделяет память.

Когда обычная функция завершает свое выполнение - она освобождает память, которую ей выделели.<br>
Если, конечно, на переменные не осталось ссылок.

В случае с замыканием, ты возвращаешь дочернюю функцию обратно (делаешь return), т.е. ссылки на переменные остаются.<br>
Движок не может освободить память => и переменные родителя остаются доступными дочерней функции (и более никому).<br>
Это и называется "замыкание" - переменные замкнуты на саму функцию.<br>
Пока возвращенная функция остается в доступе замыкание существует.

<br></p>
</details>

[//]: # (Пример 1)
<details><summary><b>Пример 1</b></summary><p>

```js
function fA() {
  var currentCount = 1;

  function fB() { // (**)
    return currentCount++;
  };
  return fB;
}

var counter1 = fA();     // (*)
console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter1()); // 3

// создаём другой счётчик, он будет независим от первого
var counter2 = fA();
console.log(counter2()); // 1
```

**Пояснение**

1. В строке (*) запускается fA(). Создаётся LexicalEnvironment для переменных текущего вызова. В функции есть одна
   переменная var currentCount, которая станет свойством этого объекта. Она изначально инициализуется в undefined,
   затем, в процессе выполнения, получит значение 1.
2. В процессе выполнения fA() создаёт функцию fB в строке (**). При создании эта функция получает внутреннее свойство
   Scope со ссылкой на текущий LexicalEnvironment.
3. Далее вызов fA() завершается и функция (**) возвращается и сохраняется во внешней переменной counter (*). Итоговым
   значением, записанным в переменную counter, является функция ` function() { return currentCount++; };` , а её Scope=
   currentCount: 1
4. Возвращённая из fA() функция counter помнит (через Scope) о том, в каком окружении была создана. Это и используется
   для хранения текущего значения счётчика.
5. Когда-нибудь функция counter будет вызвана. Эта функция состоит из одной строки: `return currentCount++`. Своих
   переменных и параметров в ней нет, поэтому её Lexical Environment пуст.
6. Но, у неё есть свойство Scope - оно указывает на внешнее окружение. Чтобы увеличить и вернуть currentCount,
   интерпретатор ищет в текущем объекте переменных Lexical Environment, не находит, затем идёт во внешний объект, там
   находит, изменяет и возвращает новое значение. Как изменяет? Переменную во внешней области видимости можно не только
   читать, но и изменять.
7. В примере было создано несколько счётчиков. Все они взаимно независимы, потому что при каждом запуске fA() создаётся
   свой объект переменных LexicalEnvironment, со своим свойством currentCount, на который новый счётчик получит ссылку
   Scope.

<br></p>
</details>

[//]: # (Пример 2 - стрелочная функция)
<details><summary><b>Пример 2 - стрелочная функция</b></summary><p>

```js
const add = x => y => {
  const z = x + y;
  console.log(x + '+' + y + '=' + z);
  return z;
};

const res = add(3)(6); // вернёт 9 и выведет в консоль 3+6=9
console.log(res);
```

**Пояснение**

- В переменную add помещается функция от аргумента x,
- результатом которой будет являться другая функция, а именно функция от аргумента y,
- результат которой вычисляется приведённым в фигурных скобках блоком кода.
- Этот блок кода опирается на аргумент y своей функции и на замыкание, создаваемое для аргумента x внешней функции.

**При вызове add(3)(6):**

- функция, хранящаяся в переменной add, вызывается с аргументом 3
- и возвращает функцию, завязанную на значение 3 в замыкании x.
- в рамках такого обращения, эта функция выполняется с аргументом y = 6 и возвращает 9.

<br></p>
</details>

[//]: # (Пример 3 - анонимная самовыполняющуяся функция)
<details><summary><b>Пример 3 - анонимная самовыполняющуяся функция (IIFE)</b></summary><p>

**`IIFE` (immediately-invoked function expressions)**

- В прошлом в JS не было лексического окружения на уровне блоков кода.
- Придумали функции, запускаемые сразу после объявления.
- Создаётся и немедленно вызывается Function Expression. Код выполняется сразу, и у него есть свои локальные
  переменные.
- Function Expression обёрнуто в скобки (function {...}), потому что, когда JavaScript встречает "function" в основном
  потоке кода, он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, так что
  такой код вызовет ошибку. Даже если мы скажем: «хорошо, давайте добавим имя», – это не сработает, потому что
  JavaScript не позволяет вызывать Function Declaration немедленно. Так что скобки вокруг функции – это трюк, который
  позволяет показать JavaScript, что функция была создана в контексте другого выражения, и, таким образом, это
  функциональное выражение: ей не нужно имя и её можно вызвать немедленно.
- Кроме скобок, существуют и другие пути показать JavaScript, что мы имеем в виду Function Expression - стваить
  вначале `+` или `!`, например

```js
var fn = (
        function () {
          var numberOfCalls = 0;
          return function () {
            return ++numberOfCalls;
          }
        }
)();
```

<br></p>
</details>

[//]: # (Механизм - кратко)
<details><summary><b>Механизм - кратко</b></summary><p>

- Все функции, блоки кода и скрипты имеют скрытый объект `LexicalEnvironmen`.
- Все переменные и параметры функций = свойства объекта `LexicalEnvironmen`.
- Каждый запуск функции создает новый такой объект.
- При создании функция также получает скрытое св-во `[[Environment]]`
    - это ссылка на родительский `LexicalEnvironment`, в котором функция была создана.
- При вызове функция будет искать переменные:
    - внутри своего `LexicalEnvironmen`,
    - затем во внешних `LexicalEnvironment` (переходя по ним через св-ва `[[Environment]]`).

<br></p>
</details>

[//]: # (Механизм - Lexical Environment и [[Environment]])
<details><summary><b>Механизм - Lexical Environment и [[Environment]]</b></summary><p>

- При запуске функции, в ней создаётся объект `LexicalEnvironmen`.
- Его свойства - все переменные внутри функции, аргументы функции и вложенные функции.
- В конце выполнения функции объект `LexicalEnvironmen` обычно удаляется и память очищается. Если нет замыкания.
- Если переменная не найдена в `LexicalEnvironmen` функции – она будет искаться снаружи, через ссылку в
  свойстве `[[Environment]]`<br>
  <br>

**Уточнения**

- Скрытый объект `LexicalEnvironmen` есть у функции, блока кода и скрипта.
- Состоит из двух частей:
  - Объект `Environment Record`, в нём как свойства хранятся:
    - все локальные переменные
    - другие функции, объявленные внутри текущей
    - значение `this`
    - псевдомассив `arguments`
    - параметры функций
  - Ссылка на внешнее лексическое окружение
    - На код снаружи от текущих фигурных скобок.
    - У глобального объекта эта ссылка == null.
    - **Кажется это и есть скрытое свойство `[[Environment]]`**.
    - Функция получает его при «рождении».
- "Переменная" – это просто свойство специального внутреннего объекта `Environment Record`.
  - «Получить / изменить переменную» = «получить / изменить свойство этого объекта».
- `strict mode`
  - Если переменная не была найдена ни в одном внешнем окружении, это будет ошибкой в `strict mode`.
  - Без `strict mode`, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.
- `Function Declaration`
  - `function say(name){/*...*/}`
  - полностью инициализируются не тогда, когда выполнение доходит до них (как let), а раньше — когда создаётся
    лексическое окружение.
  - поэтому мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.
- В процессе выполнения функция будет оперировать данными \ информацией. Функция - это одно, а данные, с
  которыми функция работает - это совершенно другое. Данные, с которыми работает функция в процессе своего выполнения,
  лежат в отдельном месте оперативной памяти. Это место даже имеет специальное название - лексическое
  окружение `Lexical environment`.

<br></p>
</details>

[//]: # (Механизм - Global object)
<details><summary><b>Механизм - Global object</b></summary><p>

Все функции, блоки кода и скрипты имеют скрытый объект `LexicalEnvironmen` — на верхнем уровне это «global object».<br>
`Global object` = частный случай объекта `LexicalEnvironment`<br>
Глобальные переменные и функции - те, которые не находятся внутри какой-то функции. На "верхнем уровне".

В JS все глобальные переменные и функции = свойства объекта `global object`. <br>
В браузере этот объект доступен под именем window. <br>
Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.

У глобального объекта ссылка на внешнее лекс. окружение (св-во `[[Environment]]`) == null.

<br></p>
</details>

[//]: # (Механизм - Scope)
<details><summary><b>Механизм - Scope (разбираться)</b></summary><p>

Разбираться: [pikabu - Замыкание в JS по-человечески](https://pikabu.ru/story/zamyikanie_v_js_pochelovecheski_9330642)

Есть понятие `scope` = область видимости функции.<br>
Есть понятие `Scope` = имя ссылки, которая лежит в `[[Enviroment]]`<br>

`scope` — набор информации, с которой работает выполняемый код в текущий момент.<br>
`scope` = философское понятие, `LexicalEnvironmen` — его техническая реализация. Как-то так.<br>
Внутри `[[Enviroment]]` хранятся данные `Scope`, которые указывают на `LexicalEnvironmen`. Или что-то в этом духе.<br>

При анализе кода функции движок JS создаёт `функциональный объект` — там хранит данные о функции.<br>
Мы хотим, чтобы переменная X была в `scope` (области видимости функции). <br>
Но этой переменной нет в `LexicalEnvironmen` функции.
Поэтому смотрим в свойство `[[Environment]]` — там лежит ссылка на родительский `LexicalEnvironmen`.<br>
Будем искать в нём. И так дальше, пока не найдём или не дойдём до корня (глобальный объект).
Набор связанных между собой (специальной ссылкой) `LexicalEnvironmen`, расширяющих область видимости конкретной функции
- `scope chain`.<br>
После того, как ссылка `Scope` лексического окружения функции была скопирована с ссылки `[[Environment]]`
функционального объекта функции — область видимости функции была расширена областью видимости родителя,
образовав `scope chain`.

***

При создании функции в ней создаётся св-во `Scope` (область видимости*).<br>
В нём хранится ссылка на внешний объект `LexicalEnvironment`, в котором создана функция — глобальный объект (window) или
другая функция.<br>
Св-во `Scope` никогда не меняется, всюду следует за функцией, "привязывает" её к месту своего рождения.

Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания
функции. <br>
Функция по ссылке `Scope` обращается во внешний `LexicalEnvironmen` и берёт значение, которое там есть на момент
обращения.

Разница между созданием замыкания и созданием scope-объекта:

- замыкание (функция + ссылка на текущую цепочку scope-объектов) создается при определении функции,
- новый scope-объект создается при каждом вызове функции. Используется для модификации цепочки scope-объектов замыкания

<br></p>
</details>

[//]: # (Зачем используются)
<details><summary><b>Зачем используются</b></summary><p>

- `State для функции` — создать функцию у которой есть своё изменяемое состояние.
  - Т.е. привязать к функции данные, сохраняющиеся между ее вызовами.
  - автономное атомарное хранилище данных + доступ к этим данным.
- `Передача параметров в функцию`, которую вызывает другая функция
  - т.е. создание функций, в свою очередь тоже создающих функции.
  - Через замыкание возвращаемая внутренняя функция «запоминает» параметры, переданные внешней функции.
- `Изоляция данных` — ограничение доступа к данным, ограничение их области видимости.
- Эмуляция `private методов` функций.
  - N языки (Java...) позволяют объявлять private методы — могут быть вызваны только методами того же класса, в котором
    объявлены. Средство организации пространства имен — чтоб не засорять публичный интерфейс кода внутренними методами
    классов. JS так не умел, это эмулировали замыканиями.
- Обработка `callback`
  - Функция обратного вызова. Выполняется после того, как другая функция завершила выполнение.
  - Например: кликнул по кнопке, вызвалась функция, что-то сделала
  - Могу через замыкание создать функцию-фабрику, она принимает размер шрифта X и меняет его на всей странице.
  - Создаю N экземпляров из функции-фабрики, передавая туда разные Х. Каждый экземпляр вешаю как callback на кнопку (
    onClick)
  - Кликая по разным кнопкам - меняю размер шрифта на сайте
  - ```js
    function makeSizer(size) {
      return function() {
        document.body.style.fontSize = size + 'px';
      };
    };
    
    <input onclick="makeSizer(12)" type="button" value="12pt">
    <input onclick="makeSizer(14)" type="button" value="14pt">
    ```
  - ИЛИ:
  - внутреннюю функцию не возвращаем, а вешаем на какое-либо событие — поскольку событие возникает уже после того, как
    исполнилась функция, замыкание опять же помогает не потерять переданные при создании обработчика данные.
- Можно использовать везде, где используют `объект с одним методом`
  - Позволяют связать данные (лексическое окружение) с функцией, которая их использует. Как в ООП — объекты связывают
    данные (св-ва объекта) с методами.
- [Habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)

<br></p>
</details>

[//]: # (Альтернатива замыканиям)
<details><summary><b>Альтернатива замыканиям</b></summary><p>

Вместо замыканий можно использовать функцию как объект.<br>
Создать в объекте функции свойство и привязать к нему значение. Это значение будет сохраняться между вызовами функции,
также как в замыкании.<br>
Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны.

Пример:
```js
function makeCounter() {
  function counter() {
    return counter.currentCount++;
  };
  counter.currentCount = 1;

  return counter;
}

var counter = makeCounter();
alert(counter()); // 1
alert(counter()); // 2
```

Принципиальная разница:
– во внутренней механике

- свойство функции общедоступно, в отличие от переменной из замыкания. К свойству имеет доступ любой, у кого есть объект
  функции.

Я так понимаю, можно использовать и обычные объекты/классы?

<br></p>
</details>

[//]: # (Производительность)
<details><summary><b>Производительность</b></summary><p>

Не нужно без необходимости создавать функции внутри функций в тех случаях, когда замыкания не нужны.<br>
Использование этой техники снижает производительность и в скорости, и в потреблении памяти.

<br></p>
</details>

[//]: # (Разное)
<details><summary><b>Разное</b></summary><p>

- Все функции в JS = замыкания.
  - Когда создается функция — всегда создается замыкание.
  - Чаще оно пустое - обычно функции ничего не используют из внешнего LexicalEnvironmen.
- В функциональном программировании замыкания не приветствуются. Но знать и уметь надо, а в JS - обязательно.
- Замыкания внутри цикла + `var`
  - Пока в ES6 не ввели ключевое слово `let`, часто возникала проблема при создании замыканий внутри цикла.
  - Будьте внимательны с использованием var/let в циклах.
  - Либо используем let (` for (let i = 0; i < someVariable; i++){...}`),
  - Либо реализуем замыкание в отдельной функции снаружи цикла, а в цикле вызываем эту функцию при каждой итерации.
  - Или сделать ещё один уровень вложенного замыкания.
    Подробнее: [MDN - Замыкания](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B9_%D0%B2_%D1%86%D0%B8%D0%BA%D0%BB%D0%B5_%D0%BE%D1%87%D0%B5%D0%BD%D1%8C_%D1%87%D0%B0%D1%81%D1%82%D0%B0%D1%8F_%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0)
    , [Habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)
- «Замкнутые» данных сохраняются в не в «стеке» а в «куче»
  - Это структура в памяти JS-движка.
  - Стек — стопка тарелок. Положил сверху, взял сверху. LIFO (Last In, First Out)
  - Куча — просто склад переменных. Обратился по имени (ссылке) - получил данные.
  - Позволяет сохранять данные после вызова функции. Даже после того, как контекст выполнения удаляется из стека
    выполнения вызова.

<br></p>
</details>

**Ссылки**

- [learn.javascript.ru - Замыкания](https://learn.javascript.ru/closures)
- [MDN - Замыкания](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)
- [Habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)
- [htmlacademy - Замыкания в JavaScript](https://htmlacademy.ru/blog/useful/javascript/lets-learn-javascript-closures)
- [Wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
- [pikabu - Замыкание в JS по-человечески](https://pikabu.ru/story/zamyikanie_v_js_pochelovecheski_9330642)
- [Hexlet - Возврат функций из функций](https://ru.hexlet.io/courses/js-functions/lessons/return-function/theory_unit)
- [code.mu - Продвинутая работа с функциями](http://code.mu/books/javascript/advanced/prodvinutaya-rabota-s-funkciyami-javascript.html)
- [proglib - Пора понять замыкания в JavaScript! Часть 1. Готовим фундамент](https://proglib.io/p/js-closures-1/)
- [proglib - Пора понять замыкания в JavaScript! Часть 2. Переходим к делу](https://proglib.io/p/js-closures-2/)

<br></p>
</details>

[//]: # (Прототипы)
<details id="prototype"><summary><b>Прототипы</b></summary><p>

В JS объекты имеют специальное скрытое свойство `[[Prototype]]`.<br>
Оно либо равно `null`, либо ссылается на другой объект. Этот объект называется «прототип».

Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В
программировании такой механизм называется «прототипным наследованием».

Свойство `[[Prototype]]` является внутренним и скрытым, но есть много способов задать его.<br>
Одним из них является использование `__proto__` (устраевшее св-во)

```js
    let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;
```

Если мы ищем свойство или метод в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.

Современные же методы работы с прототипами (нужно использовать вместо `__proto__`):

- `Object.create(proto, [descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как proto, и
  необязательными дескрипторами свойств descriptors.
- `Object.getPrototypeOf(obj)` – возвращает свойство `[[Prototype]]` объекта obj.
- `Object.setPrototypeOf(obj, proto)` – устанавливает свойство `[[Prototype]]` объекта obj как proto.

Можно строить длинные цепочки прототипов

- Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
- Значение `__proto__` может быть объектом или `null`. Другие типы игнорируются.

Прототипы никак не влияют на `this`.

Цикл `for..in` проходит не только по собственным, но и по унаследованным свойствам объекта.

**Ссылки**

- [learn.javascript.ru - Прототипы](https://learn.javascript.ru/prototypes)

<br></p>
</details>

[//]: # (Промисы - Promises )
<details id="promise"><summary><b>Промисы - Promises</b></summary><p>

  ***

Способ организации асинхронного кода.<br>
Объект, который содержит своё состояние — ожидание, выполнен успешно, ошибка.<br>
Позволяет вызывать разные коллбеки в зависимости от результата — одни для успеха, другие для ошибок.

Промисы можно объединять в цепочки — замена «пирамиды вложенных колбэков».<br>
Выполняем асинхронную операцию, с результатами её работы выполняем другую асинхронную операцию и т.д.
<br>
<br>


[//]: # (Способ использования. Описание 1)
<details><summary><b>Способ использования. Описание 1</b></summary><p>

- создаём специальный объект-промис (через конструктор `new Promise()`),
- в этом объекте находится `функция-исполнитель` и у неё два коллбека — `resolve`/`rejected` (функция завершилась
  удачно/неудачно)
- в эту функцию пишем свой код (например асинхронный запрос). Функция вызывается автоматически при создании промиса (т.е
  когда JS-парсер доходит до этого места кода).
- внутри функции, по результатам работы, вызываем коллбеки resolve/rejected. Если второй вариант не интересует - можно
  вызвать только один, например на успех.
- в коллбек resolve/rejected передаю результат работы функции-исполнителя или ошибку. Эти данные поступят в `обработчик`
  , и там с ними можно работать.
- после промиса добавляем к нему `конструкции-обработчики` (then/catch/finally) - выполнят разные действия, в
  зависимости
  от результатов выполнения функции в промисе (resolve/rejected).
- обработчики .then/.catch тоже возвращает объект-промис - можно строить длинные цепочки
- в конце цепочки обработчиков (один или несколько .then) обязательно ставить catch/finally — обработать ошибки, чтоб
  вся система не упала.

<br></p>
</details>

[//]: # (Способ использования. Описание 2)
<details><summary><b>Способ использования. Описание 2</b></summary><p>

1. В основном коде пишем `new Promise()` и внутри запускаем асинхронную функцию
2. Асинхронная функция создаёт объект `promise` и возвращает его.
3. В основном коде мы принимаем объект `promise` и навешиваем на него обработчики (одни - на успех, другие - на ошибку).
4. Когда код асинхронной функции завершается, он переводит promise в состояние `fulfilled(результат)`
   или `rejected(ошибка)`. При этом автоматически вызываются соответствующие обработчики в основном коде.

<br></p>
</details>

[//]: # (Свойства объекта "promise")
<details><summary><b>Свойства объекта `promise`</b></summary><p>

- возвращается конструктором `new Promise`
- `state` («состояние»)
  - вначале `pending` («ожидание»),
  - затем либо `fulfilled` («выполнено успешно») gри вызове resolve
  - либо `rejected` («выполнено с ошибкой») при вызове reject
- `result` («результат»)
  - вначале `undefined`,
  - при вызове `resolve(value)` меняется на `value`
  - при вызове `reject(error)` меняется на `error`

<br></p>
</details>

[//]: # (Обработчики промиса)
<details><summary><b>Обработчики промиса</b></summary><p>

- назначаются вызовом `then`/`catch`/`finally`
- `.then` = универсальный метод для навешивания обработчиков-колбэков:
  - `promise.then(onFulfilled, onRejected)` //первый сработает если промис завершился удачно, второй сработает при
    неудаче
  - `promise.then(onFulfilled)` //сработает если промис завершился удачно, при неудаче ничего не произойдёт
  - `promise.then(null, onFulfilled)` //сработает если промис завершился неудачно, при удаче ничего не произойдёт
  - Внутри .then обязательно должна быть функция.
    - Всё кроме функции интерпретируется как then(null) и в следующий по цепочке обработчик «проваливается» результат
      предыдущего.
    - ```js
      //Вариант с ошибкой
      Promise.resolve('foo')
      .then(Promise.resolve('bar')) //нет функции => вернёт null
      .then(function (result) {
        console.log(result); //'foo' - «провалился» из первой строки
      });
      
      //То же самое
      Promise.resolve('foo')
      .then(null) 
      .then(function (result) {
        console.log(result); //'foo' - «провалился» из первой строки
      });
      
      //Вариант с другой ошибкой
      Promise.resolve('foo')
      .then(() => {Promise.resolve('bar');}) //в then функция, но она не делает return — вренёт undefined
      .then(result => {
        console.log(result); //'undefined'
      });
      
      //Вариант без ошибки 1
      Promise.resolve('foo')
      .then(() => {return Promise.resolve('bar');}) //функция + return результатов работы Promise
      .then(result => {
        console.log(result); //'bar'
      });
            
      //Вариант без ошибки 2
      Promise.resolve('foo')
      .then(someFunc()) //функция выполнится
      .then(result => {
        console.log(result); //Если в someFunc() есть return - выведутся отправленные ей данные. Иначе undefined.
      });
      ```
  - Если хочешь передать данные в следующий обработчик - должен быть `return`
    - Если в обработчике нет `return` — обработчик возвращает undefined
    - ```js
      //Вариант с ошибкой
      Promise.resolve('foo')
      .then(() => {Promise.resolve('bar');}) //Не делает return — вренёт undefined
      .then(result => {
        console.log(result); //'undefined'
      });
      
      //Вариант без ошибки
      Promise.resolve('foo')
      .then(() => {return Promise.resolve('bar');}) //Есть return результатов работы Promise
      .then(result => {
        console.log(result); //'bar'
      });
      ```
  - Можем сделать три вещи
    - Вернуть (return) другой промис
      - в `return` пишем другой промис, когда он выполнится - его результат попадёт в следующий обработчик
      - если я просто вызову другой промис (без return) - промис выполнится. Но в следующий обработчик придёт именно то,
        что объявлено в return (или `undefined`, если return нет). Т.е. промис выполнится и НЕ передаст свои результаты
        дальше по цепочке обработчиков.
      - ```js
        getUserByName('Ivan')
        .then(function (user) {
          // Функция getUserAccountById возвращает promise, результат которого попадет в следующий then
          return getUserAccountById(user.id);
        })
        .then(function (userAccount) {
          // Я знаю все о пользователе!
        });
        ```
    - Вернуть (return) обычное синхронное значение (или undefined)
      - ```js
        getUserByName('Ivan')
        .then(function (user) {
          if (inMemoryCache[user.id]) {
            // Данные этого пользователя уже есть в обычном синхронном коде, возвращаем сразу
            return inMemoryCache[user.id];
          }
          // Про этого пока не знаем, вернем промис запроса
          return getUserAccountById(user.id);
        })
        .then(function (userAccount) {
          // Я знаю все о пользователе!
        });
        ```
    - Выдать (throw) синхронную ошибку
      - ```js
        getUserByName('Ivan')
        .then(function (user) {
          if (user.isLoggedOut()) {
            // Пользователь вышел — выдаем ошибку!
            throw new Error('user logged out!');
          }
          if (inMemoryCache[user.id]) {
            // Данные этого пользователя уже есть в обычном синхронном коде, возвращаем сразу
            return inMemoryCache[user.id];
          }
          // Про этого пока не знаем, вернем промис запроса
          return getUserAccountById(user.id);
        })
        .then(function (userAccount) {
          // Я знаю все о пользователе!
        })
        .catch(function (err) {
          // Упс, ошибка, но мы к ней готовы!
        });
        ```
        - catch() получит синхронную ошибку, если пользователь не авторизован, или асинхронную, если любой из промисов
          выше перейдет в состояние rejected. Функции в catch без разницы, была ошибка синхронной или асинхронной.
- `.catch` = чтобы поставить обработчик только на ошибку.
  - это синтаксический сахар для `.then(null, onFulfilled)`, просто более короткий способ записать его.
  - `.catch(onRejected)` – сработает только при неудачном завершении промиса
  - `.catch(onRejected)` = сокращённая запись `.then(null, onRejected).`
  - Если промис завершается с ошибкой, то управление переходит в ближайший `.catch` ниже по коду. `.catch` не
    обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких .then.
  - Если ошибка не перехвачена ни одним `.catch` (например добавить `.catch` в конец цепочки) — скрипт умирает с
    сообщением в консоли
  - Самый лёгкий путь перехватить все ошибки – это добавить `.catch` в конец цепочки. Тогда, если все в порядке, этот
    .catch вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная
    json-строка, или что угодно другое), то ошибка будет перехвачена. Финальный .catch перехватывает как промисы, в
    которых вызван reject, так и случайные ошибки в обработчиках.
  - Если мы бросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление
    перейдёт к ближайшему `.catch`. Это происходит для всех ошибок, не только для тех, которые вызваны
    оператором `throw`. Например, вызов несуществующей функции (программная ошибка).
  - В `.catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. Если мы
    пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок.
    А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный
    обработчик `.then`.
- `.finally` = выполнится в любом случае: и при успехе, и при ошибке
  - обработчик для выполнения очистки/доведения после завершения предыдущих операций. Например остановить индикатор
    загрузки.
  - В finally мы не знаем, как был завершён промис - успешно ли нет
  - finally «пропускает» результат или ошибку дальше, к последующим обработчикам. Поэтому обычно ставится в коле выше
    чем `then` и `catch`
  - Обработчик finally также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.<br>
    - Единственное исключение — если обработчик finally выдает ошибку. Эта ошибка передается следующему обработчику
      вместо любого предыдущего результата.
- Вызов обработчика тоже возвращает промис => мы можем вызвать на нём следующий обработчик.
  - когда обработчик (then, catch, finally) возвращает значение — оно становится результатом выполнения соответствующего
    промиса и передаётся в следующий обработчик.
    - ```js
      promise
      .then(result => {return result * 2})
      .then(result => {alert(result)});
      ```
  - если обработчик `handler`, переданный в `.then(handler)` возвращает промис (`return new Promise()`) — следующие
    обработчики цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка)
    передаётся дальше.
    - ```js
      promise
      .then(result => {
        return new Promise((resolve, reject) => { // then возвращает новый промис
          setTimeout(() => resolve(result * 2), 1000);
        });
      })
      .then(result => {alert(result)}); 
      ```

<br></p>
</details>

[//]: # (Синтаксис "Promise.resolve")
<details><summary><b>Синтаксис `Promise.resolve().then()`*</b></summary><p>

- Бывает что асинхронного кода нет, но нужен промис, чтобы построить цепочку.

- ```js
  //Пример цепочки после успешного завершения
  const promise = new Promise((resolve) => resolve());
  // promise.then ...
  
  //Пример цепочки после неудчаного завершения
  const promise = new Promise((resolve, reject) => reject());
  // promise.catch ...
  ````

- Для этих задач есть спец. синтаксис, с ним код становится чище:

- ```js
  const promise1 = Promise.resolve();
  // promise1.then
  
  const promise2 = Promise.reject();
  // promise2.catch ...
  ````  

<br></p>
</details>

[//]: # (Сhaining - чейнинг)
<details><summary><b>Сhaining (чейнинг)</b></summary><p>

Возможность строить асинхронные цепочки из промисов<br>
Основная причина, из-за которой существуют и активно используются промисы.

Например, мы хотим по очереди:

- Загрузить данные посетителя с сервера (асинхронно).
- Затем отправить запрос о нём на github (асинхронно).
- Когда это будет готово, вывести его github-аватар на экран (асинхронно).
- …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.

```js
  httpGet('/article/promise/user.json') //делаем запрос
        .then(response => {
          console.log(response);
          let user = JSON.parse(response);
          return user;
        })
        // 2. Получить информацию с github
        .then(user => {
          console.log(user);
          let githubUser = httpGet(`https://api.github.com/users/${user.name}`)
          return githubUser;
        })
        // 3. Вывести картинку юзера
        .then(githubUser => {
          console.log(githubUser);
          githubUser = JSON.parse(githubUser);
          img.src = githubUser.avatar_url;
          document.body.appendChild(img);
        });
```

Вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.

При чейнинге `.then…then…then`, в каждый следующий `then` переходит результат от предыдущего.<br>
Если очередной `then` вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.

Цепочки Promise работают напрямую через `event loop` и могут содержать достаточно тяжелые вычисления.<br>
Разбивая их на атомарные операции, мы оставляем пространство для выполнения обработчиков пользовательских событий.

<br></p>
</details>

[//]: # (Промисификация)
<details><summary><b>Промисификация</b></summary><p>

Это когда берут асинхронную функцию на коллбеках и делают для неё обёртку, возвращающую промис.<br>
Использование становится удобнее.<br>
Часто используется для сторонних библиотек и legasy-кода, которые написан на колбеках. А хочется работать с ними через
промисы.

Такой код

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}

// использование:
// loadScript('path/script.js', (err, script) => {...})
```

Можно записать так:

```js
let loadScriptPromise = function (src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}

// использование:
// loadScriptPromise('path/script.js').then(...)
```

Теперь loadScriptPromise хорошо вписывается в код, основанный на промисах.<br>
loadScriptPromise передаёт всю работу исходной функции loadScript, предоставляя ей колбэк, по вызову которого происходит
resolve/reject промиса.

Чтобы автоматизировать создание таких обёрток можно использовать функцию-помощник — принимает функцию для промисификации
f и возвращает функцию-обёртку.<br>
Есть готовые модули с гибкой настройкой промисификации, например

- [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify)
- встроенная функция `util.promisify` в Node.js.

Промисификация – это отличный подход, особенно, если вы будете использовать async/await, но она не является тотальной
заменой любых колбэков. Промис может иметь только один результат, но колбэк технически может вызываться сколько угодно
раз.
Поэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка
будут проигнорированы.

<br></p>
</details>

[//]: # (Promise API)
<details><summary><b>Promise API</b></summary><p>

У класса `Promise` есть статические методы:

- Promise.all
  - [javascript.ru - Promise.all](https://learn.javascript.ru/promise-api#promise-all)
  - запустить множество промисов параллельно и дождаться, пока все они выполнятся
  - Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой
    ошибкой. При этом остальные результаты игнорируются.
  - принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив)
  - возвращает новый промис.
  - новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их
    результатов.
  - порядок элементов результирующего массива точно соответствует порядку исходных промисов. Даже если первый промис
    будет выполняться дольше всех, его результат всё равно будет первым в массиве.
  - Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст
    задачу-промис, и затем обернуть получившийся массив в Promise.all
- Promise.allSettled
  - [javascript.ru - Promise.allSettled](https://learn.javascript.ru/promise-api#promise-allsettled)
  - Альтернатива Promise.all
  - Метод всегда ждёт завершения всех промисов. В массиве результатов будет
    - {status:"fulfilled", value:результат} для успешных завершений,
    - {status:"rejected", reason:ошибка} для ошибок.
- Promise.race
  - [javascript.ru - Promise.race](https://learn.javascript.ru/promise-api#promise-race)
  - Как Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
- Promise.any
  - [javascript.ru - Promise.any](https://learn.javascript.ru/promise-api#promise-any)
  - Как Promise.all, но ждёт только первый **успешно выполнившийся** выполненный промис, из которого берёт результат (
    или ошибку).
  - Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с
    помощью AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.
- Promise.resolve/reject
  - [javascript.ru - Promise.resolve/reject](https://learn.javascript.ru/promise-api#promise-resolve-reject)
  - Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы
    рассмотрим его чуть позже) делает их, в общем-то, не нужными.
  - Promise.resolve(value) создаёт и возвращает успешно выполненный промис с результатом value.
    - Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.
  - Promise.reject(error) создаёт и возвращает промис, завершённый с ошибкой error.

<br></p>
</details>

[//]: # (Асинхронные итераторы, for-await-of. ForEach, for и while)
<details><summary><b>Асинхронные итераторы, for-await-of. ForEach, for и while</b></summary><p>

Надо относиться очень аккуратно к использованию `forEach`, `for` и `while` в промисах.
Скорее всего нужен `Promise.all()` или что-то в этом духе.

Просто использовать цикл for или метод forEach с асинхронными операциями мы не можем. И цикл for и метод forEach ожидают
синхронный код.<br>
Однако мы можем использовать for await...of, который появился в ES2018, для обхода асинхронных итерируемых сущностей.

Подробнее:

- [Habr - У нас проблемы с промисами](https://habr.com/ru/company/vk/blog/269465/)

Есть ещё асинхронные итераторы (используется цикл for-await-of) - объединяют возможности итераторов и операторов async и
await.

- [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
- [Mentanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
- [Habr - Как работать с async/await в циклах JavaScript](https://habr.com/ru/post/435084/)

<br></p>
</details>

[//]: # (Что нового)
<details><summary><b>Что нового</b></summary><p>

- ES6 (2015)
  - введены Promises
- ES8 (2017)
  - `Async/Await`  — асинхронные функции, работают на основе promise
- ES9 (2018)
  - метод `finally()` у объектов Promise — выполнять коллбэк после `resolve()` / `reject()`. Чтобы корректно завершать
    операции (например, высвобождая ресурсы).
  - цикл `for-await-of` (асинхронная итерация) — создавать циклы, работающие с асинхронным кодом. Вызывать в цикле
    асинхронные функции (возвращающие промисы) или обрабатывать массивы, содержащие промисы.
- ES11 (2020)
  - динамический импорт — можно импортировать модули в виде промиса
- ES12 (2021)
  - метод `Promise.any` — принимает n промисов и возвращает первый успешно завершившийся.
  - объект `AggregateError` — новый тип ошибок. Представить n ошибок в виде одной комбинированной. Например для
    Promise.any(), если все promises завершились в rejected

<br></p>
</details>

[//]: # (Заметки)
<details><summary><b>Заметки</b></summary><p>

- Как правило, все асинхронные действия должны возвращать промис.
  - Позволяет планировать после него какие-то дополнительные действия по завершении асинхронной части.
  - Даже если эта возможность не нужна прямо сейчас, она может понадобиться в будущем.
- Можно работать с промиса в обычных функциях, можно в
  стрелочных `.then(script => loadScript("/article/promise-chaining/two.js"))`.
- Функция-executor в промисе должна вызвать либо `resolve(value)`, либо `reject(error)`. Если кроме этого она возвращает
  значение (т.е. делает какой-то return) - оно буде проигнорировано.
- Функции-колбэки `resolve(value)` и `reject(error)` принимают только один аргумент: value или error. Или ни одного.
  Все дополнительные аргументы будут проигнорированы.
- В `reject(error)` можно передать любой аргумент. Но рекомендуется использовать объект `Error` (или унаследованный от
  него).
- внутри `then` всегда использовать `return` или выдавать ошибку при помощи `throw`.
- в конец цепочки промисов `.then(...).then(...)` всегда добавлять метод `catch()`: .catch(console.log.bind(console))
- всегда добавлять обработку ошибок ниже в виде `catch()`,
  - Никогда не использовать для этой цели вторую функцию в методе `then()`
  - Исключение только одно — асинхронные тесты в Mocha, в случаях, когда я намеренно жду ошибку:

<br></p>
</details>

[//]: # (Примеры кода)
<details><summary><b>Примеры кода</b></summary><p>

- ```js
  //Создаём объект-промис
  let promise = new Promise(function (resolve, reject) {
    // Эта функция будет вызвана автоматически, в ней можно делать любые асинхронные операции,
    // Когда они завершатся — нужно вызвать resolve(результат) при успехе или reject(ошибка) при ошибке
    setTimeout(() => resolve(result), 1000); // переведёт промис в состояние fulfilled с результатом "result", через 1 сек
  })
  
  //Навешиваем обработчик с двумя вариантами реакции - на успех и ошибку
  promise
        .then(
                // функция-обработчик №1 - запустится при вызове resolve
                result => console.log("Fulfilled: " + result), // result - аргумент resolve

                // функция-обработчик №2 - запустится при вызове reject
                // сработала бы, если б в SetTimeout вместо resolve("result") был вызов reject("error")
                error => console.log("Rejected: " + error), // error - аргумент reject
        );
  ```

- ```js
  //Промис в функции
  const loadImg = url => {
    return new Promise((resolve, reject) => {
      const getSomething = new XMLHttpRequest();
      getSomething.open("GET", url);

      getSomething.onload = () => resolve(xhr.responseText); //передаем в resolve ответ
      getSomething.onerror = () => reject(xhr.statusText); //переадем в reject текст ошибки

      getSomething.send();
    });
  }

  loadImg(url)
        .then(
                function (result) {
                  //some work
                },
                function (err) {
                  console.log(err);
                }
        );
  ```

- ```js
  //Вызов промиса без объявления переменной
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000);
  }).then(function (result) {
    //some work
  });
  ```

- ```js
  //когда асинхронного кода нет, но нужен промис, чтобы построить цепочку
  //Сразу переводим промис в состояние resolve (c данными value) и передаём данные в then.
 
  //Для этого есть спец. синтаксис 
  Promise.resolve(value)
  .then(result => console.log(value));
  
  //То же самое что
  new Promise(resolve => resolve(value))
  .then(result => console.log(value));
  
  //То же самое что
  new Promise(function (resolve) {
    resolve(value);
  })
  .then(result => console.log(value));
  ```

- ```js
  //Возвращение промиса из .then - построение цепочки асинхронных действий
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000);
  }).then(function (result) {
    alert(result); // 1
  
    return new Promise((resolve, reject) => { // then возвращает новый промис
      setTimeout(() => resolve(result * 2), 1000);
    });
  }).then(function(result) { // (**)
    alert(result); // 2
  });
  ```
  <br>

<br></p>
</details>


**Ссылки**

- [learn.javascript.ru - Промисы](https://learn.javascript.ru/promise-basics)
- [MDN - Промисы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [MDN - Использование промисов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Using_promises)
- [Habr - У нас проблемы с промисами](https://habr.com/ru/company/mailru/blog/269465/)
- [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
- [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://m.habr.com/ru/company/ruvds/blog/340508/)
- [Hexlet - new Promise (JS: Асинхронное программирование)](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/new-promise/theory_unit)
- [Habr - Промисы в ES6: паттерны и анти-паттерны](https://m.habr.com/ru/company/ruvds/blog/339414/)
- [Habr - Познаем промисы на основе Ecmascript спецификации. Знакомство](https://habr.com/ru/post/478938/)
- [Medium - Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
- [Ад обратных вызовов](http://callbackhell.ru/)
- [WebDev - ES6 #13 Промисы (YouTube)](https://youtu.be/XD1MKx7eIuQ)

<br></p>
</details>

[//]: # (Промисы - Async/Await)
<details id="promiseAsync"><summary><b>Промисы - Async/Await</b></summary><p>

  ***

Специальный синтаксис для работы с промисами.<br>
Замена `.then` — позволяет оформлять асинхронный код более привычным способом, как синхронный. Синтаксический сахар

Ключевое слово `async` сообщает JS-интерпретатору что эту функцию, нужно обрабатывать по-особому:

- такая функция всегда возвращает промис. Если вернёт что-то другое — это значение автоматически обернется в успешно
  завершившийся промис.
- когда система достигнет в этой функции ключевого слова `await` — она приостановится.<br>
  Она считает, что выражение после `await` возвращает промис — ожидает разрешения или отклонения этого промиса перед
  продолжением.

Ключевое слово `await` перед промисом заставит JS дождаться его выполнения, после чего:

- Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось `throw`.
- Иначе вернётся результат промиса — то, что возвращает асинхронная функция справа от слова await.
- Ключевое слово await говорит движку JS приостановить код в этой строке, не блокируя остальной код скрипта за пределами
  асинхронной функции.
  <br>
  <br>


[//]: # (Преимущества)
<details><summary><b>Преимущества</b></summary><p>

- код выглядит лучше - можно работать с асинхронными функциями как с синхронными
- удобнее обрабатывать ошибки
- удобнее отлаживать
  <br></p>

</details>

[//]: # (Про ошибки)
<details><summary><b>Про ошибки</b></summary><p>

- При использовании промисов нам приходится использовать блок `.catch()` для обработки асинхронных ошибок, и
  блок `try / catch` для обработки синхронных ошибок.
- Конструкция async / await позволяет обрабатывать синхронные и асинхронные ошибки с использованием одних и тех же
  механизмов — выражением `try / catch`.
- Также cтек ошибки, возвращённый из цепочки промисов, не содержит сведений о точном месте, в котором произошла ошибка.
  В В отличие от `async / await` этой проблемы нет

<br></p>
</details>

[//]: # (Про отладку)
<details><summary><b>Про отладку</b></summary><p>

- Если вы пользовались промисами, то вы знаете, что отладка подобных конструкций — это кошмар.
- Например, если установить nочку останова внутри блока `.then` и использовать команды отладки вроде «step-over»,
  отладчик не перейдёт к следующему `.then`, так как он умеет «перешагивать» лишь через синхронный код.
- С использованием `async / await` можно переходить по вызовам, в которых используется ключевое слово `await` так, будто
  это — обычные синхронные операции.
  <br></p>

</details>

[//]: # (Про event loop)
<details><summary><b>Про event loop</b></summary><p>

- Сама по себе async-функция обработается по обычным правилам.
- А вот ключевое слово `await` в ней — поставит код «на паузу».<br>
  Интерпретатор JS будет ждать, пока промис справа от `await` не выполнится.
- После чего оно вернёт его результат, и выполнение кода продолжится.
- Вроде это должно работать как обычный `.then`
  - Это просто «синтаксический сахар» для получения результата промиса, аналог `promise.then`.
  - Хотя await и заставляет JS дожидаться выполнения промиса, это не отнимает ресурсов процессора.
  - Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать
    события и т.п.

Ключевое слово `await` говорит движку JS приостановить код в этой строке, не блокируя остальной код скрипта за пределами
асинхронной функции.

Слово `await` сообщает что

- мы должны дождаться выполнения асинхронной функции
- не помещать ее в event loop, а выполнить прямо здесь.


- ```js
  // Мы дожидаемся выполнения асинхронной функции getData(), 
  // выполняем прямо здесь (не помещая в event looop) и пишем результат в i-й элемент массива.

  async function fillArray() {
    const arr = [];
    for (var i = 0; i < 10000; i++) {
      arr[i] = await getData(i);
    }
  }
  ```

- Это значит, что при вызове асинхронной функции fillArray() она попадет в очередь контекстов и будет исполнена.<br>
- Но следующий контекст будет ждать, пока текущий завершится. <br>
- Все пользовательские события, таймеры и прочие помещаемые в очередь контексты будут ждать, пока не пройдут десять
  тысяч
  запросов к серверу.
  <br></p>

</details>

[//]: # (Asynс-функция всегда возвращает промис)
<details><summary><b>Asynс-функция всегда возвращает промис</b></summary><p>

- ```js
  //Можно не писать return Promise(...) — всё равно вренётся промис
  async function f() { return 1 }
  f().then(alert); // 1
  ```

- ```js    
  //Можно явно вернуть промис — результат будет тот же
  async function f() {return Promise.resolve(1)}
  f().then(alert); // 1
  ```

<br></p>
</details>

[//]: # (Async и Promise.all)
<details><summary><b>Async и Promise.all</b></summary><p>

Await отлично работает в сочетании с `Promise.all`, если необходимо выполнить несколько задач параллельно.

`Promise.all` — запустить N промисов параллельно и дождаться, пока все они выполнятся.<br>
Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой
ошибкой. При этом остальные результаты игнорируются.

<br></p>
</details>

[//]: # (Асинхронные итераторы, for-await-of. ForEach, for и while)
<details><summary><b>Асинхронные итераторы, for-await-of. ForEach, for и while</b></summary><p>

Надо относиться очень аккуратно к использованию `forEach`, `for` и `while` в промисах.
Скорее всего нужен `Promise.all()` или что-то в этом духе.

Просто использовать цикл for или метод forEach с асинхронными операциями мы не можем. И цикл for и метод forEach ожидают
синхронный код.<br>
Однако мы можем использовать for await...of, который появился в ES2018, для обхода асинхронных итерируемых сущностей.

Подробнее:

- [Habr - У нас проблемы с промисами](https://habr.com/ru/company/vk/blog/269465/)

Есть ещё асинхронные итераторы (используется цикл for-await-of) - объединяют возможности итераторов и операторов async и
await.

- [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
- [Mentanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
- [Habr - Как работать с async/await в циклах JavaScript](https://habr.com/ru/post/435084/)

<br></p>
</details>

[//]: # (Примеры использования)
<details><summary><b>Примеры использования</b></summary><p>

- ```js
  //Использование со стрелочной функцией
  const foo = async() => {console.log(await getData())};
  foo();
  ````

- ```js
  //Отлавливание ошибок
  const foo = async() => {
    try {
        console.log(await getData())
    } catch(err) {
        console.error(err)    
    }
  };
  foo();
  ````

- ```js
  //Пример с then
  

  //Он же с async/await
  const foo = async() => {
    try {
        console.log(await getData())
    } catch(err) {
        console.error(err)    
    }
  };
  foo();
  ````

- ```js
  //A. Вариант с .then
  // 1. Запрашиваем с сервера JSON с данными пользователя
  fetch('/src/user.json')
        // 2. Загружаем данные в формате json
        .then(response => response.json())
        
        // 3. Запрашиваем информацию об этом пользователе с GitHub
        .then(user => fetch(`https://api.github.com/users/${user.name}`))

        // 4. Загружаем ответ в формате json
        .then(response => response.json())

        // 5. Показываем аватар (githubUser.avatar_url) в течение 3 секунд
        .then(githubUser => new Promise(function (resolve, reject) {
          let img = document.createElement('img');
          img.src = githubUser.avatar_url;
          img.className = "promise-avatar-example";
          document.body.append(img);

          // ждём 3 секунды и затем скрываем аватар
          setTimeout(() => {
            img.remove();
            resolve(githubUser); // (**)
          }, 3000);
        }))

        // 6. Выполянем какое-то дейстиве после отображения-скрытия аватара
        .then(githubUser => alert(`Закончили показ ${githubUser.name}`));

  //B. Тот же вариант с .async
  async function showAvatar() {

    // 1. Запрашиваем с сервера JSON с данными пользователя
    let response = await fetch('/src/user.json');
  
    // 2. Загружаем данные в формате json
    let user = await response.json();
  
    // 3. Запрашиваем информацию об этом пользователе с GitHub
    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  
    // 4. Загружаем ответ в формате json
    let githubUser = await githubResponse.json();
  
    // 5. Показываем аватар (githubUser.avatar_url)
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);
  
    // ждём 3 секунды и затем скрываем аватар
    await new Promise((resolve, reject) => setTimeout(resolve, 3000));
    img.remove();

    // 6. Выполянем какое-то дейстиве после отображения-скрытия аватара
    return githubUser;
  }
  showAvatar();
  ````

***

- Функция `getAmount()` вызывает две асинхронные функции — `getUser()` и `getBankBalance()`.<br>
  Можно сделать это через `.then`, но конструкция `async/await` позволяет решить эту задачу проще и элегантнее.
- ```js
  function getUser(userId) {
    return new Promise(resolve => resolve('Ivan'))
  }
  
  function getBankBalance(user) {
    return new Promise((resolve, rejected) => {
      if (user == 'Ivan') {
        resolve('$1,00')
      } else {
        rejected('unknown user')
      }
    })
  }
  
  // Раньше, с .then
  function getAmount(userId) {
    getUser(userId)
            .then(user => getBankBalance(user))
            .then(money => console.log(money))
  }
  
  // Теперь, с Async/Await
  async function getAmount2(userId) {
    let user = await getUser(userId);
    let money = await getBankBalance(user);
    console.log(money);
  }
  ```

Подробнее этот пример рассмотрен
здесь: [Habr - Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)
<br></p>
</details>

[//]: # (Что нового?)
<details><summary><b>Что нового?</b></summary><p>

- ES8 (2016) — введены Async/Await
- ES13 (2022) — оператор `await` можно использовать вне функции (без `async`). Полезно для загрузки модулей динамически
  или условно?

<br></p>
</details>

**Ссылки**

- [learn.javascript.ru - Async/await](https://learn.javascript.ru/async-await)
- [MDN - Async/await](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Promises)
- [Habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
- [Habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
- [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
- [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://m.habr.com/ru/company/ruvds/blog/340508/)
- [Habr - Поймут даже дети: простое объяснение async/await и промисов в JavaScript](https://habr.com/ru/post/474726/?ysclid=l8aawlijry104453440)
- [Habr - Разница между асинхронной функцией и функцией, возвращающей промис](https://habr.com/ru/post/475260/)
- [Дока - Асинхронность в JS ](https://doka.guide/js/async-in-js/?ysclid=l8abi9sfsv463636739)
  [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://stasonmars.ru/javascript/polnoe-ponimanie-syncronnogo-i-asyncronnogo-javascript-s-async-await/)
- [Ад обратных вызовов](http://callbackhell.ru/)
- [WebDev - ES6 #14 Async/Await (YouTube)](https://youtu.be/b17RVAqp5QA)

- [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
- [Mentanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
- [Habr - Как работать с async/await в циклах JavaScript](https://habr.com/ru/post/435084/)

<br></p>
</details>

[//]: # (Атрибуты async и defer тега script)
<details id="asyncDefer"><summary><b>Атрибуты async и defer тега script</b></summary><p>

Аттрибуты тэга `<script>`. Влияют на то, когда будет загружаться и выполняться этот скрипт. Будет ли заблокирован
парсинг HTML на время загрузки/выполнения или нет.

`Async` — указает браузеру, что скрипт может быть выполнен асинхронно. <br>
Скрипт скачивается асинхронно (параллельно с формированием документа). Как только скрипт загружен - он запускается,
парсер на это время будет приостановлен. Атрибут доступен только для файлов, подключающихся внешне.

`Defer` (анг откладывать) - указывает браузеру, что скрипт должен быть выполнен после того, как HTML-документ будет
полностью разобран. <br>
Скрипт скачивается асинхронно (параллельно с формированием документа). И после получения - скрипт не запускается сразу,
а ждёт, пока документ будет полностью сформирован.

**Где расположен элемент `<script>` ?**
Асинхронное и отложенное выполнения наиболее важны, когда элемент `<script>` не находится в самом конце документа.
HTML-документы парсятся по порядку, с открытия `<html>` до его закрытия. Если внешний JavaScript-файл размещается
непосредственно перед закрывающим тегом `</body>`, то использование async и defer становится менее уместным, так как
парсер к тому времени уже разберёт большую часть документа, и JavaScript-файлы уже не будут оказывать воздействие на
него.

**Async - скрипт самодостаточен**

Для файлов, которые не зависят от других файлов и/или не имеют никаких зависимостей, атрибут async будет наиболее
полезен. Поскольку нам не важно, когда файл будет исполнен, асинхронная загрузка — наиболее подходящий вариант.

**Defer - скрипт полагается на полностью разобранный DOM**

Во многих случаях файл скрипта содержит функции, взаимодействующие с DOM. Или, возможно, существует зависимость от
другого файла на странице. В таких случаях DOM должен быть полностью разобран, прежде чем скрипт будет выполнен. Как
правило, такой файл помещается в низ страницы, чтобы убедиться, что для его работы всё было разобрано. Однако, в
ситуации, когда по каким-либо причинам файл должен быть размещён в другом месте — атрибут defer может быть полезен.

**Синхронный inline - скрипт небольшой и зависим**

Если скрипт является относительно небольшим и/или зависит от других файлов, то, возможно, стоит определить его
инлайново. Несмотря на то, что встроенный код блокирует разбор HTML-документа, он не должен сильно помешать, если его
размер небольшой. Кроме того, если он зависит от других файлов, может понадобиться незначительная блокировка.

**Ссылки**

- [learn.javascript.ru - Внешние скрипты, порядок исполнения](https://learn.javascript.ru/external-script)
- [Асинхронный JavaScript против отложенного](https://habr.com/ru/post/323790/)
- [Разница между async и defer у тега script](https://wp-kama.ru/id_12151/raznitsa-async-defer.html)
- [Атрибут defer](http://htmlbook.ru/html/script/defer)

<br></p>
</details>   

[//]: # (Стрелочные функции)
<details id="arrowFunc"><summary><b>Стрелочные функции</b></summary><p>

Специальный синтаксис создания функций.
Появились в ES6.

**Особенности**

- Не имеют своего `this`. Внутри стрелочных функций тот же `this`, что и снаружи. Удобно в обработчиках событий и
  коллбэках.
- Не имеют своего `arguments`. Используются аргументы внешней «обычной» функции.

**Отличия от bind**

- `.bind(this)` создаёт «связанную версию» функции.
- Стрелка => ничего не привязывает. У функции просто нет this. При получении значения this – оно, как обычная
  переменная, берётся из внешнего лексического окружения.

**Можно ли сделать `.bind` стрелочной функции?**

- нет. У стрелочных функций нет `this`, он всегда будет определяться как контекст, в котором был определен.
- Если требуется привязка this — надо использовать обычную функцию.
- Ошибки не будет, просто не сработает (скорее всего)

**Ссылки**

- [learn.javascript.ru - Стрелочные функции, основы](https://learn.javascript.ru/arrow-functions-basics)
- [learn.javascript.ru - Повторяем стрелочные функции](https://learn.javascript.ru/arrow-functions)
- [learn.javascript.ru](https://learn.javascript.ru/es-function)

<br></p>
</details>

[//]: # (Ключевое слово this. Контекст выполнения)
<details id="this"><summary><b>Ключевое слово `this`. Контекст выполнения</b></summary><p>

`this` — текущий контекст исполнения функции.<br>
Ссылка на некий объект, к свойствам которого можно получить доступ внутри вызова функции. <br>
Т.е. это ссылка на какой-то внешний объект, у которого я беру свойства или методы. На какой объект указывает эта ссылка
— зависит от того как я вызываю функцию. Вызывая одну и ту же функцию разными способами я могу получать разные
значения `this`

Методы могут ссылаться на объект (в котором они вызваны) через `this`.

Значение `this` определяется во время исполнения кода.

- При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не
  будет вызвана.
- Функция может быть скопирована между объектами (из одного объекта в другой).
- Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.
  Т.е. `this` = слово слева от точки :)

**4 варианта вызова функции в JS**

- Обычный вызов функцию:
  - `say('Hello!')`
  - в **use strict** — значение `this` ===  `undefined`.
  - без **use strict** — значение `this` === `глобальный объект`
  - даже если функция вложена в другую функцию - ничего не меняется. Undefined или глобальный объект.
    - Контекст внутренней функции зависит только от вызова, а не от контекста внешней функции. Пример вызвал метод
      объекта, в нём this === объект, всё ок. Вызвал в этом методе функцию, а вне обратился к this - и тут уже this ===
      undefined/глобальный объект.
    - Чтобы получить ожидаемый this, модифицируйте контекст внутренней функции при помощи непрямого вызова (.call() /
      .apply()) или создайте связанную функцию через .bind()
- Функция является методом объекта
  - `user.say('Hello!'),`
  - this === объект
  - this определяется в момент вызова функции. Если записать метод объекта в переменную и вызвать её без указания
    объекта — теряем привязку к объекту. Нужен `bind`
- Вызов функциии-конструктора
  - `new User()`
  - `this` === свежесозданному объекту, созданному конструктором.
  - конструктор — это функция для создания однотипных объектов.
  - конструкторы вызывают с помощью ключевого слова `new`
  - начиная с ECMAScript 6, JS позволяет определять конструкторы ключевым словом `class`
- Непрямой вызов функции (через `call()` или `apply()`)
  - `say.call(undefined, 'Hello!')`, `say.apply(undefined, 'Hello!')`
  - Оба позволяют настроить контекст снаружи явным образом — первым аргументом принимают `this`.
- Ещё есть метод `bind`
  - `say('Hello!').bind(admin)`,
  - позволяет связывать контекст выполнения с функцией — «заранее и точно» определить, каким будет значение `this`

**Стрелочные функции и `this`**

У стрелочных функций нет `this`.<br>
Когда внутри стрелочной функции обращаются к `this`, то его значение берётся извне. Связываются с ближайшим по иерархии
контекстом, в котором они определены.<br>
Удобно, когда нужно передать в стрелочную функцию, например, родительский контекст без использования `bind()`<br>
При использовании обычной функции внутри контекст бы потерялся, и чтобы добиться того же результата, нам бы пришлось
использовать `call()`, `apply()` или `bind()`

**Контекст выполнения**
У каждого вызова функции есть свой «контекст выполнения» (execution context).

Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя
локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.

При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных –
«стеке контекстов».

**Ссылки**

- [Habr - Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/company/ruvds/blog/422089/)

**Также смотри темы**

- Замыкания - Lexical Environment и [[Environment]]
- Стрелочные функции
- "Call" & "apply"
- Bind
- Глобальный объект
- Use strict
- Объекты, прототипы
- Модули
- Callback

**Ссылки**

- [learn.javascript.ru - Методы объекта, "this"](https://learn.javascript.ru/object-methods)
- [learn.javascript.ru - Стрелочные функции](https://learn.javascript.ru/arrow-functions)
- [О ключевом слове «this» языка JavaScript: особенности использования с пояснениями](https://tproger.ru/translations/javascript-this-keyword/)
- [MDN - this](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)
- [Дока - this: контекст выполнения функций](https://doka.guide/js/function-context/)
- [Habr - Что записано в this? Закулисье JavaScript-объектов](https://habr.com/ru/company/ruvds/blog/455527/)
- [Habr - Ключевое слово this в JavaScript для начинающих](https://habr.com/ru/company/ruvds/blog/419371/)
- [Habr - Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/company/ruvds/blog/422089/)

<br></p>
</details>   

[//]: # (Bind)
<details id="#bind"><summary><b>Bind</b></summary><p> 

Метод. Позволяет привязать контекст к функции. Важно при callback

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this
предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в
привязанную функцию аргументами при её вызове.

При вызове callback может нарушиться контекст вызова this.<br>
Т.е. отвалиться привязка this к родительскому объекту.

```js
    <App
        addQuote={store.addQuote} //нет скобок после addQuote - функция не выполянется здесь, а передаётся на выполение
/>
```

Не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо, от своего имени.

В таком случае, при создании callback надо сделать привязку контекста - bind

```js 
    <App
        addQuote={store.addQuote.bind(store)}
/>
```

**Ссылки**

- [learn.javascript.ru - bind](https://learn.javascript.ru/bind)
- [code.mu - dind](http://code.mu/javascript/context/bind.html)
- [Habr - Bind, Call и Apply в JavaScript (2013)](https://habr.com/ru/post/199456/)
- [MDN - Function.prototype.bind()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_objects/Function/bind)

<br></p>
</details>

[//]: # ("Call" & "apply" todo: доработать)
<details id="callApply"><summary><b>"Call" & "apply"</b></summary><p>

Методы для явного указания `this` функций

Мы сами устанавливаем контекст, в котором выполняется функция. <br>
Когда мы используем ключевое слово `this` внутри нашей callback-функции, оно ссылается на то, что мы передаём первым
аргументом в `call()/apply`

- `call` — позволяет вызывать функцию, явно устанавливая `this`. Вызывает func с данным контекстом и аргументами. Можно
  заимствовать методы.
- `apply` — более мощный метод. Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию.
  Вызывает func, передавая context как this и псевдомассив args как список аргументов.

**Ссылки**

- [learn.javascript.ru](https://learn.javascript.ru/call-apply-decorators)
- [Habr - Bind, Call и Apply в JavaScript (2013)](https://habr.com/ru/post/199456/)

<br></p>
</details>   

[//]: # (Callback)
<details id="callback"><summary><b>Callback</b></summary><p>

Функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback
– функция обратного вызова).

Сами не вызываем функцию. Отдаём её как аругмент в другую функции, и та вызывает, когда сочтёт нужным.

Чуть сложнее: В JavaScript функции – это объекты. Поэтому функции могут принимать другие функции в качестве аргументов,
а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего
порядка. А любая функция, которая передается как аргумент, называется callback-функцией.

Пример:
``<button onClik={function}>txt</button>``<br>
Когда произойдёт событие onClick, кнопка вызовет эту функцию.
Нет скобок после function - мы не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо. От своего
имени

Неправильно:
``<button onClik={function()}>txt</button>``<br>
Здесь функция не передаётся, а сразу вызывается.

<b>Зачем?</b>
JS - событийно-ориентированный язык. Если функция не отвечает немедленно (например выполянет AJAX-запрос или Timeout) -
JS не будет останавливать работу, ожидая ответа. Он продолжит выполнение других функций, одновременно ожидая ответа от
нашей функции. Вывод: нельзя просто вызывать функции в нужном порядке и надеяться, что они в обязательно выполнятся в
том же порядке.<br>

Пример:

  ```
    function first(){
      // Как будто бы запрос к API
      setTimeout( function(){
        console.log(1);
      }, 500 );
    }
    function second(){
      console.log(2);
    }
    first();
    second();
    
    //Выдаст ответ:
    // 2
    // 1
  ```

Коллбэки позволяют нам быть уверенными в том, что определенный код не начнет исполнение до того момента, пока другой код
не завершит исполнение.

При вызове callback может нарушиться контекст вызова this. Т.е. отвалиться привязка this к родительскому объекту.

  ```
  <App
      addQuote={store.addQuote}
    />
  ```

В таком случае, при создании callback надо сделать привязку контекста - bind

  ```
    <App
      addQuote={store.addQuote.bind(store)} 
    />
  ```

Функции call() и apply() - ещё один способ вызова callback-функции. Здесь мы сами устанавливаем контекст, в котором
выполняется функция. Это означает, что когда мы используем ключевое слово this внутри нашей callback-функции, оно
ссылается на то, что мы передаём первым аргументом в call()/apply. (см. ниже)

Пример:

  ```
  function showFullName() {alert(что-нибудь)}
  
  var user = {что-то}
  
  function_name.call(user); // вызываем колбек и в качестве контекста this передаём ему user

  ```

  ***

Коллбэки являются самым распространённым средством выражения и выполнения асинхронных действий в программах на
JavaScript. Более того, коллбэк является наиболее фундаментальным асинхронным шаблоном языка. Бесчисленное множество
JS-приложений, даже весьма хитроумных и сложных, основано исключительно на коллбэках.

  ***
Обратные вызовы — фундаментальная часть JavaScript (поскольку являются просто функциями), и вы должны научиться читать и
писать их прежде, чем переходить к более продвинутым функциям языка, так как все они зависят от понимания обратных
вызовов. Если вы пока не можете написать удобный для поддержки код обратных вызовов, то продолжайте работать над этим.

Ссылки:

- [Habr - Понимание callback-функций (колбеков)](https://habr.com/ru/post/151716/)
- [hexlet](https://ru.hexlet.io/blog/posts/javascript-what-the-heck-is-a-callback)
- [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://m.habr.com/ru/company/ruvds/blog/340508/)
- [Ад обратных вызовов](http://callbackhell.ru/)

<br></p>
</details>

[//]: # (Cамовыполняющиеся функции. Модули)
<details id="modules"><summary><b>Самовыполняющиеся функции. Модули</b> ( function(){} )()</summary><p>

**Анонимные функции и функциональыне выражения**

Анонимная функция — функция, которая объявляются в месте использования и не получаtт уникального имени.

Есть «Function Expression» (функциональное выражение) - синтаксис объявления функций:

```  
var f = function(параметры) {
  // тело функции
};
```  

Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```

Важное отличие Function Expression (и анонимных функций, в частности) - они должны объявляться до их вызова.<br>
Такая функция создается в момент ее запуска в скрипте, а не во время парсинга. Поэтому в коде её надо прописать до её
вызова.

```
//Плохо:
sayHi("Вася");
var sayHi = function(name) {
  alert( "Привет, " + name );
}

//Хорошо:
var sayHi = function(name) {
  alert( "Привет, " + name );
}
sayHi("Вася");
```

См. также Function Expression

Анонимные функции короче, их легче писать. Это удобно (если не надо ссылаться на них в коде). Например в обработчиках.

**Про самовыполняющиеся функции**<br>
В определенной записи анонимные функции могут вызывать сами себя.

```
(function() {
  // код выполняется автоматически
})();
```

Эффект создается пустыми скобками в конце функции.

Главная фишка этого приёма – изоляция области видимости функции.<br>
Переменная, объявленная внутри функции, может быть вызвана только внутри этой функции. В остальном коде данная
переменная не видна. Поэтому переменная внутри самовыполняющейся функции замыкается внутри этой функции. Такую
переменную нельзя случайно вызвать из внешнего кода или переписать.

Эта техника аккуратно инкапсулирует переменные и код, пряча их от глобального пространства имен, чтобы они не вступили в
конфликт с другим кодом. Поэтому полифилы и плагины часто пишутся в виде самовыполняющихся функций.

**Ссылки**

- [Анонимные и самовыполняющиеся функции в JavaScript](https://webformyself.com/anonimnye-i-samovypolnyayushhiesya-funkcii-v-javascript/)
- [learn.javascript.ru - Модули через замыкания](https://learn.javascript.ru/closures-module)
- [learn.javascript.ru - Функциональные выражения](https://learn.javascript.ru/function-declaration-expression)
- [Wikipedia - Анонимная функция](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
- [code.mu - Продвинутая работа с функциями](http://code.mu/books/javascript/advanced/prodvinutaya-rabota-s-funkciyami-javascript.html)
- [WebDev - Модули в JS](https://youtu.be/q_tHi37EMic)
- [learn.javascript.ru - Модули](https://learn.javascript.ru/modules)

<br></p>
</details>

[//]: # (Модули)
<details><summary><b>Модули</b></summary><p>

ES6 (2015)

**Определения**

- переиспользуемая часть кода, содержащая в себе детали реализации и предоставляющая открытое API (позволяет легко
  загрузить её и использовать в другом коде).
- Модуль – это просто файл. Один скрипт – один модуль. Модули могут загружать друг друга и использовать
  директивы `export` и `import`, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого.

**Почему потребовались модули**

- коллизия имён - два разных скрипта могут объявлять одинаковые названия функций и переменных. И затирать друг-друга
- Поддержка большой кодовой базы - в присложении сотнис криптов. Если каждый подключать вручную с помощью
  тэга `<script>` — управлять этим трудно.

**Модульность решает задачи**

- обеспечение поддержки изоляции кода
- определение зависимостей между модулями и легкое управление ими
- доставка кода в среду выполнения.

**Основные возможности модуле**

- Всегда «use strict»
- Своя область видимости переменных - переменные и функции, объявленные в модуле, не видны в других скриптах.
- Код в модуле выполняется только один раз при импорте - если один и тот же модуль используется в нескольких местах, то
  его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.

**script type="module"**

Надо явно сказать браузеру, что скрипт является модулем - атрибутом `<script type="module">`.<br>
Модули не работают локально — только через HTTP(s).

**Особенности в браузере**

- Отложенное (deferred) выполнение по умолчанию.
  - загрузка внешних модулей (например `<script type="module" src="...">`) не блокирует обработку HTML.
  - модули ожидают полной загрузки HTML документа, и только затем выполняются
    - Поэтому модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.
    - Поэтому вначале выполнятся обычные скрипты, потом модули. Даже если модули объявлены выше по коду
  - сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
- Для модулей атрибут `async` работает во встроенных скриптах (а не только на внешних). Скрипты с ним запускаются сразу
  по готовности, не ждут других скриптов или HTML-документа. Полезно, когда модуль ни с чем не связан, например для
  счётчиков, рекламы, обработчиков событий.
- Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
- Дублирующиеся внешние скрипты игнорируются - внешние скрипты с одинаковым атрибутом src запускаются только один раз

**Глобальные переменные**

Переменные объявленные в модулях - видны только в них (надо экспортировать/импортировать). <br>
Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда
получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.

**Циклические зависимости**
При вложенности модулей друг в друга может возникнуть циклическая зависимость:

```
ModuleA -> ModuleB -> ModuleC -> ModuleD -> ModuleA
//если упростить
ModuleA <-> ModuleD
```

ES-модули нативно умеют работать с циклическими зависимостями и корректно их обрабатывать.<br>
Циклические зависимости не всегда могут быть источником явных ошибок и исключений, но могут стать причиной некорректного
поведения кода, которое трудно будет отловить.<br>
Есть несколько хаков, как можно обходить циклические зависимости для некоторые ситуаций, но лучше просто не допускать их
возниковения.

**Прочее**

- `this` на верхнем уровне модуля = undefined. В не-модульных скриптах `this` – глобальный объект (window, например)

- Объект `import.meta` содержит информацию о текущем модуле.

```js
<script type="module">
  alert(import.meta.url); // ссылка на html страницу для встроенного скрипта. Содержимое зависит от окружения. В
  браузере содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML
</script>
```

- В браузере import должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» (
  bare). Они не разрешены в import.

```js
import {sayHi} from 'sayHi'; // Ошибка, "голый" модуль
// путь должен быть, например './sayHi.js' или абсолютный
```

**Import / export**

- `export let user = 'Ivan';` — экспорт до объявления
- `export {user, sayHi};` — экспорт отдельно от объявления
- `import {user, sayHi} from './say.js'`
- `import * as say from './say.js`
- `import {sayHi as hi} from './say.js'`
- `export {sayHi as hi};`
- Default
  - `export default class User {}` — экспорт по-умолчанию
  - `export {sayHi as default}` — тоже экспорт по-умолчанию
  - `import User from './user.js'` — импорт по-умолчанию
  - `import {default as User, sayHi} from './user.js'`  - импорт по-умолчанию + обычный в одной строке
  - `import * as user from './user.js'` `let User = user.default;` — импортировали всё (и default, и обычное), потом
    обратились к default-экспорту (User)
- Реэкспорт
  - `export {default as User} from './user.js'` — реэкспорт
  - `export {default as User}` — реэкспорт default-экспорта (`export User from './user.js'` не сработает).
  - `export * from './user.js'` — реэкспортирует только именованные экспорты, исключая default-экспорт

**Динамический импорт**

Выражение `import(module)` загружает модуль и возвращает промис, результатом которого становится объект модуля,
содержащий все его экспорты.

```
let modulePath = prompt("Какой модуль загружать?");

import(modulePath)
  .then(obj => <объект модуля>)
  .catch(err => <ошибка загрузки, например если нет такого модуля>)
```

Использовать его мы можем динамически в любом месте кода.<br>
Или если внутри асинхронной функции, то можно `let module = await import(modulePath)`.

В "статическом" импорте нельзя:

- Задавать путь к модулю чем-то кроме строки. Вызов функции нельзя<br>

```
import ... from getModuleName(); // Ошибка, должна быть строка
```

- делать импорт в зависимости от условий или в процессе выполнения

```
if(...) {
  import ...; // Ошибка, запрещено
}

{
  import ...; // Ошибка, мы не можем ставить импорт в блок
}
```

**Старые реализации модулей**

ДО ES6 были реализации модулей сторонними библиотеками:

- AMD – одна из самых старых модульных систем, изначально реализована библиотекой require.js.
- CommonJS – модульная система, созданная для сервера Node.js.
- UMD – ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.

**Ссылки**

- [learn.javascript.ru - Модули](https://learn.javascript.ru/modules)
- [Mentanit - Модули в JS](https://metanit.com/web/javascript/19.1.php)
- [Habr - Модули](https://habr.com/ru/company/domclick/blog/532084/)
- [WebDev - Модули в JS](https://youtu.be/q_tHi37EMic)
- [learn.javascript.ru - Модули через замыкания](https://learn.javascript.ru/closures-module)
- [Habr - Эволюция модульного JavaScript (2017)](https://habr.com/ru/company/yandex/blog/192874/)
- [Habr - Путь JavaScript модуля (2013)](https://habr.com/ru/post/181536/)

<br></p>
</details>

[//]: # (Function Declaration, Function Expression)
<details id="funcDeclaration"><summary><b>Function Declaration, Function Expression</b></summary><p>

`Function Declaration` – функция, объявленная в основном потоке кода.

- `function sayHi() {...}`
- создаются интерпретатором до выполнения кода. Поэтому их можно вызвать в коде до объявления. Т.е. вверху вызов
  функции, а ниже - её код

`Function Expression` – функции, объявленная в контексте какого-то выражения (например присваивания).

- `var f = function sayHi() {...}`
- создаются интерпретатором в процессе выполнения выражения, в котором созданы. В данном случае – функция будет создана
  при операции присваивания var f = function...
- анонимные функции - частный случай Function Expression

В результате инициализации, к началу выполнения кода:

- Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.
- Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них.

**Ссылки**

- [learn.javascript.ru - Function Declaration / Function Expression](https://learn.javascript.ru/function-expressions)

<br></p>
</details>

[//]: # (Циклы todo: Доработать)
<details id="cycles"><summary><b>Циклы</b></summary><p>

- `while` — многократное выполнение одних и тех же инструкций, пока истинно некоторое условие
- `do... while` — вначале выполняется, потом проверяет условие. Точно выполнится один раз
- `for` — часто используется если известно точное количество повторений. «Цикл со счётчиком».
- `for ... in` — перебор свойств объекта
- `for ... of` — перебор по массиву. Итерируемые объекты
- `for await of` — получение данных с помощью асинхронных итераторов. Перебор в цикле данных, поступающих асинхронно.
  Например: загружаем что-то по частям из сети.

**Ссылки:**

- [learn.javascript.ru - Циклы while и for](https://learn.javascript.ru/while-for)
- [Дока - Циклы](https://doka.guide/js/loop/)
- [MDN - Циклы и итерации](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Loops_and_iteration)
- [Metanit - Циклы](https://metanit.com/web/javascript/2.7.php)
- [Metanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
- [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
- [itchief.ru - Циклы в JavaScript](https://itchief.ru/javascript/loops)
- []()
- []()

<br><p>
</details>

[//]: # (Обработчики событий, events handlers)
<details id="eventsHandlers"><summary><b>Обработчики событий</b> (events handlers)</summary><p>

Блоки кода (обычно функции), которые позволяют обрабатывать события (щелчок мыши...) и реагировать на них.

Когда такой блок кода определяют для запуска в ответ на некое событие, говорят "мы регистрируем обработчик событий".
Иногда обработчики называют прослушивателями событий (event listeners). Термины часто взаимозаменяемы, но вообще: _
прослушиватель_ слушает событие, а _обработчик_ — это код, который запускается в ответ на событие.

Ссылки:

- [learn.javascript.ru](https://learn.javascript.ru/introduction-browser-events)
- [MDN](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F)
- [professorweb.ru](https://professorweb.ru/my/javascript/js_theory/level2/2_5.php)
      
<br></p>
</details>

[//]: # (Web-workers)
<details id="webWorkers"><summary><b>Web-workers</b></summary><p> 

Спецификация Web Workers — позволяет запускать дополнительные JS-процессы(workers).<br>
Способ исполнить код в другом, параллельном потоке.<br> 
Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.

Web Workers могут обмениваться сообщениями с основным процессом, но они имеют свои переменные и свой событийный цикл.<br>
Web Workers не имеют доступа к DOM, поэтому основное их применение – вычисления. Они позволяют задействовать несколько ядер процессора одновременно.

Мы используем их следующим образом: мы проверяем наличие конструктора Worker() в браузере, и, если он доступен, мы создаем экземпляр рабочего объекта с URL-адресом сценария в качестве аргумента. Этот скрипт будет выполняться в отдельном потоке.

**Ссылки**
- [JavaScript Web Workers: руководство для начинающих](https://webdevblog.ru/javascript-web-workers-rukovodstvo-dlya-nachinajushhih/?ysclid=l7id6v4kl6484714219)
- [MDN - Использование Web Workers](https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Using_web_workers)

<br></p>
</details>

[//]: # (Объекты {} и массивы [] todo: Доработать!)
<details><summary><b>Объекты {} и массивы []</b></summary><p>

- ``{ width: 300, height: 200, }`` — объект. Структура для хранения данных в формате ключ-значение.
- ``[ 300, 200, ]``                 - массив. Для хранения пронумерованных значений. Особый тип объектов.

- Объект - структура, пригодная для хранения любых данных. В других языках программирования такую структуру данных также называют «словарь» и «хэш».

  - В JS объекты также используются как элементы ООП, это немного отдельно.

  - Массив - это разновидность объекта. Обладает дополнительными свойствами и ограничениями

  - Массивы обычно используются для хранения _упорядоченных_ коллекций данных, например – списка товаров на странице,
    студентов в группе и т.п. Предлагает дополнительные методы для удобного манипулирования такой коллекцией. Элементы в
    массиве должны идти подряд, иначе теряется большая часть преимуществ этой структуры.

  - Квадратные скобки также позволяют обратиться к свойству объекта, имя которого может быть результатом выражения.
    Например, имя свойства может храниться в переменной:
    let key = "likes birds";
    // то же самое, что и user["likes birds"] = true;
    user[key] = true;
  - Оператор in для проверки существования свойства в объекте
    - "key" in object
    - Если key без кавычек - это не имя свойства, а ссылка на переменную, в которой это имя лежит

Мутирующие / не мутирующие методы (особенной у массивов) - выписать/пометить, заучить

- Объекты
  - Есть разные виды объектов
    - «простой объект» («plain object») или просто Object
    - Array
    - Date
    - Error
    - ...
  - Ключ/имя/идентификатор свойства: значение свойства
  - Создание объекта
    - Конструктор объекта - new
    - Литеральная нотация - {}
  - Доступ к свойству через []
    - Если имя св-ва = n слов (`['key name']`)
    - Если имя св-ва = результат выражения. Например хранится в переменой (`[variable]`),  (`[variable + 'SomeText']`)
    - Если имя св-ва = вычисляемое свойство. Имя будет выдано другой переменной/функцией по результатам ее работы
  - ! Методы объекта (базовые)
    - delete user.age - удаление свойства
    -
    - keys() - возвращает ключи объекта.
    - values() - возвращает значения объекта.
    - entries() - создает вложенный массив пар «ключ-значение» объекта
    -
    - assign() - копирование свойств объекта в другой объект.
    - create() - создать новый объект из существующего.
    -
    - freeze() - «замораживает» объект. Предотваращает изменения свойств и т.д.
    - seal() - предотвращает добавление новых свойств, но позволяет изменять существующие.
    - getPrototypeOf() - получения внутреннего скрытого [[Prototype]] объекта, также доступного через свойство __proto__
      .
    - ... там ещё много. Изучать
    - что-то добавили в последние несколько лет
  - Трансформация объектов
    - У объектов нет множества методов, которые есть в массивах, например map, filter и других.
    - Если нужен аналог - можно использовать метод `Object.entries` с последующим вызовом `Object.fromEntries` :
      1. Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj .
      2. На нём вызываем методы массива, например, map .
      3. Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
  - Спец. св-во `__proto__` — всегда объект
  - Оператор in
    - проверка существования св-ва в объекте.
    - Если св-ва нет - вернёт undefined
    - Позволяет отследить когда свойство есть, но его значение = undefined
    - `'key name' in user`
    - `variable_with_key_name in user`
  - Цикл `for ... in` — перебор всех св-в объекта
    - 
    ```js
        for (key in object) { 
          // выполнится для каждого св-ва объекта
        }
        for (let key in object) { 
          // ... 
                }
    ```
  - Св-ва в объекте упорядочены спец. образом
    - св-ва с целочисленными ключами сортируются по возрастанию
    - остальные располагаются в порядке создания.
    - «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
    - То есть, "49" – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в
      строку, то оно не изменится.
    - А вот свойства "+49" или "1.2" таковыми не являются
  - Объекты хранятся и копируются «по ссылке»
    - Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.
    - Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.
    - Два объекта равны только в том случае, если это один и тот же объект.
      - Операторы `==` и `===` для объектов работают одинаково.
      - две переменные ссылаются на один и тот же объект, поэтому они равны друг другу
      - два разных объекта не равны, хотя оба пусты...
      - Для сравнений вроде `obj1 > obj2` или для сравнения с примитивом `obj == 5` объекты преобразуются в примитивы.
  - Клонирование объектов
    - создать новый объект и повторить структуру дублируемого объекта, перебирая его свойства и копируя
      их (`for ... in`)
    - метод `Object.assign`
    - Глубокое клонирование
      - рекурсивный цикл `for (let key in user) {newObj[key] = oldObj[key];}`
      - JSON-хак `const myDeepCopy = JSON.parse(JSON.stringify(myOriginal))`
      - WebAPI structuredClone `const myDeepCopy = structuredClone(myOriginal);`
      - lodash.cloneDeep(obj)
  - Способы создания метода объекта
    - Отдельно создали функцию, потом присвоили её св-ву объекта
    - Добавляем методу св-во и после = сразу пишем функцию
    - В самом объекте сразу пишем сврва, а после = пишем функцию
    - В самом объекте пишем
    ```js
    // У этих объектов одинаковые методы
        user = { 
              sayHi: function() { 
                alert("Привет"); 
              }
        }; 
  //
  // сокращённая запись
  user = {
  sayHi() {  
  alert("Привет");
  }
  };
  ```
  - Ключевое слово `this`
    - Ключевое слово для доступа из метода объекта к другой информации в этом объекте
    - Значение this - объект перед точкой
    - Не является фиксированным. Его значение вычисляется в момент
    - Вызов функции без объекта:
      - В "use strict"
        - this == undefined
        - в таком коде значением this будет являться undefined . Если мы попытаемся получить доступ к name , используя this.name – это вызовет ошибку.
      - В нестрогом режиме значением this в таком случае будет глобальный объект ( window для браузера).
      - Обычно подобный вызов является ошибкой программирования. Если внутри функции используется this , тогда ожидается, что она будет вызываться в контексте какого-либо объекта.
    - У  стрелочных функций нет «this»
      - Его значение берётся снаружи - из внешней «нормальной» функции. Т.е
    - Методы могут ссылаться на объект через this .
    - Значение this определяется во время исполнения кода.
    - При объявлении любой функции в ней можно использовать this , но этот this не имеет значения до тех пор, пока функция не будет вызвана.
    - Эта функция может быть скопирована между объектами (из одного объекта в другой).
    - Когда функция вызывается синтаксисом «метода» – object.method() , значением this во время вызова является объект перед точкой.
  - Функция конструктор объектов и оператор `new`
    - Чтобы создавать много однотипных функций по шаблону
    - Это обычные функции. Технически любая функция может быть использована как конструктор. То есть, каждая функция может быть вызвана при помощи оператора new , и выполнится алгоритм создания нового объекта из конструктора (см. learnjs )
    - Есть два соглашения:
      1. Имя функции-конструктора должно начинаться с большой буквы.
      2. Функция-конструктор должна вызываться при помощи оператора "new"
    - `new function() { … }` — можно обернуть в коде создание одного большого объекта с большим кодом. Конструктор создаётся и тут же вызывается. Не может быть использован дважды. Инкапсуляция кода создания большого объекта
    - Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.
      - В случае, если функция вызвана при помощи new , то в new.target будет сама функция,в противном случае undefined
      - Можно использовать, чтобы отличить обычный вызов от вызова «в режиме конструктора» => можно обработать этот случай, написать для него свою логику => чтобы функцию можно было вызывать как с, так и без new. Иногда используется в библиотеках. Плохая практика.
    - Return из конструктора
    - Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this , который в итоге станет результатом.
    - Но если return всё же есть, то применяется простое правило:
      - При вызове return с объектом, будет возвращён объект, а не this .
      - При вызове return с примитивным значением, примитивное значение будет отброшено.
    - Другими словами, return с объектом возвращает объект, в любом другом случае конструктор вернёт this
    - В конструкторе можно создавать не только свойства но и методы
  -  Классы
    - Для создания сложных объектов есть и более «продвинутый» синтаксис чем конструктор – классы.

- Массивы
  - Особый тип объекта, предназначенный для работы с упорядоченным набором элементов.
  - Не использовать как объект
    - Добавление нечислового свойства, `arr.test = 5`
    - Создание «дыр», например: добавление arr[0] , затем arr[1000] (между ними ничего нет).
    - Заполнение массива в обратном порядке, например: arr[1000] , arr[999] и т.д.
  - Объявление
    - `let arr = [];`
    - `let arr = new Array();`
      - если вызвать с одним аргументом-числом - создаст массив без элементов, но заданной длины (length)
  - Перебор массива
    - For
      - Перебор по индексам
    - For of
      - выводит значения элементов, но не сообщает их индекс
    - For in
      - метод объектов. Плохая идея
      - Выполняет перебор всех свойств объекта, а не только цифровых
      - В 10-100 раз медленнее, т.к. оптимизирован под обычные объекты
    - Есть метод forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
    - Есть методы преобразования - map, sort и т.д.
  - Lenght
    - Наибольший цифровой индекс +1 (т.к. нумерация с нуля)
    - Можно сказать, это общее число элементов в массиве - если он заполнен без дырок
    - Если уменьшить length - укоротим массив, удалим элементы с конца
  - Многомерные массивы
  - реализация метода toString
    - Возвращает список элементов, разделённых запятыми.
      - alert( [] + 1 ); // "1"
      - alert( [1] + 1 ); // "11"
      - alert( [1,2] + 1 ); // "1,21"
    - Быть аккуратно с бинарным "+" - произведет сложение строк!
      - alert( "" + 1 ); // "1"
      - alert( "1" + 1 ); // "11"
      - alert( "1,2" + 1 ); // "1,21"
  - Методы массивов
    - Push/pop
      - Работают заметно быстрее чем shift/unshift
      - push - добавляет элемент в конец массива
      - pop - удаляет последний элемент из массива и возвращает его
    - Shift/unshift
      - Unshift - добавляет элемент в начало
      - Shift - удаляет первый элемент и возвращает его
    -
    - Добавления/удаления элементов:
      - push (...items) – добавляет элементы в конец,
      - pop() – извлекает элемент с конца,
      - shift() – извлекает элемент с начала,
      - unshift(...items) – добавляет элементы в начало.
      - splice(pos, deleteCount, ...items) – начиная с индекса pos , удаляетdeleteCount элементов и вставляет items .
      - slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end ).
      - concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items . Если
        какой-то из items является массивом, тогда берутся его элементы.
    - Поиска среди элементов:
      - indexOf/lastIndexOf(item, pos) – ищет item , начиная с позиции pos , и
      - возвращает его индекс или -1 , если ничего не найдено.
      - includes(value) – возвращает true , если в массиве имеется элемент value , в
      - противном случае false .
      - find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все
      - значения, при прохождении которых через функцию возвращается true .
      - findIndex похож на find , но возвращает индекс вместо значения.
    - Перебора элементов:
      - forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
    - Преобразования массива:
      - map(func) – создаёт новый массив из результатов вызова func для каждогоэлемента.
      - sort(func) – сортирует массив «на месте», а потом возвращает его.
      - reverse() – «на месте» меняет порядок следования элементов напротивоположный и возвращает изменённый массив.
      - split/join – преобразует строку в массив и обратно.
      - reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и
        передавая промежуточный результат между вызовами.
    - Дополнительно:
      - Array.isArray(arr) проверяет, является ли arr массивом.
    -
    - Есть другие методы, используются реже
    - Добавить свежие методы 2017-2022
    - Мутирующие - изменяют исходный массив
      - sort
      - reverse
      - splice
-

- Псевдомассивы
  - объекты, у которых есть индексы и свойство length, т. е., они выглядят как массивы.
- Деструктурирующее присваивание
  - Специальный синтаксис, который позволяет «распаковать» массивы или объекты в кучу переменных,
    - так как иногда они более удобны. Т
    - когда мы передаём объекты/массивы в функцию, то ей может понадобиться не объект/массив целиком, а элементы по
      отдельности - здесь и нужна деструктуризация
  - Также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
  - Ничего не делает с исходным массивом/объектом, только копирует. Просто более короткий вариант записи
  - Пропускайте элементы, используя запятые
  - Работает с любым перебираемым объектом с правой стороны - Set и т.д.
  - Присваивайте чему угодно с левой стороны - например свойствам объекта
- Инструкции
  - это синтаксические конструкции и команды, которые выполняют действия. «Строки программы». Отделяются точкой с
    запятой

**Методы объектов**

- keys() - возвращает ключи объекта.
- values() - возвращает значения объекта.
- create() - создать новый объект из существующего.
- freeze() - «замораживает» объект. Предотваращает изменения свойств и т.д.
- seal() - предотвращает добавление новых свойств, но позволяет изменять существующие.
- assign() - копирование свойств объекта в другой объект.
- entries() - создает вложенный массив пар «ключ-значение» объекта
- getPrototypeOf() - получения внутреннего скрытого [[Prototype]] объекта, также доступного через свойство __proto__
-
- ... там ещё много. Изучать
- что-то добавили в последние несколько лет
-
- [Некоторые методы объектов](https://techrocks.ru/2021/10/27/40-javascript-methods-you-should-know/#object)

**Методы массивов**

- push(...items) – добавляет элементы в конец,
- pop() – извлекает элемент из конца,
- shift() – извлекает элемент из начала,
- unshift(...items) – добавляет элементы в начало.
- [splice](https://learn.javascript.ru/array-methods#splice) - добавлять, удалять и заменять элементы.
- [slice](https://learn.javascript.ru/array-methods#slice) - создаёт новый массив и копирует в него нужные эл-ты
- [concat](https://learn.javascript.ru/array-methods#concat) - создаёт новый массив и копирует в него данные из
  старых
- [forEach](https://learn.javascript.ru/array-methods#perebor-foreach) - перебор
- [indexOf/lastIndexOf и includes](https://learn.javascript.ru/array-methods#indexof-lastindexof-i-includes) - поиск
  в массиве
- [find и findIndex](https://learn.javascript.ru/array-methods#find-i-findindex) - поиск
- [filter](https://learn.javascript.ru/array-methods#filter) - поиск
- [map](https://learn.javascript.ru/array-methods#map) - преобразование
- [sort(fn)](https://learn.javascript.ru/array-methods#sort-fn) - сортировка «на месте»
- [reverse](https://learn.javascript.ru/array-methods#reverse) - смена порядка элементов на обратный
- [split и join](https://learn.javascript.ru/array-methods#split-i-join) - разбивка/объединение
- [reduce/reduceRight]()
- [Array.isArray](https://learn.javascript.ru/array-methods#array-isarray) - отличить массив от объекта
  - 
- НОВЫЕ
- `findLast()` и `findLastIndex()` — поиск в массивах «с конца
- `at()` — обращаться к массивам с конца. И строкам тоже
- `flat()` и `flatMap()` — рекурсивно сгладить массивы до заданной глубины и вернуть новый массив. Т.е. многомерный
  массив сделать одномерным.
-
- [ШПАРГАЛКА](https://learn.javascript.ru/array-methods#itogo)
- [Habr - 15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году](https://habr.com/ru/company/plarium/blog/483958/)
  - 
- Чаще всего спрашивают
  - Метод [map](https://learn.javascript.ru/array-methods#map) - преобразование
  - Метод [filter](https://learn.javascript.ru/array-methods#filter)
  - Метод [reduce](https://learn.javascript.ru/array-methods#reduce-reduceright)

Ссылки:

- [learn.javascript.ru - Массивы](https://learn.javascript.ru/array)
- [learn.javascript.ru - Объекты](https://learn.javascript.ru/object)
- [learn.javascript.ru - Шпаргалка Методы массивов](https://learn.javascript.ru/array-methods#itogo)
- [Habr - Несколько полезных кейсов при работе с массивами в JavaScript](https://habr.com/ru/post/279867/)
- [Козлова О - JS Interview Questions. Массивы](https://medium.com/@olgakozlova/javascript-interview-questions-part-i-arrays-e996f6433089)
- [Хватит использовать массивы! Как JavaScript Set ускоряет код](https://proglib.io/p/javascript-sets/)

<br></p>
</details>

[//]: # (Методы массивов)
<details id="arrayMethods"><summary><b>Методы массивов</b></summary><p>

**Основные**

- [push(...items)](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – добавляет элементы в конец,
- [pop()](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – извлекает элемент из конца,
- [shift()](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – извлекает элемент из начала,
- [unshift(...items)](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – добавляет элементы в начало.
- [splice](https://learn.javascript.ru/array-methods#splice) - добавлять, удалять и заменять элементы. **Мутирующий!**
- [slice](https://learn.javascript.ru/array-methods#slice) - создаёт новый массив и копирует в него нужные эл-ты
- [concat](https://learn.javascript.ru/array-methods#concat) - создаёт новый массив и копирует в него данные из
  старых
- [forEach](https://learn.javascript.ru/array-methods#perebor-foreach) - перебор
- [indexOf/lastIndexOf и includes](https://learn.javascript.ru/array-methods#indexof-lastindexof-i-includes) - поиск
  в массиве
- [find и findIndex](https://learn.javascript.ru/array-methods#find-i-findindex) - поиск
- [filter](https://learn.javascript.ru/array-methods#filter) - поиск
- [map](https://learn.javascript.ru/array-methods#map) - преобразование
- [sort(fn)](https://learn.javascript.ru/array-methods#sort-fn) - сортировка «на месте». **Мутирующий!**
- [reverse](https://learn.javascript.ru/array-methods#reverse) - смена порядка элементов на обратный.  **Мутирующий!**
- [split и join](https://learn.javascript.ru/array-methods#split-i-join) - разбивка/объединение
- [reduce/reduceRight]()
- [Array.isArray](https://learn.javascript.ru/array-methods#array-isarray) - отличить массив от объекта

**Новые**

- [findLast()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast)
  и [findLastIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex)
  — поиск в массивах «с конца
- [at()](https://learn.javascript.ru/array#poluchenie-poslednih-elementov-pri-pomoschi-at) — обращаться к массивам с
  конца. И строкам тоже
- [flat()](https://ru.hexlet.io/blog/posts/flat-i-flatmap-novye-metody-dlya-raboty-s-massivami-v-ecmascript)
  и [flatMap()](https://ru.hexlet.io/blog/posts/flat-i-flatmap-novye-metody-dlya-raboty-s-massivami-v-ecmascript) —
  рекурсивно сгладить массивы до заданной глубины и вернуть новый массив. Т.е. многомерный массив сделать одномерным.
  - [flat)()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) на MDN
  - [flatMap()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap) на MDN

**Чаще всего спрашивают**

- [map](https://learn.javascript.ru/array-methods#map) - преобразование
- [filter](https://learn.javascript.ru/array-methods#filter)
- [reduce](https://learn.javascript.ru/array-methods#reduce-reduceright)

**Мутирующие методы**

- [(fn)](https://learn.javascript.ru/array-methods#sort-fn) - сортировка «на месте».
- [reverse](https://learn.javascript.ru/array-methods#reverse) - смена порядка элементов на обратный.
- [splice](https://learn.javascript.ru/array-methods#splice) - добавлять, удалять и заменять элементы.

**Шпаргалки**

- [learn.javascript.ru - Шпаргалка](https://learn.javascript.ru/array-methods#itogo)
- [Habr - 15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году](https://habr.com/ru/company/plarium/blog/483958/)

**Ссылки**

- [learn.javascript.ru - Шпаргалка](https://learn.javascript.ru/array-methods#itogo)
- [Habr - 15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году](https://habr.com/ru/company/plarium/blog/483958/)
- [Habr - Область видимости переменной в Javascript (ES4-5)](https://habr.com/ru/post/78991/)

<br><p>
</details>

[//]: # (Деструктуризация массивов)
<details id="destruct"><summary><b>Деструктуризация массивов</b></summary><p>

const [fruit, setFruit] = useState('банан');

Такой синтаксис в JS называется «деструктуризацией массивов (array destructuring)».
Он означает, что мы создаём две новые переменные, fruit и setFruit.
Во fruit будет записано первое значение, вернувшееся из useState, а в setFruit — второе.

Это равносильно такому коду:

  ```
    var fruitStateVariable = useState('банан'); // Возвращает пару значений
    var fruit = fruitStateVariable[0]; // Извлекаем первое значение
    var setFruit = fruitStateVariable[1]; // Извлекаем второе значение
  ```

Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть массив из двух
элементов. Первый элемент обозначает текущее значение, а второй является функцией, позволяющей менять это значение.

**Ссылки:**

- [learn.javascript.ru - Деструктуризация](https://learn.javascript.ru/destructuring)
- [learn.javascript.ru - Деструктурирующее присваивание](https://learn.javascript.ru/destructuring-assignment)
- [Деструктуризация в ES6. Полное руководство](https://medium.com/@stasonmars/%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-es6-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-b865bb71f376)
- [Habr - Вы не знаете деструктуризацию, пока](https://habr.com/ru/company/otus/blog/530248/)
- [Medium - Learn the basics of destructuring props in React](https://www.freecodecamp.org/news/the-basics-of-destructuring-props-in-react-a196696f5477/)
- [IT-Kamasutra #90 - Про деструктуризацию props в функциональных компонентах](https://youtu.be/JtbSOJKRJAI?t=1785)
- [IT-Kamasutra #90 - Про деструктуризацию props в классовых компонентах](https://youtu.be/JtbSOJKRJAI?t=3352)
- [Дэн Абрамов - Чем функциональные компоненты React отличаются от компонентов, основанных на классах? (см. про деструктуризацию props)](https://habr.com/ru/company/ruvds/blog/444348/)

<br></p>
</details>

[//]: # (Методы объектов)
<details id="objectMethods"><summary><b>Методы объектов</b></summary><p>

**Методы конструктора Object**

- [assign()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) - копирование
  свойств объекта в другой объект.
  - При объединении двух объектов с `Object.assign` первый объект мутируется. Другие объекты остаются неизменными.
- [create()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create) - создать
  новый объект из существующего.
- [keys()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) - возвращает
  массив ключей объекта (имена всех **собственных** перечислимых свойств объекта).
- [values()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values) -
  возвращает значения объекта.
- [freeze](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) - «замораживает»
  объект. Другой код не сможет удалить или изменить никакое свойство.
- [seal](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) - предотвращает
  добавление новых свойств, но позволяет изменять существующие.
- [entries()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) - создает
  вложенный массив пар «ключ-значение» объекта
- [defineProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
  - Добавляет к объекту именованное свойство, описываемое переданным дескриптором.
- [defineProperties](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)
  - Добавляет к объекту именованные свойства, описываемые переданными дескрипторами.
- [getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)
  - Возвращает дескриптор свойства для именованного свойства объекта.
- [getOwnPropertyDescriptors](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)
  - возвращает все собственные дескрипторы свойств данного объекта.
- [getOwnPropertyNames](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)
  - Возвращает массив, содержащий имена всех переданных объекту <strong>собственных</strong> перечисляемых и
    неперечисляемых свойств.
- [getOwnPropertySymbols](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)
  - Возвращает массив всех символьных свойств, найденных непосредственно в переданном объекте.
- [getPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)
  - - получение внутреннего скрытого свойства [[Prototype]] объекта (оно также доступно через свойство `__proto__`)
- [is](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is) - Определяет, являются
  ли два значения различимыми (то есть, одинаковыми)
- [isExtensible](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible) -
  Определяет, разрешено ли расширение объекта.
- [isFrozen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen) -
  Определяет, был ли объект заморожен.
- [isSealed](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed) -
  Определяет, является ли объект запечатанным (sealed).
- `observe()` — асинхронно наблюдает за изменениями в объекте.
- [preventExtensions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)
  - Предотвращает любое расширение объекта.
- [setprototypeof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)
  - Устанавливает прототип (т.е. внутреннее свойство `[[Prototype]]`)
- [fromEntries](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) -
  преобразует список пар ключ-значение в объект. Обратное методу `Object.entries`.
- [hasOwn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn) (en) -
  проверять
  является ли св-во прямым свойством объекта, даже если его значение null или undefined. В отличие от оператора `in` -
  не проверяет это свойство в цепочке прототипов объекта.
- [hasOwnProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)
  - проверять содержит ли объект указанное неунаследованно) свойство, или метод.
- [isPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf)
  - проверяет существует ли указанный объект в цепочке прототипов другого объекта
- [propertyIsEnumerable](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable)
  - является ли указанное свойство перечисляемым. Перечисляемые - все свойства, которые добавляются к объекту, являются
    перечисляемыми по умолчанию. Встроенные свойства не перечисляется.
- [setPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)
  - позволяет установить или изменить прототип указанному объекту.Создаваемый объект наследует свойства от прототипа.
- [toLocaleString](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString)
  - возвращает строку, представляющую объект. Предназначен для переопределения унаследованными объектами в целях
    поддержки зависимости от локали.
- [toString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString) -
  возвращает строку, представляющую объект.
- [valueOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf) - для
  преобразования объекта в примитивное значение.

**Устаревшие**

- [__
  defineGetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__)
  - привязывает свойство объекта к функции, вызываемой каждый раз при поиске этого свойства. Вместо
  него `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)`
- [__
  defineSetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__)
  - привязывает свойство объекта к функции, вызываемой каждый раз при попытке установить значение этого свойства. Вместо
  него рекомендуется
  использовать `(синтаксис инициализатора объекта (new Object(), Object.create() или литеральную нотацию)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Object_initializer)`
  или `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)`
- [__
  lookupGetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__)
  - возвращает функцию, привязанную к геттеру указанного свойства. Вместо
  него `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)`
  и `[getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)`
- [__
  lookupSetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__)
  - возвращает функцию, привязанную к сеттеру указанного свойства. Вместо
  него `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)`
  и `[getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)`
- [__proto__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) - является
  свойством доступа (комбинацией геттера и сеттера), которое расширяет внутренний прототип [[Prototype]] объекта (
  являющийся объектом или null), через который осуществлялся доступ. Вместо него `Object.getPrototypeOf`
  /`Object.setPrototypeOf`
  /`[Object.create(proto, [descriptors])]((https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create)) `
  .

**Новые**

- [hasOwn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn) (en) — ES13 (
  2022). проверяет: принадлежит ли св-во этому объекту? Или оно унаследовано / не существует?
- [fromEntries](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) —
  ES10 (2019). преобразует список пар ключ-значение в объект. Обратное методу `Object.entries`.

**Про мутирование объектов**

- При объединении двух объектов с `Object.assign` первый объект мутируется. Другие объекты остаются неизменными.
- Object.freeze предотвращает непосредственное изменение свойств объекта.

**Шпаргалки**

- [MDN - Методы конструктора Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object#methods)

**Ссылки**

- [Некоторые методы объектов](https://techrocks.ru/2021/10/27/40-javascript-methods-you-should-know/#object)
- [Habr - Работа с объектами в JavaScript: теория и практика](https://habr.com/ru/post/48542/)
- [8 методов объектов в JavaScript (2018)](https://www.8host.com/blog/metody-obektov-v-javascript/)
- [40 методов JavaScript, которые вы должны знать](https://techrocks.ru/2021/10/27/40-javascript-methods-you-should-know/#object)
- [MDN - Методы конструктора Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object#methods)

<br><p>
</details>

[//]: # (Копирование объектов todo: Доработать!)
<details id="objectCopy"><summary><b>Копирование объектов</b></summary><p>

Копирование обычное

- цикл `for (let key in user) { newObj[key] = oldObj[key] }`
- Object.assign

Копирование глубокое

- рекурсивный цикл `for (let key in user) {newObj[key] = oldObj[key];}`
- JSON-хак `const myDeepCopy = JSON.parse(JSON.stringify(myOriginal))`
- WebAPI structuredClone `const myDeepCopy = structuredClone(myOriginal);`
- lodash.cloneDeep(obj)

<br><p>
</details>

[//]: # (Преобразование объектов в примитивы)
<details id="objectToPrimitive"><summary><b>Преобразование объектов в примитивы</b></summary><p>

Вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве аргумента.

Существует всего 3 типа преобразований (хинтов):

- "string" (для alert и других операций, которым нужна строка)
- "number" (для математических операций)
- "default" (для некоторых операций)

В спецификации явно указано, какой хинт должен использовать каждый оператор. И существует совсем немного операторов,
которые не знают, что ожидать, и используют хинт со значением "default" . Обычно для встроенных объектов хинт "default"
обрабатывается так же, как "number" . Таким образом, последние два очень часто объединяют вместе.

Алгоритм преобразований к примитивам следующий:

1. Сначала вызывается метод obj[Symbol.toPrimitive](hint) , если он существует.
2. Иначе, если хинт равен "string" происходит попытка вызвать obj.toString() , затем obj.valueOf() , смотря что
   есть.
3. Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf() , затем obj.toString() ,
   смотря что есть.

На практике довольно часто достаточно реализовать только obj.toString() как «универсальный» метод для всех типов
преобразований, возвращающий «читаемое» представление объекта, достаточное для логирования или отладки.

**Ссылки:**

- [learn.javascript.ru - Преобразование объектов в примитивы](https://learn.javascript.ru/object-toprimitive)

<br><p>
</details>

[//]: # (Декораторы)
<details id="decorators"><summary><b>Декораторы</b></summary><p>

Декораторы позволяют добавить метаданные классам и функциям.<br>
Тем самым изменить их поведение без изменения их кода.

По сути - обычная функция. Оборачивает некую сущность и модифицирует её поведение. Похоже на High Order Components.

**Ссылки**

- [Mentanit - Декораторы в TS](https://metanit.com/web/typescript/6.1.php8)
- [WebDev - Декораторы в TS](https://youtu.be/1-lWrocbnK8)
- [Habr - Разбираем декораторы ES2016](https://habr.com/ru/post/277021/)
- [learn.javascript.ru - Декораторы и переадресация вызова, сall/apply](https://learn.javascript.ru/call-apply-decorators)

  <br></p>

</details>

[//]: # (Декоратор Debounce)
<details id="debounce"><summary><b>Декоратор Debounce (Дебаунс)</b></summary><p>

"Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.<br>
Превращает несколько вызовов функции в течение определенного времени в один вызов.<br>
Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова.

Если дословно переводить — «устранение дребезга».

Ссылки:

- [Legmo - Программирование](../Programming/Programming.md)
- [learn.javascript.ru - Сделать Debounce](https://learn.javascript.ru/task/debounce)
- [doka - Сделать Debounce на примере формы поиска](https://doka.guide/js/debounce/)
- [Habr - Debouncing с помощью React Hooks](https://habr.com/ru/post/492248/)
- [Habr - Debouncing с помощью React Hooks: хук для функций](https://habr.com/ru/company/domclick/blog/510616/)
- [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)

  <br></p>

</details>

[//]: # (Декоратор Throttling)
<details id="throttling"><summary><b>Декоратор Throttling (Тротлинг)</b></summary><p>

Данный декоратор позволяет «затормозить» функцию — функция будет выполняться не чаще одного раза в указанный период,
даже если она будет вызвана много раз в течение этого периода. Т.е. все промежуточные вызовы будут игнорироваться.

Ссылки:

* [Habr - Декораторы](https://habr.com/ru/post/60957/)
* [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)

<br></p>
</details>

[//]: # (Переменные var, let и const)
<details id="variables"><summary><b>Переменные var, let и const</b></summary><p>


Не надо объявлять переменные без указания директивы (например var или let).

```js
//Т.е. так писать не стоит
a = 1

//Надо так
var a = 1
let a = 1
const a = 1
```

**Var**

- Устаревший способ объявления переменной.
- Область видимости переменной var – функция.
- var существуют и до объявления. Они равны undefined.
- При использовании в цикле у нас будет одна var на все итерации цикла. Не создаётся заново в каждой итерации.
  Способ объявления переменной. Используем если будем переопределять значение переменной. Видна в блоке

**Let**

- Область видимости переменной let – блок {...}, в котором объявлена.<br>
- Это, в частности, влияет на объявления внутри if, while или for.
- let видна только после объявления. До тех пор их просто нет.
- При использовании в цикле, для каждой итерации создаётся своя переменная.
- Введена в язык в ES6 (ES-2015)

**Const**

- Способ объявления переменной. Используем для констант
- Объявление const задаёт константу, то есть переменную, которую нельзя менять. При попытке изменения выдаст ошибку.
- Eсли в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё.
- В остальном - аналогичная let.
- Функции обычно лучше создавать через const.
- Вообще хороший вариант объявления чего-то, что мы не собираемся менять.
- В случае использования const современные JavaScript-движки могут выполнить ряд дополнительных оптимизаций.
- Введена в язык в ES6 (ES-2015)

**Константы и `const`**

Константы, которые жёстко заданы всегда, во время всей программы, обычно пишутся в верхнем регистре. <br>
Например: const ORANGE = "#ffa500".

Большинство переменных – константы в другом смысле: они не меняются после присвоения. <br>
Но при разных запусках функции это значение может быть разным. <br>
Для таких переменных можно использовать const и обычные строчные буквы в имени.

Использование `const` вместо `var` / `let` не говорит о том, что значение является константой или что оно иммутабельно (
неизменяемо). Ключевое слово `const` просто указывает компилятору следить за тем, что переменной больше не будет
присвоено никаких других значений.

**Ссылки**

- [learn.javascript.ru - Переменные](https://learn.javascript.ru/variables)
- [learn.javascript.ru - Устаревшее ключевое слово "var"](https://learn.javascript.ru/var)
- [learn.javascript.ru - Переменные: let и const](https://learn.javascript.ru/let-const)
- [Habr - Область видимости переменной в Javascript (ES4-5)](https://habr.com/ru/post/78991/)

<br><p>
</details>

[//]: # (Proxy-объекты)
<details id="proxyObjects"><summary><b>Proxy-объекты</b></summary><p>

Особые объекты, позволяют перехватывать и изменять действия, выполняемые над другими объектами.

В частности, речь идёт о вызове функций, об операциях присваивания, о работе со свойствами, о создании новых объектов, и
так далее.<br>
Эту технологию используют для блокирования прямого доступа к целевому объекту или целевой функции и организации
взаимодействия с объектом или функцией через прокси-объект.

Так выглядит объявление простого прокси-объекта, которому передаётся целевой объект и обработчик:<br>
`let proxy = new Proxy(target, handler);`

**Стандартное поведение объектов**<br>
  Объявим объект, а затем попробуем обратиться к несуществующему свойству этого объекта.
  ```
    let obj = {
      c: "car",
      b: "bike"
    };

    document.write(obj.b, ""); //Результат -> "bike"
    document.write(obj.c, ""); //Результат -> "car"
    document.write(obj.l); 	   //Результат -> "undefined"
  ```
  
  **Использование прокси для объекта**<br>
  Используем обработчик с перехватчиком get. Обработчик передаст целевой объект и запрошенный ключ перехватчику.
  ```
    let handler = {
        get: function(target, name) {
        return name in target ? target[name] : "Key does not exist";
      }
    }

    let obj = {
      c: "car",
      b: "bike"
    };

    let proxyObj = new Proxy(obj, handler);

    document.write(proxyObj.b, ""); //Результат -> "bike"
    document.write(proxyObj.c, ""); //Результат -> "car"
    document.write(proxyObj.l);     //Результат -> "Key does not exist"
  ```
  
  Ссылки:

- [Habr](https://habr.com/ru/company/ruvds/blog/359060/)

  <br></p>
</details>

[//]: # (Функции-генераторы)
<details id="funcGenerators"><summary><b>Функции-генераторы</b> - function* ()</summary><p>
    
  Могут приостанавливать своё выполнение, возвращать промежуточный результат и возобновляться позже.<br>
  Код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором»
  
  Генератор связан с итераторами. В частности, он является итерируемым объектом.
  
  Один генератор может включать в себя другие. Это называется композицией.
  
  **Плоский асинхронный код**
  
  Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
  
  Общий принцип такой:
  - Генератор yield'ит не просто значения, а промисы.
  - Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами
    next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в
    генератор следующим next.
  - Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например,
    возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.

Появились в ES6.

Ссылки:

- [learn.javascript.ru](https://learn.javascript.ru/generator)

<br></p>
</details>

[//]: # (Итераторы)
<details id="iterators"><summary><b>Итераторы</b></summary><p>

Тип объектов, содержимое которых можно перебрать в цикле

По сути - объект, предназначенный для перебора другого объекта.<br>
Например массив, функция-генератор, список DOM-узлов, строка..

Для перебора таких объектов добавлен новый синтаксис цикла: for..of.

Итераторы дают возможность сделать «перебираемыми» любые объекты.

Ссылки:

- [learn.javascript.ru](https://learn.javascript.ru/iterator)

<br></p>
</details>

[//]: # (Лексическое всплытие)
<details id="eventHoisting"><summary><b>Лексическое всплытие</b></summary><p>

Организация процесса обработки события (например клика по div), при котором вначале срабатывают обработчики на целевом
объекте (сам div), потом на его родителе, потом выше...

Отсюда различия между event.target (куда кликнули) и this (где сейчас включился обработчик).

Всплытие можно искуственно прервать (не желательно без чёткой необходимости) - event.stopPropagation() и
event.stopImmediatePropagation().

Обратный процесс называетя Погружение - вообще-то вначале идёт погружение и только потом всплытие.

Бывают особые случаи - например событие focus не всплывает и др.

**Ссылки:**

- [Лексическое всплытие](https://learn.javascript.ru/bubbling-and-capturing)
- [learn.javascript.ru - Всплытие и перехват](https://learn.javascript.ru/event-bubbling)

<br></p>
</details>

[//]: # (Хранение данных в браузере: Cookie, socalStorage, sessionStorage)
<details id="dataStorage"><summary><b>Хранение данных в браузере: Cookie, socalStorage, sessionStorage</b></summary><p>

`Куки` (cookie) – небольшие строки данных, хранятся непосредственно в браузере.<br>
Они являются частью HTTP-протокола, определённого в спецификации RFC 6265.

Обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. <br>
Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

Аутентификация через куки:

- При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным
  уникальным идентификатором сессии («session identifier»).
- Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
- Таким образом, сервер понимает, кто сделал запрос.

можно читать и писать в куки из JS-кода `alert( document.cookie );`, `document.cookie = "user=John";`
Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.

Если куки не имеет спец. параметра - удаляются после закрытия браузера (сессионные куки)<br>
Чтобы помочь куки «пережить» закрытие браузера, мы можем установить значение опций expires или max-age.

Сторонние куки - размещены с домена, отличающегося от страницы, которую посещает пользователь.<br>
в силу своей специфики обычно используются для целей отслеживания посещаемых пользователем страниц и показа рекламы.

***
Объекты веб-хранилища `localStorage` и `sessionStorage` позволяют хранить пары ключ/значение в браузере.

Отличия от куки:

- Не отправляются на сервер при каждом запросе => можем хранить гораздо больше данных. Как минимум 5 мегабайтов данных.
- Сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
- Хранилище привязано к источнику (домен/протокол/порт) — разные протоколы или поддомены определяют разные объекты
  хранилища, и они не могут получить доступ к данным друг друга.

`localStorage`

- объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
- Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.

`sessionStorage`

- sessionStorage существует только в рамках текущей вкладки браузера.
  - Другая вкладка с той же страницей будет иметь другое хранилище.
  - Но оно разделяется между ифреймами на той же вкладке (при условии, что они из одного и того же источника).
- Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.
- Используется реже
- Позволяет разным окнам одного источника обмениваться сообщениями.

**Ссылки:**

- [learn.javascript.ru - Cookie](https://learn.javascript.ru/cookie)
- [learn.javascript.ru - LocalStorage, sessionStorage](https://learn.javascript.ru/localstorage)

  <br></p>

</details>

[//]: # (ООП в JS todo: доработать)
<details><summary><b>ООП в JS</b></summary><p>

  ***
На самом деле, поддержка JS-классов браузерами — не более чем «синтаксический сахар». Эти конструкции преобразуются в те
же базовые структуры, которые уже поддерживаются языком. В результате, даже если пользоваться новым синтаксисом, на
более низком уровне всё будет выглядеть как создание конструкторов и манипуляции с прототипами объектов.

**Поддержка классов ES6 в JS-движке V8**

При подготовке JS-кода к выполнению система производит его синтаксический анализ и формирует на его основе абстрактное
синтаксическое дерево. При разборе конструкций объявления классов в абстрактное синтаксическое дерево попадают узлы типа
ClassLiteral.
  
  В подобных узлах хранится пара интересных вещей. Во-первых — это конструктор в виде отдельной функции, во-вторых — это список свойств класса. Это могут быть методы, геттеры, сеттеры, общедоступные или закрытые поля. Такой узел, кроме того, хранит ссылку на родительский класс, который расширяет класс, для которого сформирован узел, который, опять же, хранит конструктор, список свойств и ссылку на собственный родительский класс.
  
  После того, как новый узел ClassLiteral трансформируется в код, он преобразуется в конструкции, состоящие из функций и прототипов.

**Ссылки:**

- [learn.javascript.ru - ООП в функциональном стиле](https://learn.javascript.ru/oop)
- [learn.javascript.ru - ООП в прототипном стиле](https://learn.javascript.ru/prototypes)
- [Habr - Как работает JS: классы и наследование, транспиляция в Babel и TypeScript](https://habr.com/ru/company/ruvds/blog/415377/)
- [Web-dev - Классы (YouTube)](https://youtu.be/BASquaxab_w)

<br></p>
</details>

[//]: # (Классы)
<details id="classes"><summary><b>Классы</b></summary><p>

Введены в ECMAScript 2015.<br>

В JS используется модель «прототипного наследования»: каждый объект наследует поля (свойства) и методы
объекта-прототипа.
В JS нет таких классов как в Java или Swift, т.е. шаблонов / схем для создания объектов. В прототипном наследовании есть
только объекты.<br>
Классы в JS - «синтаксический сахар» над механизмом прототипного наследования. Более простой способ создания объектов и
организации наследования.

В ООП класс — шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных
и реализация поведения функций или методов. Инструкция, чертёж по которому можно создать автомобиль (объект).

В JS класс — функция для создания объектов. Определяет св-ва и методы объекта.

```js
// создаём класс
class Task {
  // метод «конструктор»
  constructor(isCompleted) {
    this.title = 'Learn JS',
            this._isCompleted = isCompleted
  }

  //  статический метод класса - не наследуется объектами
  static getDefaultData() {
    //...
  }

  // метод класса. Наследуется объектами
  completed() {
    this.isCompleted = true
  }

  // геттер
  get isCompleted() {
    return (this._isCompleted === true) ? 'Task is completed' : 'Task is not completed';
  }
}

//добавляем статическое св-во класса - не наследуется объектами
Task.counter = 0; //лучше объявлять его сразу после создания класса, а не ниже по коду (т.е. до создания кземпляров класса)

//создаём объекты на основе класса (экземпляры класса)
let task1 = new Task(false);
let task2 = new Task(true);
```

**Аксессоры**

Это `геттеры` и `сеттеры` — спец. методы класса для установки и чтения его свойств.<br>
Чтобы случайно не изменить св-ва классе, которые не должны меняться - стараются напрямую св-ва класса не менять.
Используют геттеры и сеттеры.<br>
Снаружи ведут себя как свойства:

```js
    //Вызов обычного метода класса
task.setSomethingData(10);

//Вызов метода-сеттера
task.somethingData = 10;
```

**Ссылки:**

- [WebDev - Классы в JS](https://youtu.be/BASquaxab_w)
- [LearnJS - Классы](https://learn.javascript.ru/class)
- [MDN - Классы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)
- [Habr - JavaScript: полное руководство по классам](https://habr.com/ru/post/518386/)

<br></p>
</details>

[//]: # (Аттрибуты свойств. Флаги, дескрипторы, методы доступа)
<details id="propertiesAttributes"><summary><b>Аттрибуты свойств (Флаги, дескрипторы, методы доступа)</b></summary><p>

У объектов JS есть свойства. В том числе у глобального объекта.<br>
У всех свойств есть имя, значение и `аттрибуты` (флаги конфигурации, метаданные).

Свойства объектов бывают 2 типов:

- `свойства-данные` (data properties) — обычные свойства. Имеют дескрипторы данных.
  - ```js
    let user = {
      name: "John"
    };
    let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
    alert( JSON.stringify(descriptor, null, 2 ) );
    /* дескриптор свойства:
      {
        "value": "John",
        "writable": true,
        "enumerable": true,
        "configurable": true
      }
    */
    ```
- `свойства-аксессоры` (accessor properties) — функции для присвоения/получения значения. Имеют дескрипторы доступа.
  - у такого свойства может быть 2 метода: «геттер» – для чтения и «сеттер» – для записи.
  - Не имеют дескрипторов `value` и `writable`, но имеют функции `get` и `set`.
  - Снаружи объекта выглядят как обычные свойства объекта. «Под капотом» работат как функции.
  - ```js
      let user = {
        name: "John",
        surname: "Smith",
        //заведём «виртуальное» свойство-аксессор fullName.
        //для работы с ним будем испольщовать два метода
        get fullName() {
          //метод-геттер, срабатывает при чтении user.fullName
          return `${this.name} ${this.surname}`;
        }, 
        set fullName(value) {
          //метод-сеттер, срабатывает при записи user.fullName = 'Ivan Petrov'
          [this.name, this.surname] = value.split(" ");
        } 
      };
    ```

`Дескриптор` свойства — объект с описанием свойства: его значение и атрибуты. <br>
Запрашиваем информацию о свойстве объекта (см. методы ниже) - получаем объект-дескриптор с его описанием.<br>
Два типа свойств (св-ва данных / св-ва доступа) => два типа дескрипторов.<br>
Дескриптор может быть только одним из этих двух типов. Не может быть одновременно обоими.

Дескрипторы (флаги, аттрибуты, метаданные):

- дескрипторы данных
  - `enumerable` — св-во перечисляется в циклах / циклы его игнорируют. Например, цикл for..in.
  - `configurable` — св-во можно удалить, а эти атрибуты можно изменять / этого делать нельзя.
  - `writable` — св-во можно изменить / только для чтения.
  - `value` — содержит непосредственно данные, значение свойства.
- дескрипторы доступа (для аксессоров)
  - `enumerable` — св-во перечисляется в циклах / циклы его игнорируют.
  - `configurable` — св-во можно удалить, а эти атрибуты можно изменять / этого делать нельзя.
  - `get` — функция, срабатывает при чтении свойства. Без аргументов
  - `set` — функция, срабатывает при записи свойства. Принимает один аргумент

Когда мы создаём свойство «обычным способом», аттрибуты writable, enumerable, configurable = `true`.

<img src="/Assets/Img/js-descriptor.jpg" title="Схема 1" alt="Схема 1" />

**Методы**

Методы для работы с этими аттрибутами:

- Метод `Object.getOwnPropertyDescriptor` — получить информацию о свойстве.
- Метод `Object.defineProperty.` — изменить свойство.
- Метод `Object.defineProperties(obj, descriptors)` — определять N свойств сразу.
- Метод `Object.getOwnPropertyDescriptors(obj).` — получить все дескрипторы свойств сразу.

Методы ограничения доступ ко всему объекту:

- `Object.preventExtensions(obj)` — запрещает добавлять новые свойства в объект.
- `Object.seal(obj)` — запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих
  свойств.
- `Object.freeze(obj)` — запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable:
  false для всех существующих свойств.

Методы для их проверки:

- `Object.isExtensible(obj)` — возвращает false, если добавление свойств запрещено, иначе true.
- `Object.isSealed(obj)` — возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств
  установлено configurable: false.
- `Object.isFrozen(obj)` — возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих
  свойств установлено configurable: false, writable: false.

**Ссылки**

- [Дескрипторы свойств](https://behemothoz.gitbooks.io/js-learn/content/object/deskriptori-svoistv.html)
- [learn.javascript.ru - Флаги и дескрипторы свойств](https://learn.javascript.ru/property-descriptors)
- [learn.javascript.ru - Свойства - геттеры и сеттеры](https://learn.javascript.ru/property-accessors)
- [Дока - Дескрипторы](https://doka.guide/js/descriptors/)
- [Свойства объектов JavaScript](https://msiter.ru/tutorials/javascript/js_object_properties)
- [Habr - Подводные камни JavaScript](https://habr.com/ru/post/159313)

<br></p>
</details>

[//]: # (Перебор структур данных. Методы «keys», «values», «entries»)
<details id="keysValuesEntries"><summary><b>Перебор структур данных. Методы `keys`, `values`, `entries`</b></summary><p>

Универсальные методы, существует соглашение использовать их для структур данных.<br>
Если бы мы делали собственную структуру данных, нам также следовало бы их реализовать.

- `.keys()`
- `.values()`
- `.entries()`

Вариант 1

- Поддерживаются для структур:
  - Map
  - Set
  - Array
- Отличие
  - Не надо ничего указывать в скобках - `mapName.keys()`
  - Возвращает перебираемые объект

Вариант 2

- Поддерживаются для структур:
  - Простые объекты
- Синтаксис
  - Object.keys(obj)
  - Object.values(obj)
  - Object.entries(obj)
- Отличие
  - Объект надо указывать в скобках - `Object.keys(objName)` , не `objName.keys()`
  - Возвращает «реальный» массив

**Игнорируют символьные свойства**

- Уточнить - только в простых объектах или также и Map, Set, Array?
- Если требуется учитывать и символьные ключи, то для этого существует отдельный метод Object.getOwnPropertySymbols  ,
  возвращающий массив только символьных ключей.
- Также, существует метод Reflect.ownKeys(obj)  , который возвращает все ключи.

**Ссылки:**

- [learn.javascript.ru - Object.keys, values, entries](https://learn.javascript.ru/keys-values-entries)

<br><p>
</details>

[//]: # (Перебираемые/итерируемые объекты todo: доработать)
<details id="iterable"><summary><b>Перебираемые (итерируемые) объекты</b></summary><p>

`Итерируемые объекты` – объекты, которые реализуют метод Symbol.iterator. можно использовать в цикле for..of

Можно составить свои - нужно добавить в объект метод с именем Symbol.iterator (специальный встроенный Symbol, созданный
как раз для этого).

Встроенные перебираемые объекты

- Массивы
- Строки
- ... (Прописать полный список)

Итерируемые объекты и псевдомассивы — два разных термина

- Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
- Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.

Явный вызов итератора - **дописать**

Метод Array.from

- метод, принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array . После этого мы уже можем
  использовать методы массивов.

**Ссылки:**

- [learn.javascript.ru - Перебираемые объекты](https://learn.javascript.ru/iterable)

<br><p>
</details>

[//]: # (Асинхронная итерация todo: пусто)
<details id="asyncIteratorsGenerators"><summary><b>Асинхронная итерация</b></summary><p>



Ссылки:

- [learn.javascript.ru - Асинхронная итерация](https://learn.javascript.ru/async-iterators-generators)

<br></p>
</details>

[//]: # (Цикл for-await-of todo: пусто)
<details id="cycleForAwaitOf"><summary><b>Цикл for-await-of</b></summary><p>



Ссылки:

- [Цикл for-await-of](https://learn.javascript.ru/async-iterators-generators)

<br></p>
</details>

[//]: # (Опциональная цепочка «?.»)
<details id="optionalChaining"><summary><b>Опциональная цепочка `?.`</b></summary><p>

- Не оператор, а синтаксическая конструкция
- Безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.
- Позволяет без возникновения ошибок обратиться к вложенным свойствам.
- Проверяет левую часть выражения на равенство `null`/`undefined`, и продолжает дальнейшее вычисление, только если это
  не так.
- Переменная перед ?. должна быть объявлена. Если переменной `user` вообще нет, то `user?.anything` приведёт к ошибке

Три формы синтаксиса:

1. `obj?.prop` – возвращает `obj.prop`, если существует `obj`, и `undefined` в противном случае.
2. `obj?.[prop]` – возвращает `obj[prop]`, если существует `obj`, и `undefined` в противном случае.
3. `obj.method?.()` – вызывает `obj.method()`, если существует `obj.method`, в противном случае возвращает `undefined`

**Используется в сокращённых вычислениях**

- немедленно останавливает вычисление, если левой части не существует.
- таким образом, последующие вызовы функций или операции не будут выполнены.

**Вызовы `?.()` и `?.[]`**

Используется для вызова потенциально несуществующей функции. <br>
В следующем примере не у всех пользователей есть метод `admin`

```js
let userAdmin = {
  admin() {
    alert("Я админ");
  }
};

let userGuest = {};
userAdmin.admin?.(); // Я админ
userGuest.admin?.(); // ничего не произойдет (такого метода нет)
```

**delete**

Кроме этого, `?.` можно совместно использовать
с `delete`:  `delete user?.name; // Удалить user.name, если пользователь существует`

**Не злоупотребляйте опциональной цепочкой**

Нам следует использовать ?. только там, где нормально, что чего-то не существует.

К примеру, если, в соответствии с логикой нашего кода, объект user должен существовать, но address является
необязательным, то нам следует писать user.address?.street, но не user?.address?.street.

В этом случае, если вдруг user окажется undefined, мы увидим программную ошибку по этому поводу и исправим её. В
противном случае, если слишком часто использовать ?., ошибки могут замалчиваться там, где это неуместно, и их будет
сложнее отлаживать.

**Ссылки:**

- [learn.javascript.ru — Опциональная цепочка '?.'](https://learn.javascript.ru/optional-chaining)

<br><p>
</details>

[//]: # (Коллекции todo: доработать)
<details id="collections"><summary><b>Коллекции</b></summary><p>

[//]: # (Map)
<details><summary><b>Map</b></summary><p>

- коллекция ключ/значение, как и Object. Позволяет использовать ключи любого типа, в том числе может использовать
  объекты в качестве ключей
  - Map -подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их
    вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
- Отличия от обычного объекта Object
  - Что угодно может быть ключом, в том числе и объекты.
  - Есть дополнительные методы, свойство size
- Как объект Map сравнивает ключи
  - Nan
- Цепочка вызовов map.set
- Перебор Map
  - 3 метода
  -
    + Метод forEach - похож на метод массива
  - перебор Map происходит в том же порядке, в каком происходило добавление элементов.
  - Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это –
    неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
- Создание Map - можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации
- Метод Object.entries - делает Map из Object
- Метод Object.fromEntries - делает Object из Map
- Основные методы и свойства
  - new Map()
  - map.set(key, value) – записывает по ключу key значение value .
  - map.get(key) – возвращает значение по ключу или undefined , если ключ key отсутствует.
  - map.has(key) – возвращает true , если ключ key присутствует в коллекции, иначе false .
  - map.delete(key) – удаляет элемент по ключу key .
  - map.clear() – очищает коллекцию от всех элементов.
  - map.size – возвращает текущее количество элементов.

<br><p>
</details>

[//]: # (Set)
<details><summary><b>Set</b></summary><p>

- «множество» значений (без ключей), где каждое значение может появляться только один раз.
- Основные методы
  - new
  - add
    - при повторных вызовах set.add() с одним и тем же значением ничего не происходит => каждое значение появляется один
      раз.
  - delete
  - has
  - clear
  - size
  -
- Те же встроенные методы, что и Map :
  - set.values() – возвращает перебираемый объект для значений,
  - set.keys() – то же самое, что и set.values() , присутствует для обратной совместимости с Map ,
  - set.entries() – возвращает перебираемый объект для пар вида [значение, значение] , присутствует для обратной
    совместимости с Map
- Альтернатива Set
  - массив для хранения значений + доп. код для проверки уже имеющегося элемента с помощью `arr.find` .
  - Но в этом случае будет хуже производительность, потому что arr.find проходит весь массив для проверки наличия
    элемента.
  - Множество Set лучше оптимизировано для добавлений, оно автоматически провеяется на уникальность
- Перебор Set
  - Метод for..of
  - используя forEach
  - Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это –
    неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя

<br><p>
</details>

[//]: # (WeakMap)
<details><summary><b>WeakMap</b></summary><p>

- ключи в WeakMap должны быть объектами, а непримитивными значениями
- WeakMap не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
- Если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из
  объекта WeakMap ) автоматически.
- Зачем нужен
  - В основном, WeakMap используется в качестве дополнительного хранилища данных.
    - Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим
      сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то
      WeakMap – как раз то, что нужно.
  - Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться (
    «кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат,
    повторно используя его. Для хранения результатов мы можем использовать Map
  - WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения
    объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap
    или в WeakSet , то он будет удалён автоматически.
- Методы:
  - weakMap.get(key)
  - weakMap.set(key, value)
  - weakMap.delete(key)
  - weakMap.has(key)
- Не поддерживает перебор и методы keys() , values() , entries() , так что нет способа взять все ключи или значения из
  неё.

<br><p>
</details>

[//]: # (WeakSet)
<details><summary><b>WeakSet</b></summary><p>

- можем добавлять в WeakSet только объекты (не примитивные значения). Set -подобная коллекция, которая хранит только
  объекты и удаляет их, как только они становятся недостижимыми иными путями.
- WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта.
  Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в
  WeakSet , то он будет удалён автоматически.
- Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
- Поддерживает add , has и delete , но не size , keys() и не является перебираемой.
- Зачем
  - служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет».
    Присутствие во множестве WeakSet может что-то сказать нам об объекте. Например, мы можем добавлять пользователей в
    WeakSet для учёта тех, кто посещал наш сайт

<br><p>
</details>

**Ссылки:**

- [learn.javascript.ru - Map и Set](https://learn.javascript.ru/map-set)
- [learn.javascript.ru - WeakMap и WeakSet](https://learn.javascript.ru/weakmap-weakset)

<br><p>
</details>

[//]: # (Объект Error)
<details id="errorsObject"><summary><b>Объект Error</b></summary><p>

7 встроенных видов ошибок, также можно создать свои собственные.

Конструктор `Error` создаёт объект ошибки.<br>
Экземпляры объекта Error выбрасываются при возникновении ошибок во время выполнения.

Встроенные ошибки генерируются самим движком JS, пользовательские — создаются с помощью конструктора Error.<br>
Ошибки можно ловить в конструкции `try...catch`.

Вызов конструктора `new Error()` возвращает объект ошибки со следующими свойствами:

- `name` — имя типа (класса) ошибки.
- `message` — человекопонятное описание ошибки для встроенных типов (SyntaxError, TypeError и так далее) и переданное в
  конструктор значение для общего типа Error.

```js
const commonError = new Error('Общая ошибка. Проверьте код')
console.log(commonError.message) // 'Общая ошибка. Проверьте код'
console.log(commonError.name) // 'Error'

```

**Встроенные ошибки движка JS**

- `SyntaxError` — опечатки. Неверные названия методов, лишние/отсутствующие точки с запятой или скобки и т.д.
- `ReferenceError` — попытка обратиться к несуществующей переменной
- `TypeError` — попытка обратиться к несуществующему свойству. Недопустимый тип переменной или параметра.
- `RangeError` — для значений, которые выходят за диапазон допустимого. Слишком большая длина массива и т.д.
- `URIError` — при неправильном использовании обработки URI. Передача неверных параметров в `encodeURI()`
  или `decodeURI()`
- `EvalError` — ошибка в глобальной функции `eval()`
- `nternalError (не стандарт)` — ошибка в движке JS. Не является стандартом, почти не используется.
- `AggregateError` — представить несколько ошибок в виде одной комбинированной. Например, Promise.any(), когда все
  promises завершились в rejected. ЕS12(2021)

**Ссылки:**

- [doka.guide - Error](https://doka.guide/js/errors/)
- [MDN - Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)
- [Habr - Error](https://habr.com/ru/company/ruvds/blog/431078/)
- [Mentanit - Error](https://metanit.com/web/javascript/16.3.php)

<br><p>
</details>

[//]: # (Утечки памяти в JS todo: доработать)
<details id="memoryLeak"><summary><b>Утечки памяти в JS</b></summary><p>

В двух словах, утечки памяти можно определить как фрагменты памяти, которые больше не нужны приложению, но по какой-то
причине не возвращённые операционной системе или в пул свободной памяти.

Языки программирования используют разные способы управления памятью. Однако, проблема точного определения того,
используется ли на самом деле некий участок памяти или нет, как уже было сказано, неразрешима. Другими словами, только
разработчик знает, можно или нет вернуть операционной системе некую область памяти.

1. Глобальные переменные - неявное объявление<br>
   Пример:
    ```  
      function foo(arg) {
        bar = "скрытая глобальная переменная"; // это то же: window.bar = "явно объявленная глобальная переменная";
      }
    ```    
    Решение: добавляйте 'use strict'; в начало JavaScript-файлов
        
  2. **Глобальные переменные** - явно объявленные, не вычищенные (кэши и т.д.)<br>
  
  Это касается глобальных переменных, использующихся для временного хранения и обработки больших блоков данных. Если вам нужна глобальная переменная, чтобы записать в неё большое количество информации, убедитесь, что в конце работы с данными её значение будет установлено в null или переопределено. <br>
  Примером увеличенного расхода памяти, связанным с глобальными переменными, являются кэши — объекты, которые сохраняют повторно используемые данные. Для эффективной работы их следует ограничивать по размеру. Если кэш увеличивается без ограничений, он может привести к высокому расходу памяти, поскольку его содержимое не может быть очищено сборщиком мусора.
  
  ***
  
  В JavaScript используется интересный подход к работе с необъявленными переменными. Обращение к такой переменной создаёт новую переменную в глобальном объекте. В случае с браузерами, глобальным объектом является window. Рассмотрим такую конструкцию:
  ```
  function foo(arg) {
      bar = "some text";
  }
  ```  
  
  Она эквивалентна следующему коду:
  ```
  function foo(arg) {
      window.bar = "some text";
  }
  ```
  
  Если переменную bar планируется использовать только внутри области видимости функции foo, и при её объявлении забыли о ключевом слове var, будет случайно создана глобальная переменная.
  
  В этом примере утечка памяти, выделенной под простую строку, большого вреда не принесёт, но всё может быть гораздо хуже.
  
  Другая ситуация, в которой может появиться случайно созданная глобальная переменная, может возникнуть при неправильной работе с ключевым словом this:
  ```
  function foo() {
      this.var1 = "potential accidental global";
  }
  // Функция вызывается сама по себе, при этом this указывает на глобальный объект (window),
  // this не равно undefined, или, как при вызове конструктора, не указывает на новый объект
  foo();
  ```
  
  Для того, чтобы избежать подобных ошибок, можно добавить оператор "use strict"; в начало JS-файла. Это включит так называемый строгий режим, в котором запрещено создание глобальных переменных вышеописанными способами. Подробнее о строгом режиме можно почитать здесь.
  
  Даже если говорить о вполне безобидных глобальных переменных, созданных осознанно, во многих программах их слишком много. Они, по определению, не подвергаются сборке мусора (если только в такую переменную не записать null или какое-то другое значение). В частности, стоит обратить пристальное внимание на глобальные переменные, которые используются для временного хранения и обработки больших объёмов данных. Если вы вынуждены использовать глобальную переменную для хранения большого объёма данных, не забудьте записать в неё null или что-то другое, нужное для дальнейшей работы, после того, как она сыграет свою роль в обработке большого объёма данных.
  
  3. **Таймеры или забытые коллбэки**<br> 
    Пример:
    ``` 
      var someResource = getData();
      setInterval(function() {
          var node = document.getElementById('Node');
          if(node) {
              // Сделаем что-нибудь с node и someResource.
              node.innerHTML = JSON.stringify(someResource));
          }
      }, 1000);
    ```
    
  В JS-программах использование функции setInterval — обычное явление.
  
  Большинство библиотек, которые дают возможность работать с обозревателями и другими механизмами, принимающими коллбэки, заботятся о том, чтобы сделать недоступными ссылки на эти коллбэки после того, как экземпляры объектов, которым они переданы, становятся недоступными. Однако, в случае с setInterval весьма распространён следующий шаблон:
  ```
  var serverData = loadData();
  setInterval(function() {
      var renderer = document.getElementById('renderer');
      if(renderer) {
          renderer.innerHTML = JSON.stringify(serverData);
      }
  }, 5000); //Это будет вызываться примерно каждые 5 секунд.
  ```
  
  В этом примере показано, что может происходить с таймерами, которые создают ссылки на узлы DOM или на данные, которые в определённый момент больше не нужны.
  
  Объект, представленный переменной renderer, может быть, в будущем, удалён, что сделает весь блок кода внутри обработчика события срабатывания таймера ненужным. Однако, обработчик нельзя уничтожить, освободив занимаемую им память, так как таймер всё ещё активен. Таймер, для очистки памяти, надо остановить. Если сам таймер не может быть подвергнут операции сборки мусора, это будет касаться и зависимых от него объектов. Это означает, что память, занятую переменной serverData, которая, надо полагать, хранит немалый объём данных, так же нельзя очистить.
  
  В случае с обозревателями, важно использовать явные команды для их удаления после того, как они больше не нужны (или после того, как окажутся недоступными связанные объекты).
  
  Раньше это было особенно важно, так как определённые браузеры (старый добрый IE6, например) были неспособны нормально обрабатывать циклические ссылки. В наши дни большинство браузеров уничтожают обработчики обозревателей после того, как объекты обозревателей оказываются недоступными, даже если прослушиватели событий не были явным образом удалены. Однако, рекомендуется явно удалять эти обозреватели до уничтожения объекта. Например:
  ```
  var element = document.getElementById('launch-button');
  var counter = 0;
  function onClick(event) {
     counter++;
     element.innerHtml = 'text ' + counter;
  }
  element.addEventListener('click', onClick);
  // Сделать что-нибудь
  element.removeEventListener('click', onClick);
  element.parentNode.removeChild(element);
  // Теперь, когда элемент выходит за пределы области видимости,
  // память, занятая обоими элементами и обработчиком onClick будет освобождена даже в старых браузерах,
  // которые не способны нормально обрабатывать ситуации с циклическими ссылками.
  ```
  
  В наши дни браузеры (в том числе Internet Explorer и Microsoft Edge) используют современные алгоритмы сборки мусора, которые выявляют циклические ссылки и работают с соответствующими объектами правильно. Другими словами, сейчас нет острой необходимости в использовании метода removeEventListener перед тем, как узел будет сделан недоступным.
  
  Фреймворки и библиотеки, такие, как jQuery, удаляют прослушиватели перед уничтожением узлов (при использовании для выполнения этой операции собственных API). Всё это поддерживается внутренними механизмами библиотек, которые, кроме того, контролируют отсутствие утечек памяти даже если код работает в не самых благополучных браузерах, таких как уже упомянутый выше IE 6.
  
  
  4. **Забытые обработчики событий**<br>
    Обработчики следует удалять, когда они становятся не нужны, или ассоциированные с ними объекты становятся недоступны.<br> 
    В прошлом это было критично, так как некоторые браузеры (Internet Explorer 6) не умели грамотно обрабатывать циклические ссылки.<br> 
    Большинство современных браузеров удаляет обработчики событий, как только объекты становятся недостижимы. <br>
    Однако по-прежнему правилом хорошего тона остаётся явное удаление обработчиков событий перед удалением самого объекта.<br>
    Рекомендуется явно удалять обработчики событий (removeEventListener) до удаления DOM-узлов или обнулять ссылки внутри обработчиков.<br>
  
  5. **Замыкания**
  
  Одна из важных и широко используемых возможностей JavaScript — замыкания. Это — внутренняя функция, у которой есть доступ к переменным, объявленным во внешней по отношению к ней функции. Особенности реализации среды выполнения JavaScript делают возможной утечку памяти в следующем сценарии:
  ```
  var theThing = null;
  var replaceThing = function () {
    var originalThing = theThing;
    var unused = function () {
      if (originalThing) // ссылка на originalThing
        console.log("hi");
    };
    theThing = {
      longStr: new Array(1000000).join('*'),
      someMethod: function () {
        console.log("message");
      }
    };
  };
  setInterval(replaceThing, 1000);
  ```
  
  Самое важное в этом фрагменте кода то, что каждый раз при вызове replaceThing, в theThing записывается ссылка на новый объект, который содержит большой массив и новое замыкание (someMethod). В то же время, переменная unused хранит замыкание, которое имеет ссылку на originalThing (она ссылается на то, на что ссылалась переменная theThing из предыдущего вызова replaceThing). Во всём этом уже можно запутаться, не так ли? Самое важное тут то, что когда создаётся область видимости для замыканий, которые находятся в одной и той же родительской области видимости, эта область видимости используется ими совместно.
  
  В данном случае в области видимости, созданной для замыкания someMethod, имеется также и переменная unused. Эта переменная ссылается на originalThing. Несмотря на то, что unused не используется, someMethod может быть вызван через theThing за пределами области видимости replaceThing (то есть — из глобальной области видимости). И, так как someMethod и unused находятся в одной и той же области видимости, ссылка на originalThing, записанная в unused, приводит к тому, что эта переменная оказывается активной (это — общая для двух замыканий область видимости). Это не даёт нормально работать сборщику мусора.
  
  Если вышеприведённый фрагмент кода некоторое время поработает, можно заметить постоянное увеличение потребления им памяти. При запуске сборщика мусора память не освобождается. В целом оказывается, что создаётся связанный список замыканий (корень которого представлен переменной theThing), и каждая из областей видимости этих замыканий имеет непрямую ссылку на большой массив, что приводит к значительной утечке памяти.
  
  Эту проблему обнаружила команда Meteor, у них есть отличная статья, в которой всё это подробно описано.
  
  6. Ссылки на удалённые из DOM элементы **Ссылки на объекты DOM за пределами дерева DOM**
                                           
  Иногда может оказаться полезным хранить ссылки на узлы DOM в неких структурах данных. Например, предположим, что нужно быстро обновить содержимое нескольких строк в таблице. В подобной ситуации имеет смысл сохранить ссылки на эти строки в словаре или в массиве. В подобных ситуациях система хранит две ссылки на элемент DOM: одну из них в дереве DOM, вторую — в словаре. Если настанет время, когда разработчик решит удалить эти строки, нужно позаботиться об обеих ссылках.
  ```
  var elements = {
   button: document.getElementById('button'),
   image: document.getElementById('image')
  };
  function doStuff() {
   image.src = 'http://example.com/image_name.png';
  }
  function removeImage() {
   // Изображение является прямым потомком элемента body.
   document.body.removeChild(document.getElementById('image'));
   // В данный момент у нас есть ссылка на #button в
   // глобальном объекте elements. Другими словами, элемент button
   // всё ещё хранится в памяти, она не может быть очищена сборщиком мусора.
  }
  ```
                                           
   Есть ещё одно соображение, которое нужно принимать во внимание при создании ссылок на внутренние элементы дерева DOM или на его концевые вершины.
   
   Предположим, мы храним ссылку на конкретную ячейку таблицы (тег <td>) в JS-коде. Через некоторое время решено убрать таблицу из DOM, но сохранить ссылку на эту ячейку. Чисто интуитивно можно предположить, что сборщик мусора освободит всю память, выделенную под таблицу, за исключением памяти, выделенной под ячейку, на которую у нас есть ссылка В реальности же всё не так. Ячейка является узлом-потомком таблицы. Потомки хранят ссылки на родительские объекты. Таким образом, наличие ссылки на ячейку таблицы в коде приводит к тому, что в памяти остаётся вся таблица. Учитывайте эту особенность, храня ссылки на элементы DOM в программах.
   
  **Как оптимизизровать JS-часть сайта?**
  - Проверьте зависимости проекта. Избавьтесь от всего ненужного.
  - Разделите код на небольшие фрагменты вместо того, чтобы складывать его в один большой файл.
  - Откладывайте, в тех ситуациях, когда это возможно, загрузку JS-скриптов. При обработке текущего маршрута пользователю можно выдавать только тот код, который необходим для нормальной работы, и ничего лишнего.
  - Используйте инструменты разработчика и средства вроде DeviceTiming для того, чтобы находить узкие места своих проектов.
  - Используйте средства вроде Optimize.js для того, чтобы помочь парсерам определиться с тем, какие фрагменты кода им
    нужно обработать как можно скорее.

**Ссылки**

- [Habr](https://habr.com/ru/post/309318/)
- [Habr - Как работает JS: управление памятью, четыре вида утечек памяти и борьба с ними](https://habr.com/ru/company/ruvds/blog/338150/)

<br></p>
</details>

[//]: # (Чистота кода todo: доработать)
<details id="codeCleaning"><summary><b>Чистота кода</b></summary><p>

**Общее**

- Форматирование кода направлено на передачу информации, а передача информации является первоочередной задачей
  профессионального разработчика.
- Фигурные скобки в одном стиле
- Кавычки в одном стиле
- Точка с запятой - ставить
- Длина строки - 120 символов
- Отступы горизонтальные - не нарушать структуру
- Отступы вертикальные - не более 9 строк кода подряд без вертикального отступа.
- Имя любой сущности должно отвечать на 3 вопроса - "Почему она существует?", "Какие функции выполняет?", "Как она
  используется?"
- Имя переменной – существительное.
- Имя функции – глагол или начинается с глагола.
- Уровней вложенности должно быть немного.
- Вначале код, под ним функции
- Большие функции дробить на мелкие
- Функции = Комментарии
- Разумные комментарии - не "Что делает?", а "Как устроено?", "Какие параметры принимает?", "Почему выбрано это
  решение?".
- Принцип единственной обязанности
- Разделение команд и запросов - не смешивать функции, выполняющие запросы (например, получить имя) и функции
  выполняющие команды (например, привести имя к нижнему регистру)
- Слабое *связывание* - это хорошо, сильное - плохо. Сильное связывание = сильная зависимость разных частей программы
  друг от друга.
- Высокий ровень *связности* - хорошо (не путать с сильным связыванием). Низкий - плохо. Высокий - сбор конструкций,
  объединённых общей идеей, в одном месте.
- Изоляция кода - выделять фрагменты кода в отдельные блоки, основываясь на их предназначении. В качестве таких блоков
  обычно выступают функции.
- Разбивка кода на модули - функции, которые используются похожим образом или выполняют похожие действия, можно
  сгруппировать в одном модуле (или, если хотите, в отдельном классе).
- Признак слаженности команды - читая код, ты не можешь понять, написал его ты, или коллега

**Конкретика**

- Вместо == использовать ===
- Избегать "магических чисел"
- Имя переменной должно раскрывать её сущность
- Чем меньше у функции аргументов — тем лучше (**спорно**). Например, её будет легче тестировать. С другой стороны: если
  у функции N параметров, по первой строчке её объявления сразу видно - что нужно ей передать. Но, больше 5-6 параметров
  - перебор
- если функции нужно более 5-6 парамтеров - стоит подумать об использовании объекта с параметрами.
- Используйте аргументы по умолчанию, отдавая им предпочтение перед условными конструкциями
- Используйте Object.assign для установки свойств объектов по умолчанию
- Не используйте флаги в качестве параметров (isOpen и т.д.). Их использование означает, что функция выполняет больше
  действий, чем следует.
- Не загрязняйте глобальную область видимости
- Не называть логические переменные так, чтобы в их именах присутствовало бы отрицание (notAdmin -> isAdmin)
- Избегайте логических конструкций везде, где возможно. Вместо них используйте полиморфизм и наследование
- ES-классы стоит предпочесть обычным функциям-конструкторам
- Организуйте методы так, чтобы их можно было бы объединять в цепочки - в конце каждой из функций класса нужно
  возвращать this
- Удаляйте неиспользуемый код
- Если описывая, что должна делать функция, вы используете союз «и» - эта функция слишком сложна
- Функция должна решать одну задачу
- Большие функции стоит перерабатывать в классы. Если функция решает много задач, сильно связаных друг с другом, в
  которых используются одни и те же данные - имеет смысл переделать её в объект с методами
- Если имя функции отвечает на некий вопрос - она должна возвращать значение, а не менять состояние данных.
- Если имя функция "что-то делает" - она должна менять данные и не должна ничего возвращать
- Жёстко заданные ID в функциях - признак сильного связывания
- Несколько сильно завиясщих друг от друга функций, по сути = одна большая, просто разделённая на части. Избегай этого
- Если возникла необходимость модифицировать класс из-за изменений другого класса - это признак сильного связывания
- Если несколько функций используют одни и те же переменные - они должны быть сгруппированы. Хороший повод объединить их
  в объект.
- Одна и та же строка кода не должна повторяться дважды. Повторяющийся код — это надёжный признак низкого уровня
  связности. Плохо.
- Одни и те же данные не должны храниться в более чем одной переменной. Если определяете переменные с одинаковыми
  данными в разных местах программы - используйте класс.
- Если вы передаёте ссылку на один HTML-элемент в несколько функций - можно сделать ссылку частью экземпляра некоего
  класса.
- Не стоит собирать в одном классе сущности, не имеющие друг к другу никакого отношения.
- Если свойства не используются несколькими методами класса, это может быть признаком низкого уровня связности. Плохо.
- Если методы нельзя использовать в различных ситуациях (или метод вообще не используется) — признак плохой связности.
  Плохо.
- Возвращать что-либо из функций нужно с помощью ключевого слова return.
- Для экспорта самых важных сущностей, объявленных в модуле, используйте возможности экспорта по умолчанию. Для
  второстепенных сущностей можно применить именованный экспорт.
- Используйте деструктурирование
- Задавайте стандартные значения параметров функций
- Не передавайте функциям ненужные данные
- Ограничивайте размер файла. 100 строк - хорошо. 200-300 - приемлемо. Более 400 - не надо
- Вложенность кода не должна превышать четырёх уровней.
- Имена массивов. Массивы обычно содержат в себе наборы каких-то значений. В результате к имени переменной, хранящей
  массив, имеет смысл добавлять букву s. (student*s*)
- Имен алогических значений - имеет смысл начинать с is или has.
- Имена параметров функций, передаваемых стандартным методам массивов - лучше называть с учётом данных, которые в них
  оказываются
- Использование коллбэков ухудшает читабельность кода. Особенно это касается вложенных коллбэков. Где возможно -
  используйте конструкцию async/await
- Подчищать за собой console.log. Лишние выводы захламляют консоль. Использование отладочного кода может негативно
  сказаться на производительности. Но, некоторые логи имеет смысл оставлять. Например — команды, выводящие сообщения об
  ошибках и предупреждения.
- Классы не должны быть длиннее 100 строк кода.
- Методы и функции не должны быть длиннее 5 строк кода.
- Методам следует передавать не более 4 параметров.
- Контроллеры могут инициализировать лишь один объект.

**Книги**

- Макконелл С - Совершенный код

**Руководства по стилю**

- [Google JavaScript Style Guide (en)](https://google.github.io/styleguide/jsguide.html)
- [jQuery JavaScript Style Guide (en)](http://contribute.jquery.org/style-guide/js/)
- [Airbnb JavaScript Style Guide (en)](https://github.com/airbnb/javascript)
- [Airbnb JavaScript Style Guide (ru)](https://github.com/leonidlebedev/javascript-airbnb)
- [Idiomatic.JS (en)](https://github.com/rwaldron/idiomatic.js)
- [Idiomatic.JS (ru)](https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU)
- [Dojo Style Guide (en)](https://dojotoolkit.org/reference-guide/1.10/developer/styleguide.html)
- [JSLint style (en)](https://www.jslint.com/help.html)

**Автоматизированные средства проверки (линтеры)**

- [JSLint](http://www.jslint.com/)
- [JSHint ](http://www.jshint.com/) - вариант JSLint с б*о*льшим количеством настроек

**Ссылки**

- [learnjavascript - Как писать неподдерживаемый код?](https://learn.javascript.ru/write-unmain-code)
- [learnjavascript - Советы по стилю кода](https://learn.javascript.ru/coding-style)
- [Habr - Рекомендации по написанию чистого кода на JavaScript](https://habr.com/ru/company/ruvds/blog/454520/)
- [Habr - JavaScript: путь к ясности кода](https://habr.com/ru/company/ruvds/blog/342404/)
- [Habr - 7 рекомендаций по оформлению кода на JavaScript](https://habr.com/ru/company/ruvds/blog/418631/)
- [Habr - Как писать чистый и красивый код](https://habr.com/ru/company/ruvds/blog/347610/)
- [Habr - Пишем чистый и масштабируемый JavaScript-код: 12 советов](https://habr.com/ru/company/ruvds/blog/452562/)
- [YouTube - Доклад Сэнди Метц о 4 правилах написания чистого кода в объектно-ориентированных языках (en)](https://www.youtube.com/watch?v=npOGOmkxuio)

  <br></p>

</details>

[//]: # (Fetch todo: пусто)
<details id="fetch"><summary><b>Fetch</b></summary><p>

метод реализации асинхронных запросов в нативном JS. Предоставляется
Fetch API

**Ссылки**

- [learn.javascript.ru - Fetch](https://learn.javascript.ru/network)

<br></p>
</details>

[//]: # (XMLHttpRequest todo: пусто)
<details id="xmlHttpRequest"><summary><b>XMLHttpRequest</b></summary><p>

Его современный аналог — fetch

**Ссылки**

- [learn.javascript.ru - XMLHttpRequest](https://learn.javascript.ru/xmlhttprequest)

<br></p>
</details>

[//]: # (Приведение типов todo:пусто)
<details id="typesTransformation"><summary><b>Приведение типов</b></summary><p>



Ссылки:

- [Дока - Приведение типов](https://doka.guide/js/typecasting/#preobrazovanie-tipov)
- [learn.javascript.ru - Приведение типов](https://learn.javascript.ru/type-conversions)

<br></p>
</details>

[//]: # (Оператор нулевого слияния «??» todo:пусто)
<details id="nullishCoalescing"><summary><b>Оператор нулевого слияния (`??`)</b></summary><p>



Ссылки:

- [learn.javascript.ru - Оператор нулевого слияния (`??`)](https://learn.javascript.ru/nullish-coalescing-operator)

<br></p>
</details>

[//]: # (Логические операторы присваивания «&&=», «||=», «??=» todo:пусто)
<details id="logicalAssignment"><summary><b>Логические операторы присваивания `&&=`, `||=`, `??=`</b></summary><p>



Ссылки:

- [Логические операторы присваивания(`&&=`, `||=`, `??=`)](https://techrocks.ru/2021/01/22/logical-assignment-operators-in-javascript/)

<br></p>
</details>

[//]: # (Остаточные параметры и оператор расширения / spread operator «...» todo:пусто)
<details id="spread"><summary><b>Остаточные параметры и оператор расширения, spread operator `...`</b></summary><p>



Ссылки:

- [learn.javascript.ru - Остаточные параметры и оператор расширения / spread (...)](https://learn.javascript.ru/rest-parameters-spread-operator)

<br></p>
</details>

[//]: # (Шаблонные строки/литералы. Теговые шаблоны todo:пусто)
<details id="tmpLiterals"><summary><b>Шаблонные строки / литералы). Теговые шаблоны</b></summary><p>



Ссылки:

- [tproger.ru - Шаблонные строки (шаблонные литералы). Теговые шаблоны](https://tproger.ru/translations/javascript-cheatsheet/#tmpltltrls)

<br></p>
</details>

[//]: # (Параметры функции по умолчанию todo:пусто)
<details id="functDefParam"><summary><b>Параметры функции по умолчанию</b></summary><p>



Ссылки:

- [tproger.ru - Параметры функции по умолчанию](https://tproger.ru/translations/javascript-cheatsheet/#fnctdefparam)

<br></p>
</details>

[//]: # (Рекурсия todo:пусто)
<details id="recursion"><summary><b>Рекурсия</b></summary><p>



Ссылки:

- [learn.javascript.ru - Рекурсия](https://learn.javascript.ru/recursion)
- [Рекурсия](https://code.tutsplus.com/ru/tutorials/understanding-recursion-with-javascript--cms-30346)

<br></p>
</details>

[//]: # (Сборщик мусора todo:пусто)
<details id="garbageCollection"><summary><b>Сборщик мусора</b></summary><p>



Ссылки:

- [learn.javascript.ru - Сборщик мусора](https://learn.javascript.ru/garbage-collection)

<br></p>
</details>

## Приёмы ##

[//]: # (_переменная)
<details><summary><b>_переменная</b></summary><p> 

Общеприянтое соглашение - если название переменной начинается с _ , её не надо менять или читать снаружи объекта.<br>
Это просто соглашение об именовании, которое напоминает разработчику о том, что переменная (свойство) или метод являются
либо private, либо protected, и к ним нельзя получить доступ из-за пределов класса.

Чтоб делать это - используй специальные методы: 
  * сеттеры (set... - присвоить) 
  * геттеры (get... - получить)
  
  **Ссылки**

- [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)

  <br><p>
</details>

[//]: # (ПЕРЕМЕННАЯ)
<details><summary><b>ПЕРЕМЕННАЯ</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной написано ЗАГЛАВНЫМИ, её не надо менять. Это константа.<br>
  
  **Ссылки**   

- [learn.js](https://learn.javascript.ru/variables)
- [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)
   
  <br><p>
</details>

[//]: # (Переменная)
<details><summary><b>Переменная</b></summary><p> 

Общеприянтое соглашение - если название переменной начинается с заглавной, значит это не переменная а класс ООП.<br>
У класса есть методы и всё такое...

**Ссылки**

- [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)

<br><p>
</details>

[//]: # (вызов function с двумя парами скобок)
<details><summary><b>function()()</b></summary><p>

Зачем при вызове функции ставят две двойные скобки?

Функция getFunc() возвращает другую функцию (та что в переменной func).<br>
Вторые скобки нужны чтобы вызвать функцию, которую вернула getFunc().<br>
Если скобки опустить, то return внешней функции вернет Вам не результат а саму функцию.

Пример:

  ```
        var a = 1;
        function getFunc() {
          var a = 2;
          var func = function() { alert(a); };
          return func;
        }
        getFunc()(); // 2, из LexicalEnvironment функции getFunc
  ```

<br></p>
</details>

[//]: # (true && expression)
<details><summary><b>true && expression</b></summary><p>

`true && expression` — всегда вычисляется как expression,

`false && expression` — всегда вычисляется как false.

<br></p>
</details>

[//]: # (Math.ceil)
<details><summary><b>Math.ceil(x)</b> - метод, округляет x в большую сторону</summary><p>

**Ссылки:**

- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)

<br></p>
</details>

[//]: # (Console.log)
<details><summary><b>Console.log</b></summary><p>

Брайзер добавляет глобальную переменную с именем «console» к каждой загруженной веб-странице. Объект содержит много
методов, которые возволят писать на консоль и показывать информацию, проходящую через скрипты.

**Console.dir(object)**<br>
Позволяет смотреть в консоли свойства заданного javascript объекта.<br>
Также когда нужно как-то указать в логах на DOM-узел - лучшего всего использовать методы console.dir() или
console.dirxml(). Они могут перечислить свойства элемента или вывести HTML кода элемента.

При помощи метода console.dir() можно вывести список всех свойств объекта. Выглядит аналогично тому, что Вы бы увидели
во вкладке DOM.

**Группировка**<br>
  Иногда бывает полезно сгруппировать логи для упрощения работы с ними. 
  - console.group()
  - console.groupCollapsed()
  - console.groupEnd()
  ```
    console.group("Overlord");
    console.log("Overlord stuff");
     
    console.group("Lord");
    console.log("Overlord stuff");
     
    console.group("Minion");
    console.log("Minion stuff");
    console.groupEnd();
     
    console.groupCollapsed("Servant");
    console.log("Servant stuff");
  ```
  
  **Раскраска**<br>
  Методы подобные log, но отличающихся внешне: 
  - console.info()
  - console.warn() 
  - console.error()
  
  **Шаблонные строки**<br> 
  console.log(\`Значение переменной = ${var_name}\`)
  
  **Профилирование и замеры**<br>
  Консоль позволяет точно замерять время, используя метод console.time() и console.timeEnd(). Расположите вызов первого из них перед кодом, время исполнения которого хотите замерить, а второго — после.
  ```
  console.time("Execution time took");
  // Some code to execute
  console.timeEnd("Execution time took");
  ```
  Таймеры связаны между собой метками (передаются первым аргументом и могут быть любой строкой), так что Вы можете запустить несколько таймеров одновременно. Когда сработает console.timeEnd(), будет выведено сообщение с меткой и прошедшим временем в миллисекундах.
  
  Помимо замера времени можно профилировать Ваш код и вывести стек профилирования, который подробно показывает, где и сколько времени потратил браузер.
  ```
  console.profile();
  // Some code to execute
  console.profileEnd();
  ```
  
  **Assert**
  Полезно при работе с unit-тестами.
  
  Assert'ы позволяют обеспечивать соблюдение правил в коде и быть уверенным, что результаты выполнения этого кода соответствуют ожиданиям. Метод console.assert() позволяет проводить элементарное тестирование кода: если что-то пойдет не так, будет выброшено исключение. Первым аргументом может быть все, что угодно: функция, проверка на равенство или проверка существования объекта.
  ```
  var a = 1, b = "1";
  console.assert(a === b, "A doesn't equal B");
  ```
  Метод assert принимает условие, которое является обязательным к выполнению (в данном случае простая строгая проверка на равенство) и, вторым аргументом, сообщение, которое будет выведено в консоль вместе с выброшенным исключением, если первое условие не будет выполнено.
  
  **Console.trace()**<br>
  Вывод стека вызовов до текущего момента. Скажет, какие функции есть в стеке, и какие аргументы были переданы каждой. 
  
 
  **Ещё есть** 
  - console.clear - очищает консоль
  - console.count - выводит, сколько раз данный код был выполнен.
  - console.dirxml - выводит XML код элемента
  - console.exception - выводит ошибку и результат trace() для места, откуда она была вызвана
  - console.table - выводит таблицу ([Подробнее](http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/))
  - console.timeStamp - выводит текущий timestamp с текстом, который был передан в name.
  
  **Ссылки:**

- [Habr - Используем console на полную](https://habr.com/ru/post/114483/)
- [Habr - FireBug* Console API](https://habr.com/ru/post/188066/)
- [learn.javascript.ru - строки-шаблоны](https://learn.javascript.ru/es-string)
- [MDN - console.dir](https://developer.mozilla.org/ru/docs/Web/API/console/dir)
- [MDN - console.trace](https://habr.com/ru/post/141042/)
- [Про console.table (en)](http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/)

  <br></p>

</details>


[//]: # (Языки поверх JavaScript)
<details id="metaLanguages"><summary><b>Языки поверх JavaScript</b></summary><p>

Синтаксис JavaScript устраивает не всех - одним он кажется слишком свободным, другим слишком ограниченным, третьи хотят
добавить дополнительные возможности…

Появилось много языков, которые добавляют различные возможности «поверх» JavaScript. Для запуска в браузере они
превращаются в обычный JS-код (при помощи специальных инструментов «трансляторов»).

Это преобразование происходит автоматически и совершенно прозрачно, при этом неудобств в разработке и отладке
практически нет.

Разные языки выглядят по-разному и добавляют разные вещи:

- **CoffeeScript** – «синтаксический сахар» поверх JavaScript. Сосредоточен на большей ясности и краткости кода. Часто
  его любят программисты на Ruby.
- **TypeScript** - сосредоточен на добавлении строгой типизации данных. Предназначен для упрощения разработки и
  поддержки больших систем. Разрабатывается Microsoft.
- **Dart** - не только транслируется в JS, но имеет и свою независимую среду выполнения, которая даёт ему ряд
  возможностей и доступна для встраивания в приложения (вне браузера). Разрабатывается компанией Google.

  **Ссылки:**

- [learn.javascript.ru](https://learn.javascript.ru/intro)

  <br></p>

</details>

<br> 
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*