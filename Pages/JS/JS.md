<h1> Шпаргалка по JavaScript </h1>

<p><i>JavaScript — единственный язык, которым разработчики пользуются, не научившись им пользоваться.</i></p><br><br>

[//]: # (Версии JS. Что нового)
<details id="new"><summary><b>Версии JS. Что нового</b></summary><p>

[//]: # (Новинки 2020-2023)
- <details><summary><b>Новинки 2020-2023</b></summary><p>
  
  - Массивы. Функции `.findlast()` и `.findLastIndex()` — для поиска элементов в массиве.
  - Массивы. Обновление для `Array.prototype` и `TypedArray.prototype` —  теперь можно включать изменения в массив путём возвращения новой копии
  - WeakMap. В качестве ключей для `WeakMap` можно использовать `Symbols`. Раньше для этого допускались только объекты.
  - Описали использование шебангов (последовательность `#!` в начале файла скрипта). Сообщает опер. системе, какой интерпретатор использовать при выполнении скрипта
  - Теггированые шаблонные литералы / Tagged template literals
  - Символы / Symbols
  - Оператор опциональной последовательности / Optional chaining (?.)
  - Оператор нулевого слияния / Nullish coalescing operator (??)
  - import()
  - String.matchAll()
  - Promise.allSettled()
  - BigInt
  - globalThis
  - import.meta
  - export * as… from '...'
  - String.replaceAll()
  - Promise.any()
  - Оператор присваивания нулевого слияния / Nullish coalescing assignment (??=)
  - Оператор присваивания логического И / Logical and assignment (&&=)
  - Оператор присваивания логического ИЛИ / Logical or assignment (||=)
  - WeakRef
  - Разделители числовых литералов / Numeric literal separators
  - await верхнего уровня / Top level await
  - #private
  - Статические члены класса / Static class members
  - Статические блоки инициализации / Static initialization blocks
  - Утверждение импорта / Import assertion (пока доступно только в V8)
  - Индексы совпадений регулярного выражения / RegExp match indices
  - Негативная индексация — метод [1,7,8,5].at(-1)/ Negative indexing
  - Object.hasOwn()
  - Причина ошибки / Error cause

  - **Ссылки**
    - [Habr - Возможности JavaScript и TypeScript последних лет. Часть 1](https://habr.com/ru/companies/timeweb/articles/722450/)

  <br></p>
  </details>

[//]: # (ES 2023)
- <details><summary><b>ES 2023</b></summary><p>

  - Массивы. Функции `.findlast()` и `.findLastIndex()` — для поиска элементов в массиве.
  - Массивы. Обновление для `Array.prototype` и `TypedArray.prototype` —  теперь можно включать изменения в массив путём возвращения новой копии
  - WeakMap. В качестве ключей для `WeakMap` можно использовать `Symbols`. Раньше для этого допускались только объекты.
  - Шебанги. Унифицировали поддержку 
    - это последовательность `#!` в начале файла скрипта
    - сообщает операционной системе, какой интерпретатор использовать при выполнении скрипта
    - позволяет нам использовать Hashbang/Shebang в некоторых CLI. 
    - Унифицированный механизм удаления шебангов для некоторых хостов CLI перед передачей исходных кодов в движки JS
  
  - **Ссылки**
    - [Habr - ECMAScript 2023 добавит в JavaScript новые методы для работы с массивами](https://habr.com/ru/news/728066/)
    - [Habr - Новые возможности ECMAScript 2021-2023](https://habr.com/ru/articles/741372/)
    - [tproger.ru — Что было добавлено в ECMAScript в 2023 году](https://tproger.ru/articles/chto-bylo-dobavleno-v-ecmascript-v-2023-godu?  ysclid=lnbqk7j3dz95808809)
  
  <br></p>
  </details>

[//]: # (ES 2022)
- <details><summary><b>ES 2022</b></summary><p>

  - `await` верхнего уровня в модулях. Раньше await нельзя было использовать вне функций.
    - Гарантия того, что модули не получат доступ к асинхронному импорту, пока они не будут полностью инициализированы;
    - Прозрачная обработка асинхронности: импортёрам не нужно знать, является ли импортируемый модуль асинхронным или нет
    - Позволяет загружать модули условно `if(download) { await require('/script.js') }`. Или позволит просто указать ссылку до другого ресурса, если с первым произошла ошибка. Также можно использовать тот ресурс, который загрузился быстрее
  - Объекты. Метод `Object.hasOwn(obj, propKey)` — безопасный способ проверить, есть ли у объекта obj свое собственное (не наследуемое) свойство с ключом `propKey`.
  - Метод `.at()` для индексируемых значений — получать элемент по заданному индексу, как с `[]`. Поддерживает отрицательные индексы (в отличие от `[]`). Применяется в String, Array, TypedArrays (Uint8Array и т.д.)
    - ```js
      ['a', 'b', 'c'].at(0) //'a'
      ['a', 'b', 'c'].at(-1) //'c'
      ```
  - Классы. Приватные слоты 
    - Приватные поля (приватные поля экземпляра и статические приватные поля)
    - Приватные методы и асессоры (статические и не статические)
  - Классы. Статические блоки инициализации
  - Классы. Параметры (публичные слоты) теперь можно создать с помощью Публичных полей экземпляра Публичных статических полей
  - Классы. Проверка приватных слотов через оператор `in`
  - Индексы совпадений регулярного выражения / RegExp match indices
     - Если добавить флаг `/dк` регулярному выражению, его использование создаст объекты сопоставления, которые записывают начальный и конечный индексы каждого захвата группы. Предоставляет дополнительную информацию о начальных и конечных индексах захваченных подстрок относительно начала входной строки.
  - Свойство `error.cause` или цепочки ошибок — Error и его подклассы теперь позволяют узнать, какая ошибка вызвала текущую.
    - Облегчает диагностику приложения. Свойство `.cause()` в Error позволяет указать какая ошибка вызвала другую ошибку.
    
  - **Ссылки**
    - [Habr - Ecma International утвердила ECMAScript 2022: что в ней нового?](https://habr.com/ru/articles/676032/)
    - [Medium - What’s new in ECMAScript 2022 (en)](https://medium.com/ducktypd/whats-new-in-ecmascript-2022-d459945f07dc)

  <br></p>
  </details>

[//]: # (ES 2021)
- <details><summary><b>ES 2021</b></summary><p>

  - Логические операторы присваивания `&&=`, `||=`, `??=` — «присвоить если...»<br>
    - `user &&= 'A'` — если user === true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp; *user && (user = 'A')*
    - `user ||= 'A'` — если user === false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp; *if(!user)(user = 'A')*
    - `user ??= 'A'` — если user === null или undefined
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *if(user === null || user === undefined)(
    user
    = 'A')*
  - Метод `replaceAll(A, B)` для строк — замена всех подстрок А на B;
  - Разделители разрядов `1_000` — для лучшей читаемости. Работает и с BigInt<br>
    - `let num = 152000000` = `let num = 152_000_000`
  - Метод `Promise.any` — принимает n промисов и возвращает первый успешно завершившийся<br>
    - `Promise.any([promise1, promise2]).then(val => console.log(val)`
  - Объект `AggregateError` — новый тип ошибок.<br>
    - Представить n ошибок в виде одной комбинированной.
    - Например для Promise.any(), если все promises завершились в rejected
  - Приватные методы экземпляров классов и доступа к св-вам — префикс `#`. <br>
    - `#`-методы экземпляров классов доступны только изнутри экземпляра
      класса (`class User { #generateAPIKey() {/**/} }`)<br>
    - `#`-методы доступа к свойствам объектов = приватные геттеры и сеттеры (`get #newPass(){}` и `set #newPass(){}`).
  - API сборщика мусора
    - `WeakRef  API` — обращение к целевому объекту, которое позволяет корректно обработать его сборщиком
      мусора
    - `FinalizationRegistry API` (финализатор) - управление регистрацией операций очистки, при обработке
      объекта сборщиком мусора;<br>
    Регистрируем callback-«финализатор», он запускается когда сборщик мусора уничтожает объект.
  - `Array.prototype.sort` стал более точным.
  - уменьшило количество случаев, которые приводят к сортировке, определяемой реализацией.

  <br></p>
  </details>

[//]: # (ES 2020)
- <details><summary><b>ES 2020</b></summary><p>
  
  - `BigInt` примитив — работа с целыми числами произвольной длины (длиннее чем 2^53).
    - ```js
      const bigint = 1234567890123456789012345678901234567890n;
      const sameBigint = BigInt("1234567890123456789012345678901234567890");
      const bigintFromNumber = BigInt(10); // то же самое, что и 10n
      ```
  - `?` оператор опциональных цепочек — при обращении к свойству объекта сразу проверяем, существует ли оно.
    - ```js
      const obj = {body: {a: 1, b: 2}}
      const value = obj.body?.a
      ```
  - `??` оператор нулевого слияния — проверка на `null` или `undefined`.
    - вместо `let foo = (a !== null && a !== undefined) ? a : b`
    - пишем `let foo = a ?? b`
  - Объект `globalThis` — доступ к глобальному объекту. 
    - В Node.js это global, для Worker это self, в браузере это window. Если приложение исполняется в N средах — писали
      условия.
    - ```js
      //Раньше
      let global = function () {
        if (typeof self !== 'undefined') {
          return self;
        }
        if (typeof window !== 'undefined') {
          return window;
        }
        if (typeof global !== 'undefined') {
          return global;
        }
        throw new Error('unable to locate global object');
      };
      //Теперь
      GlobalThis == this
      ```
  - Динамический импорт — можно импортировать модули в виде промиса
    - ```js
      import('module.js')
        .then(module => {/**/})
        .catch(err => {/**/});
      //Или так
      (async function () {
        const module = await import('module.js')
        /**/
      })();
      ```
  - Комбинатор `Promise.allSettled()` — возвращает промис с массивом состояний промисов.<br>
  - Условие выполнения данного промиса — выполнение всех исходных промисов.
  - Все промисы должны быть завершены (с любым статусом).

  <br></p>
  </details>

[//]: # (ES 2019)
- <details><summary><b>ES 2019</b></summary><p>

  - Методы строк `trimStart()` и `trimEnd()` — удаление пробелов в начале/конце строки
  - Методы массивов `flat()` и `flatMap()` — рекурсивно сгладить массивы до заданной глубины и вернуть новый массив.
  - Т.е. многомерный массив сделать одномерным.
  - Все элементы подмассива (до указанной глубины) рекурсивно объединяются (`Array.prototype.flat(depth=1)`)
  - Метод `Object.fromEntries` — преобразует список пар ключ-значение в объект.
  - Обратное методу `Object.entries`. .
  - Переменная в `catch` в выражении `try… catch` теперь не обязательна.
  - `Catch Binding` стал опциональным — теперь не обязательно иметь привязку переменной исключения к оператору catch.
  - `Array.sort` — изменения.
  - Теперь гарантировано будет стабильным, что означает, что элементы с одинаковым приоритетом сортировки появятся в
    списке.
  - Описание свойства для объектов `Symbol` — при создании Symbol можно добавить описание (для отладки)
  <br>
  
  **Ожидания**
  - **JSON** - подкорректированы символы разделителя строк и абзацев
  - **JSON.stringify** - представление кодов с помощью escape-последовательностей JSON
  - **.toString()** - теперь возвращает точные фрагменты текста исходного кода, включая пробелы и комментарии.
  - **import.meta**
  - **Строковый метод matchAll()**
  - **Стандартизированный Hashbang** для приложений с интерфейсом командной строки (CLI)
  
  - **Ссылки**
    - [Что нового в JavaScript ES2019](https://m.habr.com/ru/post/439532/)
    - [Что нового в JavaScript 2019](https://medium.com/web-standards/es2019-417d8b406346)

  <br></p>
  </details>

[//]: # (ES 2018)
- <details><summary><b>ES 2018</b></summary><p>

  - Оператора `rest` — выглядит как `...`.
  - Извлекать свойства объекта. Используется в левой части выражения.
  - Для литералов объектов
  - Оператор `spread` — тоже выглядит как `...`.
  - Для создания новых объектов. Используется в правой части выражения со знаком присваивания.
    Для литералов объектов
  - Асинхронная итерация, цикл `for-await-of` — создавать циклы, работающие с асинхронным кодом.
  - Вызывать асинхронные функции, возвращающие промисы (или обрабатывать массивы, содержащие промисы) в цикле.
  - Метод `finally()` у объектов Promise — выполнять коллбэк после resolve() или reject().
  - Чтобы корректно завершать операции (например, высвобождая ресурсы).
  - Устранение ограничений тегированных шаблонных строк
  - Больше свободы, что писать в шаблонных строках.
  - Раньше \u запускал переход к unicode, \x запускал переход к хекс, а символ \, за которым следовали цифры, обозначал
    переход к восьмеричным значениям. Это делало невозможным создание определенных строк, таких как путь к файлу Windows
    C:\uuu\xxx\111.
  - Регулярки.
  - Флаг `dotAll` — изменили настройки регулярок. Чтоб работать в новом формате - устанавливаем спец.
    флаг.
  - Захват именованных групп — позволяет писать регулярные выражения с назначением имён (идентификаторов) для групп.
    Облегчает работу с группами.
  - Ретроспективная проверка — узнать, существует ли некая строка сразу перед некоторой другой строкой.
  - Улучшена поддержка Unicode — можно использовать спец. конструкцию для поиска символов не-латинских
    языков(хинди, греческий...)
  
  - **Ссылки**
    - [Официальная спецификация (en)](http://www.ecma-international.org/publications/standards/Ecma-262.htm)
    - [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)
    - [Что нового в ES2018 JavaScript](https://webformyself.com/chto-novogo-v-es2018-javascript/)

  <br></p>
  </details>

[//]: # (ES 2017)
- <details><summary><b>ES 2017</b></summary><p>

  - Конструкция `Async/Await` — асинхронные функции, работают на основе promise
  - Методы строк `padStart()` и `padEnd()` — дополнения строк до заданной длины.
  - подставляет заданные символы в начало строки или её конец.
  - `Висячие запятые` в параметрах функций — теперь их можно ставить после последнего параметра функции.
  - `Разделяемая память` (shared memory) и `атомарные операции` (atomics) — касается ядра JS-движков.
  - Можно самостоятельно управлять памятью, не отдавая выполнение всех аспектов этой задачи JS-движку.
  - Позволяет писать высокопроизводительные параллельные приложения.
  - Для Объектов
  - Метод `Object.values()` — возвращает все значения собственных свойств объект. Исключает любые значения прототипов.
  - Метод `Object.entries()` — возвращает массив с ключами и значениями.
  - Метод `Object.getOwnPropertyDescriptors()` — возвращает все сведения для всех св-в объекта. В т.ч. данные о геттерах
    и сеттерах.
    - Можно создавать мелкие копии объектов и клонировать объекты, создавая новые объекты (копируя при этом геттеры и
      сеттеры, кроме прочего).
      - Упрощает выполнение операций с объектами в циклах, или преобразование обычных объектов в Map.
  
  - **Ссылки**
    - [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/8.0/index.html)
    - [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p>
  </details>

[//]: # (ES 2016)
- <details><summary><b>ES 2016</b></summary><p>

  - Метод `Array.prototype.includes()` — проверяем есть ли в массиве некий элемент.
  - Оператор возведения в степень — `**`. Заменяет `Math.pow()`.
  
  - **Ссылки**
    - [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/7.0/index.html)
    - [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p>
  </details>

[//]: # (ES 2015, ES6)
- <details><summary><b>ES 2015 (ES6)</b></summary><p>

  - const
  - let
  - шаблонные строки
  - параметры функции по умолчанию
  - стрелочный функции
  - ? map
  - ? spred оператор
  - Деструктурирующее присваивание
  - Promises (обещания) - объекты, которые помогают выполнять асинхронные операции (запрос API, обработка файлов, загрузка изображений и т. д.)
  - 
  - [Переменные: let и const](https://learn.javascript.ru/let-const)
  - [Деструктуризация](https://learn.javascript.ru/destructuring)
  - [Функции](https://learn.javascript.ru/es-function)
  - [Строки](https://learn.javascript.ru/es-string) — введены шаблоны, улучшена поддержка Unicode, добавлены методы
  - [Объекты и прототипы](https://learn.javascript.ru/es-object)
  - [Классы](https://learn.javascript.ru/es-class)
  - [Тип данных Symbol](https://learn.javascript.ru/symbol) — для создания уникальных идентификаторов
  - [Итераторы](https://learn.javascript.ru/iterator) — можно сделать "перебираемым любой" объект
  - [Set, Map, WeakSet и WeakMap](https://learn.javascript.ru/set-map) — новые типы коллекций
  - [Promise](https://learn.javascript.ru/promise) — способ организации асинхронного кода
  - [Генераторы](https://learn.javascript.ru/generator) — новый вид функций. Могут приостанавливать своё выполнение, возвращать промежуточный   результат и далее возобновлять выполнение позже.
  - [Модули](https://learn.javascript.ru/modules) — введён официальный стандрат поддержки модулей в JS
  - [Proxy](https://learn.javascript.ru/proxy) — особый объект, перехватывает обращения к другому объекту и, при необходимости, модифицирует их.
  
  - **Ссылки**
    - [Официальная спецификация (en)](https://www.ecma-international.org/ecma-262/6.0/index.html)
    - [learn.js](https://learn.javascript.ru/es-modern)
    - [code.mu](http://code.mu/books/javascript/advanced/novovvedeniya-v-es6-dlya-novichkov.html)
    - [Хабр - Обзор базовых возможностей ES6 (2016)](https://habr.com/ru/post/313526/)

  <br></p>
  </details>

[//]: # (ES 2009, ES 5)
- <details><summary><b>ES 2009 (ES 5)</b></summary><p>

  - Среди изменений:
    - поддержка строгого режима (strict mode);
    - аксессоры getters и setters;
    - возможность использовать зарезервированные слова в качестве ключей свойств и ставить запятые в конце массива;
    - многострочные строковые литералы;
    - поддержка JSON
    - и ещё очень много всего - 10 лет готовили...

  - **Ссылки**
    - [Официальная спецификация (en)](http://ecma-international.org/ecma-262/5.1/)
    - [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
    - [ES5 руководство по JavaScript](https://habr.com/ru/post/281110/)
    - [Перевод спецификации EcmaScript 5 с аннотациями](https://es5.javascript.ru/)

  <br></p>
  </details>

[//]: # (История версий JS/ES)
- <details><summary><b>История версий JS/ES</b></summary><p>

  - JS создавался как скриптовый язык для Netscape. 1997 год.
  - Разработкой занимались Брендан Эйх, Марк Андрессен и Билл Джой.
  - Был отправлен для стандартизации в ассоциацию «ECMA International». Стандартизированная версия называется `ECMAScript`,
  - описывается стандартом `ECMA-262`.
  - 
  - `ECMAScript` — стандарт
  - `JavaScript` — самая популярная реализация этого стандарта, браузерная реализация спецификации. Среди других реализаций: SpiderMonkey, V8 и ActionScript.
  - `ES.Next` — динамический термин, автоматически ссылается на новую версию ECMAScript.
  - 
  - С 2015 язык обновляется ежегодно.
  - 
  - ES1 - 1997
  - ES2 - 1998
  - ES3 - 1999
  - ES4 - не выпущена
  - ES5 - 2009
  - ES6 - 2015
  - ES7 - 2016
  - ES8 - 2017
  - ES9 - 2018
  - ES10 - 2019
  - ES11 - 2020
  - ES12 - 2021
  - ES13 - 2022

  - **Ссылки**
    - [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript](https://tproger.ru/translations/wtf-is-ecmascript/)
    - [Официальная спецификация - актуальная (en)](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
    - [Официальная спецификация - архив (en)](https://www.ecma-international.org/publications/standards/Ecma-262-arch.htm)
    - [Разъяснения насчёт JavaScript, ECMA–262, TC39 и транскомпиляторов ECMAScript](https://www.frontender.info/    javascript-ecma-262-tc39-and-ecmascript-transpilers-explained/)
    - [Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)
    - 
    - [ES6, ES8, ES2017: что такое ECMAScript и чем это отличается от JavaScript (2017)](https://tproger.ru/translations/wtf-is-ecmascript/)
    - [Wikipedia - ECMAScript(en)](https://en.wikipedia.org/wiki/ECMAScript#12th_Edition_%E2%80%93_ECMAScript_2021)
    - [Хабр - Чем отличаются JavaScript и ECMAScript?](https://habr.com/ru/company/nix/blog/342904/)
  
  <br></p>
  </details>

[//]: # (Про выпуск новых версий и TC39)
- <details><summary><b>Про выпуск новых версий и TC39</b></summary><p>

  - Традиционно обновления ECMAScript публикуются в конце июня.
  -
  - Стандарт `ECMAScript` развивается и поддерживается ассоциацией [ECMA International](http://www.ecma-international.org/memento/index.html). 
  - В ECMA есть технический координационный комитет «ECMA International Technical Committee 39» (TC39) — занимается поддержкой и обновлением   спецификации `ECMAScript`. Работают с синтаксисом, семантикой, библиотеками и сопутствующими технологиями, на которых основан язык. Это 50-100 представителей компаний, занимающихся веб-технологиями, включая разработчиков браузеров (Mozilla, Google, Apple) и устройств (Samsung и т. д.). Встречи TC39 обычно проводятся каждые два месяца и занимают около 3 дней. Там отчитываются о работе, обсуждают планы и голосуют за предложения. Предложения любой человек может прислать в репозиторий GitHub. Предложения проходят 5 этапов согласования — от 0 до 4. 4 = пригодно для включения в ревизию языка в следующем году.
  - Предложения о добавлении новых возможностей анализируются командой «T39». Если одобряются — описания новых возможностей переносятся в [черновик](  https://tc39.github.io/ecma262), а затем публикуются в [спецификации](https://www.ecma-international.org/publications/standards/Ecma-262.htm).
  - Разработчики JS-движков сами решают, какие предложения реализовать в первую очередь. Могут заранее добавить поддержку функций, которые ещё   находятся в черновике. Могут отложить разработку функций, которые уже перенесены в спецификацию. Часто в движке (например браузер) реализуется   только часть стандарта. Текущее состояние поддержки различных возможностей JS можно проверить здесь: [https://kangax.github.io/compat-table/es6/](  https://kangax.github.io/compat-table/es6/)
  - Что значат цифры в «ECMA-262» и «TC-39»? 
    - ECMA (European Computer Manufacturers Association) — международная организация, занимается стандартизацией информационных и коммуникационных технологий. Кроме JS поддерживает кучу других стандартов. 
    - 262 = номер стандарта, который она поддерживает. Т.е. до JS они стандартизировали ещё 261 какую-то сущность. 
    - Точно так же 39 = номер рабочей группы в рамках ECMA. 39-группа занимается стандартизацией версий JS, предыдущие 38 - другими вопросами :)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (О языке «в целом»)
<details id="test"><summary><b>О языке «в целом»</b></summary><p>

[//]: # (Общая характеристика языка)
- <details><summary><b>Общая характеристика языка</b></summary><p>

  - Мультипарадигменый
    - можно писать в разных стилях: ООП, процедурном, функциональном...  
  - С динамической типизацией
    - тип присваивается переменной в момент присваивания значения
  - Слабо типзированный 
    - тип переменой может меняться в процессе работы программы
  - Автоматическое управление памятью 
    - методом «сборщика мусора» — спец. процесс, периодически освобождает память, удаляя из неё ставшие ненужными объекты. [Wikipedia](https://  ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0)
  - Прототипное неследование 
    - наследование происходит путём клонирования существующего экземпляра объекта (прототипа). Нет классического ООП понятия «класса».
    - JS — едва ли не единственный язык, который может с полным правом использовать определение «объектно-ориентированный», потому что он входит в   очень короткий список языков, в которых объект может создаваться напрямую, без использования классов.
  - Функции как «объекты первого класса» 
    - они могут быть переданы как параметр, возвращены из функции, присвоены переменной. [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A  %D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)
  
  <br></p>
  </details>

[//]: # (Правильное название)
- <details><summary><b>Правильное название</b></summary><p>
  
  - Не используйте для обозначения языка такие термины, как JS6 или ES8.
  - Придерживайтесь названий ES20xx или просто JS
  
  <br></p>
  </details>

[//]: # (Мультипарадигменый)
- <details><summary><b>Мультипарадигменый</b></summary><p>

  - На JS можно писать в любой парадигме:
    - В процедурном стиле код представляет собой нисходящую линейную последовательность выполнения по заранее определенному набору операций, которые   обычно объединяются в логически связанные единицы, называемые процедурами.
    - В ОО-стиле структура кода основана на группировке логики и данных в единицах, называемых классами.
    - В функциональном стиле код структурируется по функциям (чистые вычисления в отличие от процедур), а адаптации этих функций становятся   значениями.
  - Причем может быть даже такой вариант — разные строки написаны в разных парадигмах.
  
  <br></p>
  </details>

[//]: # (Слабо типзированный, с динамической типизацией)
- <details><summary><b>Слабо типзированный, с динамической типизацией</b></summary><p>

  - JS описывают характеристиками: 
  - «динамическая типизация»
    - приём создания языка программирования — переменной присваивается тип в момент присваивания значения, а не в момент объявления переменной. 
    - В различных участках программы одна и та же переменная может принимать значения разных типов.
    - упрощает написание программ
    - снижает производительность программ — отсутствие информации о типе не позволяет компилятору эффективно оптимизировать код. 
    - То же самое относится и к средам разработки — им становится сложнее анализировать то, как код будет исполняться, заранее предупреждать о   возможных ошибках, производить автодополнение.
    - Производительность снижается и из-за необходимости проверять тип переменных во время операций, даже при обычном математическом сложении   требуется проверить, что обе переменные хранят значение подходящего типа, затем получить само значение переменной через указатель на неё[1] и   только потом производить необходимую операцию.
  - «слабая типизация» / «нестрогая типизация» 
    - переменные могут содержать значения разных типов данных, и их тип может изменяться во время выполнения программы.
    - Иначе говоря: переменная в JS не содержит информацию о типе значений, которые в ней хранятся. Можно записать в переменную строку, а потом   понять на число — это не вызовет ошибки. Поэтому JS иногда называют «нетипизированным» языком.
    - тип переменной определяется автоматически, в зависимости от значения, которое вы ей присваиваете.
  
  <br></p>
  </details>

[//]: # (Прямая и обратная совместимость)
- <details><summary><b>Прямая и обратная совместимость</b></summary><p>

  - Обратная совместимость = старый код будет нормально исполнятся в современном ядре JS.
  - JS обратно совместим. Как часто заявляют участники TC39, «мы не ломаем веб».
  - Прямая совместимость = новый код будет нормально исполнятся в старом ядре JS.
  - JS не имеет прямой совместимости! Этот вопрос решается через транспиляцию и полифилы.
  
  <br></p>
  </details>

[//]: # (Транспиляция)
- <details><summary><b>Транспиляция</b></summary><p>

  - Процесс преобразования программы на одном языке в программу на другом языке (или другой версии того же языка).
  - Делается специальной программой-транспилятором.
  - Babel — самый популярный траспилятор на сегодня.
  - Позволяет писать JS со всеми современными возможностями, не беспокоясь «как он будет выполняться в старых версиях браузеров?»
  - Транспиляция в первую очередь решает вопросы старого/нового синтаксиса.
  - [Hexlet - Что такое транспиляция?](https://guides.hexlet.io/ru/transpilers/)
  
  <br></p>
  </details>

[//]: # (Полифилы)
- <details><summary><b>Полифилы</b></summary><p>

  - Паттерн програмрования. Дополняет транспиляцию.
  - В сущности — решает ту же проблему: использование новых возможностей языка в старых версиях среды.
  - Если проблема прямой совместимости связана не с новым синтаксисом, а с отсутствующим методом API, который появился совсем недавно.
  - Обычно в таких ситуациях предоставляется определение для отсутствующего метода API, который работает так, словно он уже определен в более старой   среде. Это и есть polyfill (или shim).
  
  <br></p>
  </details>

[//]: # (Web Assembly)
- <details><summary><b>WASM (Web Assembly)</b></summary><p>

  - WASM — формат представления кода программ, отчасти напоминающий код ассемблера (отсюда название), который может обрабатываться ядром JS.
  - WASM позволяет другим языкам работать в ядре JS
  - Задуман как способ преобразования программ написанных на других языках (например, на C) в форму, которая может выполняться в ядре JS.
  - Берём программу на C, прогоняем её через специальную программу-транспилятор, на выходе получаем некий код, который может выполняться ядром JS.   Например, можно запустить игровой движок Unreal в браузере.
  - Позволяет повысить быстродействие. Пропускается фаза разбора/компиляции, обычно выполняемая ядром JS. Разбор/компиляция программ,   предназначенных для преобразования в формат WASM, выполняется заранее (AOT, Ahead Of Time). Программа распространяется в двоичной форме, готовая   для выполнения ядром JS с минимальной обработкой.
  - Позволяет расширить применение в web других языков, кроме JS. Например, если язык Go поддерживает многопоточное программирование, а язык JS —   нет, WASM обеспечивает возможности преобразования таких программ Go в форму, понятную для ядра JS, без необходимости поддержки потоков в самом   языке JS. WASM устраняет необходимость добавления в JS новых возможностей, в основном/исключительно предназначенных для использования   транспилированными программами из других языков. Это означает, что развитие функциональности JS может оцениваться (комитетом TC39) без   необходимости отвлекаться на интересы/потребности других языковых экосистем, сохраняя для других языков реальный путь на веб-платформу.
  - WASM эволюционирует и постепенно превращается в своего рода кроссплатформенную виртуальную машину (VM), на которой программы могут   компилироваться однократно и выполняться в разных системных средах. Таким образом, WASM существует не только для веб-платформ и не ограничивается   JS.
  
  <br></p>
  </details>

[//]: # (Каждый js-файл является программой)
- <details><summary><b>Каждый js-файл является программой</b></summary><p>

  - Каждый js-файл является программой.
  - И каждый js-модуль — тоже. Те самые ES-6 модули, которые подгружаются командой `import` или тегом `<script type=module>`
  - Есть софт, который объединяют разные js-файлы проекта в один, и его предоставляет веб-странице. Тогда один объединенный = целая программа.
  -
  - Почему важно: если в одном файле произошла ошибка — остальные могут продолжить выполняться.
  -
  - Отдельные js-файлы действуют как единая программа только в одном отношении: на уровне совместного доступа к их состоянию (и открытой   функциональности) через глобальную область видимости. Они объединяются в пространстве имен глобальной области видимости и во время выполнения   действуют как единое целое.
  
  <br></p>
  </details>

[//]: # (Языки поверх JavaScript)
- <details id="metaLanguages"><summary><b>Языки поверх JavaScript</b></summary><p>

  - Синтаксис JavaScript устраивает не всех - одним он кажется слишком свободным, другим слишком ограниченным, третьи хотят добавить дополнительные - возможности…
  - 
  - Появилось много языков, которые добавляют различные возможности «поверх» JavaScript. Для запуска в браузере они превращаются в обычный JS-код (- при помощи специальных инструментов «трансляторов»).
  - 
  - Это преобразование происходит автоматически и совершенно прозрачно, при этом неудобств в разработке и отладке практически нет.
  - 
  - Разные языки выглядят по-разному и добавляют разные вещи:
    - **TypeScript** — сосредоточен на добавлении строгой типизации данных. Предназначен для упрощения разработки и поддержки больших систем. Разрабатывается Microsoft.
    - **CoffeeScript** — «синтаксический сахар» поверх JavaScript. Сосредоточен на большей ясности и краткости кода. Часто его любят программисты на Ruby.
    - **Dart** — не только транслируется в JS, но имеет и свою независимую среду выполнения, которая даёт ему ряд возможностей и доступна для встраивания в приложения (вне браузера). Разрабатывается компанией Google.
  
  - **Ссылки:**
    - [learn.javascript.ru](https://learn.javascript.ru/intro)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Термины)
<details><summary><b>Термины</b></summary><p>

  - `Код` —
  - `Переменная` —
  - `Идентификатор` —
  - `Литерал` —
  - `Оператор` —
    - [MDN - Список выржений, операторов и ключевых слов JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)
  - `Конструкция` — 
  - `Выражение` (expression) — код, который после выполнения возвращает какое-либо значение.
    - В JS есть выражение, которое позволяет возвращать значение по условию — тернарный оператор. Он возвращает значение, но работает с условиями (как инструкиця).
    - Написать программу можно только совмещая выражения, которые работают с данными, и инструкции, которые позволяют управлять порядком выполнения.
    - 
    - Пример: `3` в консоли браузера вернёт `3`
    - Пример: `5 + 3` вернёт `8`
    - Пример: `Math.random()` вернёт случайное число.
    - +
    - [Doka — Выражения и инструкции](https://doka.guide/js/expressions-vs-statements/)
    - [MDN - Список выржений, операторов и ключевых слов JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)
  - `Инструкция` — синтаксические конструкции и команды, которые выполняют действия. «Строки программы». Отделяются точкой с запятой.
    - отдельная команда в коде, которая выполняет определённое действие. Например, if позволяет создать ветвление в программе, for позволяет повторять одно и то же действие.
    - Инструкции ничего не вычисляют и не возвращают результат, поэтому они не являются «выражениями».
    - В JS есть выражение, которое позволяет возвращать значение по условию — тернарный оператор. Он возвращает значение, но работает с условиями (как инструкиця).
    - Написать программу можно только совмещая выражения, которые работают с данными, и инструкции, которые позволяют управлять порядком выполнения.
    - 
    - Типы инструкций в JS
      - управление потоком выполнения (if и else, switch, throw и так далее);
      - итерации (for, while и так далее);
      - объявление значений (var, let, const);
      - функции (function, return и так далее);
      - прочие (debugger, import, export).
    - 
    - [Doka — Выражения и инструкции](https://doka.guide/js/expressions-vs-statements/)
            - `Пустая инструкция` — в строке только `;`.  Используется, когда инструкция не нужна, хотя синтаксис JS будет предполагать её.
              - ([MDN - Пустая инструкция](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/Empty))
  - `Ключевое слово` —
    - [MDN - Список выржений, операторов и ключевых слов JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)
  - `Предикат` —
  - `Блок` — используется для группировки нуля или более инструкций. Блок отделяется `{...}`
    - может опционально быть поименован `[имя:] {...}`
    - в других языках = «сложная инструкция»
    - [MDN - Блок](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block)
  - `Процедура` — функция, которая возвращает пустое значение (при этом выполнение кода процедуры непосредственно сказывается на выполнении программы).
  - `Функция` —
  - `Операция` —
  - `Аттрибут` —
  - `Транспиляция` —
  - `Движок` —
  - `Окружение` —
  - `Интерпретатор` — 
  - `Компилятор` —
  - `Интерпретация` —
  - `Компиляция` —
  - `Область видимости` —
  - `Куча` (heap) —
  - `Стэк` —
  - `Очередь` —
  - `Event Loop` (цикл обработки событий) —
  - `Объект` —
  - `Массив` —
  - `Метод` — функция, которая является свойством объекта.
  - `Прототип` —
  - `Модуль` —
  - `Класс` —
  - `Конструктор` —
  - `Корутина` — сопрограмма. [Wikipedia](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0)
  - `Debounce` — паттерн микрооптимизации кода. Ждёт Х милисек, если некое событие не произошло за это время — выполняет действие.
    - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=Z9g8L-5_c5aHx3dA&t=3807)
  - `Throttling` — паттерн микрооптимизации кода. Тормозит - выполняй событие не чаще чем Х милисек.
    - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=Z9g8L-5_c5aHx3dA&t=3807)
  - `Шлюз` (gate) — механизм, который ожидает завершения двух и более параллельных задач. Неважно, в каком порядке они будут завершаться, важно только то, что все они должны быть завершены, чтобы шлюз открылся и пропустил поток команд.
    - В Promise API этот паттерн называется all([ .. ]). 

  - **Синтаксис / Грамматика**
    -
    - «Предложением» называется полная последовательность слов, выражающая некоторую мысль. Предложение состоит из одной или нескольких «фраз», связанных знаками препинания или союзами («И», «ИЛИ» и т.д.). Сама фраза может состоять из меньших фраз. Некоторые фразы неполны и мало что дают сами по себе, тогда как другие фразы могут использоваться самостоятельно. Совокупность этих правил называется грамматикой языка.
    -
    - Так же обстоит дело с грамматикой JavaScript.
      - команды - аналоги предложений,
      - выражения - аналоги фраз,
      - операторы - аналоги союзов/знаков препинания.
    -
    - Выражение в JS - может быть вычислено с получением одного конкретного значения (результата).
    - Команда состоит из одного или нескольких выражений
      - у каждой команды имеется завершающее значение (даже если это значение undefined). Если ввести команду в консоли разработчика в браузере, потому что при выполнении консоль по умолчанию выводит завершающее значение последней выполненной команды.
      - Например, любой обычный блок { . . } имеет завершающее значение - это завершающее значение последней выполненной в нем команды/выражения. завершающее значение блока аналогично значению, неявно возвращаемому последней командой блока.
      - Но что бы ни выводилось в консоль, мы не можем перенести это значение в свою программу. Как получить завершающее значение в программе?

  - **Ссылки**
     [golvinov — Введение в программирование](https://golvinov.gitbook.io/js/)
     [golvinov — Введение в JavaScript](https://golvinov.gitbook.io/js/vvedenie-v-javascript)

<br></p>
</details>

---


[//]: # (Use strict)
<details id="useStrict"><summary><b>Use strict</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Появился в ES5 (2009)
  - Добавлен для обратной совместимости - чтоб старые программы работали корректно.
  - При включённом `"use strict"` JS обрабатывается в современном режиме. Без него — в «режиме совместимости» со старыми версиями JS.
  -
  - Его надо включать вручную, прописать `"use strict"` в начале скрипта или функции.
  - Выше `"use strict"` можно писать только комментарии. 
  - Работа строгого режима на уровне отдельных функций: 
    - Если для файла включен строгий режим, то директивы строгого режима на уровне функций запрещаются. Нужно выбрать либо одно, либо другое. 
    - Включение строгого режима на уровне функций может быть оправдано только в одном случае: вы занимаетесь преобразованием существующей программы, в которой строгий режим отключен, и изменения вносятся небольшими порциями. Иначе лучше просто включить строгий режим для всего файла/программы.
  -
  - В «классах» и «модулях» строгий режим включён автоматически. Поэтому в них нет нужды добавлять директиву "use strict".
  - Почти весь транспилированный код работает в строгом режиме, даже если исходный код не был написан в этом виде. 
    - Большая часть кода JS, находящегося в реальной эксплуатации, транспилируется. 
    - Поэтому большая часть кода JS уже работает в строгом режиме.
  - 
  - Объединение скриптов 
    - «скрипт в строгом режиме» + «скриптом в обычном» =  скрипт в строгом режиме.
    - «обычный скрипт» + скрипт в строгом режиме» = нестрогий скрипт.
    
  <br></p>
  </details>

[//]: # (Особенности строгого режима)
- <details><summary><b>Особенности строгого режима</b></summary><p>

  - Нельзя `использовать необъявленные переменные`. И объекты.
    - Раньше неправильный ввод имени переменной создавал новую глобальную переменную. Теперь это вызовет ошибку.
  - Нельзя `дублировать имя параметра` функции
  - Нельзя `удалять свойства`, которое невозможно удалить.
  - Нельзя `удалять переменные, объекты или функции` оператором `delete`
    - В строгом режиме, если вы попытаетесь удалить переменную или функцию, возникнет синтаксическая ошибка.
    - В нестрогом режиме такая попытка завершается неудачей, и выражение удаления оценится как false
  - Нельзя `присваивать значения св-вам read-only` (недоступным для записи).
    - Запись в свойства "read-only" / "get-only", несуществующие св-ва, объекты или переменные — вызовет ошибку
  - Явная ошибка если значение поля нельзя изменить или удалить
  - Запрет `восьмеричной системы счисления` — восьмеричные числовые литералы и escape-символы не допускаются
  - Нельзя называть переменные словами `eval`, `arguments`,`with `,` `
  - Зарезервированы слова: 
    - `implements`, 
    - `interface`, 
    - `let`, 
    - `package`, 
    - `private`, 
    - `protected`, 
    - `public`, 
    - `static`
    - `yield`.
    - Нельзя задействовать эти слова для именования или обращения к переменным или аргументам.
  - Нельзя использовать конструкцию `with`
    - позволяла использовать в качестве области видимости для переменных произвольный объект
  - Конструкции `eval()` (исполнение строки кода) запрещено создавать переменные в области, из которой он был вызван (по соображениям безопасности)
    - Без use strict у eval не будет отдельного лексического окружения, поэтому созданные в нем переменные будут видны из внешнего кода.
  - Ключевое слово `this` в функции ведет себя иначе.
    - Относится к объекту, который вызвал функцию. 
    - Если объект не указан, функции в строгом режиме вернут undefined. 
    - Если объект не указан, функции в обычном режиме вернут глобальный объект (window)
    
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Строгий режим](https://learn.javascript.ru/strict-mode)
  - [MDN - Строгий режим](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode)
  - [Schoolsw3 - JavaScript - Строгий режим](https://www.schoolsw3.com/js/js_strict.php)
  - [learn.javascript.ru - Eval](https://learn.javascript.ru/eval)
  - [learn.javascript.ru - Модули](https://learn.javascript.ru/modules-intro)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Атрибуты async и defer тега <script>)
<details id="asyncDefer"><summary><b>Атрибуты «async» и «defer» тега script</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Аттрибуты тэга `<script>` — определяют когда будет загружаться и выполняться этот скрипт. 
  - Будет ли заблокирован парсинг HTML на время загрузки/выполнения или нет.
  - В обоих случаях скрипт скачивается асинхронно (параллельно с формированием документа). 
  - Оба атрибута доступны только для внешних скриптов (недоступны для inline). Атрибут будет проигнорирован, если в теге `<script>` нет `src=(...)`.

  - `Async` — указает браузеру, что скрипт может быть выполнен асинхронно.
    - Как только скрипт загружен — он запускается. Парсер на это время будет приостановлен. 
    - Такие скрипты не сохраняют порядок выполения относительно друг друга. Как только загрузился — сразу начинает выполняться.

  - `Defer` (анг. *откладывать*) — указывает браузеру, что скрипт должен быть выполнен после того, как HTML-документ будет полностью разобран.
    - После получения — скрипт не запускается сразу. Ждёт, пока документ будет полностью сформирован.
    - Такие скрипты сохраняют порядок выполения относительно друг друга. Даже если `small.js` загрузится первым, он будет ждать выполнения `long.js`.
    - Используется для скриптов, которым требуется доступ ко всему DOM и/или важен их относительный порядок выполнения.
    
  - Причины проблемы
    - Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.
    - Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователь не увидит содержимое страницы, пока скрипт не загрузится и не запустится.

  <br></p>
  </details>

[//]: # (Тэг <script> в начале и конце HTML)
- <details><summary><b>Тэг script в начаале и конце HTML</b></summary><p>

  - Асинхронное / отложенное выполнение наиболее важны, когда элемент `<script>` не находится в самом конце документа.
  - HTML-документы парсятся по порядку, с открытия `<html>` до его закрытия. 
  - Если внешний JS-файл размещается непосредственно перед закрывающим тегом `</body>` — использование `async` и `defer` становится менее уместным.
  - Парсер к тому времени уже разберёт большую часть документа, и JS-файлы уже не будут оказывать воздействие на него.

  <br></p>
  </details>

[//]: # («Async» — скрипт самодостаточен + порядок скриптов не важен)
- <details><summary><b>«Async» — скрипт самодостаточен + порядок скриптов не важен</b></summary><p>

  - Для файлов, которые не зависят от других файлов и/или не имеют никаких зависимостей
  - Нам не важно, когда файл будет исполнен, поэтому асинхронная загрузка — наиболее подходящий вариант.

  <br></p>
  </details>

[//]: # («Defer» — скрипт полагается на полностью разобранный DOM)
- <details><summary><b>«Defer» — скрипт полагается на полностью разобранный DOM</b></summary><p>

  - Используется для скриптов, которым требуется доступ ко всему DOM и/или важен их относительный порядок выполнения.
  - Обычно такой файл помещается в низ страницы, чтобы убедиться, что для его работы всё было разобрано. Если файл должен быть размещён в другом месте — атрибут defer может быть полезен.

  <br></p>
  </details>

[//]: # (Динамически загружаемый скрипт — похож на async)
- <details><summary><b>Динамически загружаемый скрипт — похож на async</b></summary><p>

  - Можно также добавить скрипт динамически, с помощью JS:
    - ```js
      let script = document.createElement('script');
      script.src = "/article/script-async-defer/long.js";
      document.body.append(script); // Скрипт начнёт загружаться, как только он будет добавлен в документ 
      ```
  - Такие скрипты ведут себя как «async»
  - Можно изменить относительный порядок скриптов с «первый загрузился – первый выполнился» на порядок, в котором они идут в документе (как в обычных скриптах) с помощью явной установки свойства `async = false`:
    - ```js
      let script = document.createElement('script');
      script.src = "/article/script-async-defer/long.js";
      script.async = false;
      document.body.append(script);
      ```

  <br></p>
  </details>


[//]: # (Синхронный inline-скрипт — небольшой и зависим от других файлов)
- <details><summary><b>Синхронный inline-скрипт — небольшой и зависим от других файлов</b></summary><p>

  - Если скрипт является относительно небольшим и/или зависит от других файлов — возможно, стоит определить его инлайново. 
  - Встроенный код блокирует разбор HTML-документа. Но небольшой скрипт не должен сильно помешать. 
  - Кроме того, если он зависит от других файлов, может понадобиться незначительная блокировка.
  
  <br></p>
  </details>


[//]: # (Script и область видимости)
- <details><summary><b>Script и область видимости</b></summary><p>

  - Отдельные файлы/фрагменты кода действуют как независимые JS-программы почти во всех отношениях. 
  - Единственное, что у них есть общего — глобальный объект (window в браузере).
  - Поэтому несколько файлов могут присоединить свой код к общему пространству имен, и все они могут взаимодействовать друг с другом.
  - Но поднятие видимости глобальных переменных не переходит через эти границы. 
    - Поэтому следующий код работать не будет. Неважно, используются ли inline-скрипты `<script> ..</script>` (как показано) или файлы `<script src= .. ></script>` с внешней загрузкой.
    - ```js
      <script>foo();</script>
  
      <script>
        function foo() { .. } //Ошибка — потому что объявление `foo( )` еще не встречалось
      </script>
      ```
  - Но любой из этих двух фрагментов будет работать:
    - ```js
      <script>
        foo();
        function foo() { .. }
      </script>
      ```
  - Или:
    - ```js
      <script>
        function foo() { .. }
      </script>
    
      <script>foo();</script>
      ```

  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Внешние скрипты, порядок исполнения](https://learn.javascript.ru/script-async-defer)
  - [Асинхронный JavaScript против отложенного](https://habr.com/ru/post/323790/)
  - [Разница между async и defer у тега script](https://wp-kama.ru/id_12151/raznitsa-async-defer.html)
  - [Атрибут defer](http://htmlbook.ru/html/script/defer)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Типы данных)
<details id="types"><summary><b>Типы данных</b></summary><p>

[//]: # (Кратко)
- <details><summary><b>Кратко</b></summary><p>

  - Типы JS
    - `Boolean`
    - `String`
    - `Number`
    - `BigInt`    - целые числа произвольной длины
    - `Symbol`    - уникальные идентификаторы(ES6)
    - `Null`      - преднамеренное отсутствующее значение. 'typeof' === Object. Ошибка языка
    - `Undefined` - неинициализированное значение (не было изначально)
    - `Объекты`
      - в т.ч. Функции - typeof выдаст function. Но это объект

  - typeof 
    - `null`     — `object` (хотя реальный тип 'null')
    - `NAN`      — `number`
    - `function` — `function` (хотя реальный тип 'object')
    - `new Number(123)` — `object`

  - Преобразование логическое
    - `false` = пустая строка, 0, null, NaN, undefined
    - `true` = все остальное

  <br></p>
  </details>

[//]: # (Примитивы)
- <details><summary><b>Примитивы</b></summary><p>

  - Типы, значения которых можно только перезаписать, но нельзя изменить.
  - Хранятся в памяти «как есть».
  - Они же — «скалярные типы данных»
  - 
  - `Boolean`
  - `String`
  - `Number`
  - `BigInt` - целые числа произвольной длины
  - `Symbol` - уникальные идентификаторы(ES6)
  - Тривиальные типы
    - `Null` - преднамеренное отсутствующее значение. 'typeof' === Object. Ошибка языка
    - `Undefined` - неинициализированное значение (не было изначально)
  
  <br></p>
  </details>

[//]: # (Сложные типы, объекты)
- <details><summary><b>Сложные типы (объекты)</b></summary><p>

  - Хранятся в памяти «как ссылки».
  - Они же — «составные/комплексные типы данных»
  - 
  - Объекты
    - собственно `Объект`
    - Массивы
    - Функции - 'typeof' выдаст function. но это объект
    - Даты
    - RegExp - регулярные выражения
    - Ошибки - несколько встроенных типов (конструктор Error создаёт объект ошибки)
    - все структуры которые создаются с ключевым словом `new`: Map, Set, WeakMap, WeakSet, Error...

  <br></p>
  </details>

[//]: # (Встроенные объекты)
- <details><summary><b>Встроенные объекты</b></summary><p>

  - Boolean
  - String
  - Number
  - Object
  - Function
  - Array
  - Date
  - RegExp
  - Error
  - ... вероятно начиная с ES6 есть что-то ещё
  - 
  - это встроенные функции. Могут использоваться как конструктор (вызываться с оператором `new`), результат вызова — создание объекта заданного
    подтипа.
  - Примитивное значение "Some string" объектом не является — это примитивный литерал и неизменяемое значение.
  - Для выполнения с ним операций (например, проверки длины `.length`) необходим объект String.
  - Язык автоматически преобразует строковый примитив в объект String тогда, когда это необходимо — вам почти никогда не понадобится явно создавать форму Object. Мы вызываем свойство или метод для строкового примитива, а движок автоматически преобразует его в объект String, чтобы обращение к свойству/методу работало.
  
  <br></p>
  </details>

[//]: # (Оператор «typeof»)
- <details><summary><b>Оператор «typeof»</b></summary><p>

  - возвращает тип примитива, или object в противном случае
  - нюансы
    - typeof `null`     — `object` (хотя реальный тип 'null')
    - typeof `function` — `function` (хотя реальный тип 'object')
    - typeof `NAN`      — `number`
    - typeof `new Number(123)` — `object`
    - typeof `[1,2]` — `Object` (все массивы = объекты)
  
  <br></p>
  </details>

[//]: # (Undefined, null, NaN)
- <details><summary><b>Undefined, null, NaN</b></summary><p>

  - `undefined` — значение переменной, которая не была инициализирована. Единственное значение типа Undefined. Глобальная
    переменная.
  - `null` — умышленно созданный «пустой» объект. Единственное значение типа Null. Зарезервированное слово
  - `NaN` — спец. значение типа Number, для выражения «не чисел», «неприавльных чисел» «неопределенности». 
    - Переменная глобального контекста (объекта window).
    - Вообще это «сигнальное значение». Значение, нормальное в других отношениях,которому был присвоен специальный смысл.
    - Разновидность состояний ошибок в числовом множестве. «Я попытался выполнить математическую операцию, ничего неполучилось, и вот вам результат — некорректное число».
    - 
    - typeof NaN === number
    - Есть два разных способа проверки на NaN
      - встроенная глобальная функция `isNaN(x)` — содержит ошибку! Не применяй его! 
        - Пример: `window.isNaN('my string'); // true! Хотя это строка, а не значение NaN `
      - метод `Number.isNaN(x).` работает корректно. Применя его!
    - 
    - например - результат деления 0 на 0, parseInt('неприводимая к числу строка'), Math.sqrt(-1)...
    - деление других чисел на 0 — это бесконечность, для которой в JS есть значения Infinity.
  
  - **Странности**
    - С чем бы мы ни сравнивали `NaN`, результатом сравнения всегда будет `false`.
      - NaN === NaN; // false
      - сравнения NaN используется специальная функция `Number.isNaN(..)` или функция `Object.is(..)`
    - 0 === -0; // true
      - Для сравнения -0 лучше использовать функцию `Object.is(..)`
    - Оператор `typeof` говорит что тип необъявленной переменной — `undefined`, но при обращении к ней происходит ошибка.
    - Т.к. необъявленная (Undeclarated) переменная ещё не существует.
    - Если переменная объявлена, но не инициализирована (её не присвоено значение) — такой ошибки не будте
    - Можно читать и записывать значение `undefined` => кто-то может перезаписать его и сравнение с undefined будет
     некорректным.
    - Т.к. undefined — это не только значение undefined типа Undefined, но и глобальная переменная. Её можно
      переопределить.
    - `null` мы перезаписать не можем. Язык даёт перезаписать `undefined`, но не даёт перезаписать `null`.
    - Это не глобальная переменная, а зарезервированное слово, его перезаписать нельзя
    - При переопределении undefined всё прошло успешно, при переопределении null возникла ошибка, а при переопределении
     NaN операция не вызвала ошибки, но свойство не было переопределено.
  
  <br></p>
  </details>

[//]: # (Операции с дробными числами)
- <details><summary><b>Операции с дробными числами</b></summary><p>
  
  ```js
  //Проблема
  console.log( 0.1 + 0.2 == 0.3 ); // false
  console.log( 0.1 + 0.2); // 0.30000000000000004
  
  //Решение
  let sum = 0.1 + 0.2;
  alert( sum.toFixed(2) ); // 0.30
  //PS: метод «toFixed» возвращает строку!
  ```

  - Программист обязан знать об особенностях работы компьютера с числами с плавающей точкой.
  - При сложении некоторых дробных чисел, выдаётся арифметически неверный результат.
  - Такие результаты получаются из-за особенностей работы c числами с плавающей точкой. Это не является особенностью JavaScript, другие языки работают также (PHP, Python, Ruby...)
  - Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.
  - В большинстве случаев достаточно просто округлять результаты.
  - Если необходимо выдавать точный результат — можно просто умножать все аргументы на 10 и результат делить обратно на 10
  - Подробнее: [learn.javascript.ru — Числа. Неточные вычисления](https://learn.javascript.ru/number#netochnye-vychisleniya)
  
  <br></p>
  </details>

[//]: # (Про понятие «скалярный»)
- <details><summary><b>Про понятие «скалярный»</b></summary><p>

  - Понятия  «скалярный» и «примитивный» не совсем взаимозаменяемы. Они часто похожи, но есть различия. Зависит от контекста.
  - `Скаляры` обычно противопоставляются `составным элементам` (таким как массивы, карты, множества, структуры и т.д.)
  -
  - «Скалярный» используется в контекстах, где уместно различать одиночные / простые / атомарные значения и составные значения.
  - `Скаляр` — это «единственное» значение (number, boolean, возможно string).
  - `Составное` — состоит из нескольких скаляров (и, возможно, ссылок на другие составные).
  -
  - «Примитивные типы», отличаются, например, от ссылочных типов и используются, когда уместным различием является «Является ли это непосредственно значением или это ссылка на что-то, что содержит реальное значение?», как в примитивных типах Java и ссылках. Я рассматриваю это как несколько более низкоуровневое различие, чем «скалярный» / «составной».
  - Это действительно зависит от контекста (и часто от того, какое языковое семейство обсуждается).
  - Возьмем один, возможно патологический, пример: строки.
    - в `C` строка — это составное число (массив символов),
    - в `Perl` строка — это скаляр
    - в `Java` строка — это объект (или ссылочный тип).
    - в `Python все (концептуально) является объектно-ссылочным типом, включая строки (и числа).
  
  <br></p>
  </details>

[//]: # (Советы)
- <details><summary><b>Советы</b></summary><p>

  - Не использовать булевы операторы с NaN. Для проверки нужно использовать функцию `isNaN`.
  - Перед обращением к переменной проверять что она объявлена. При обращении к необъявленной (Undeclared) переменной — ошибка.
  - Не сравнивать переменные с `undefined` — кто-то мог перезаписать глобальную переменную undefined и сравнение будет некорректным. Лучшее решение: сравнивать не значение переменной, а её тип (`typeof a === 'undefined'`).

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Habr - Подводные камни JavaScript](https://habr.com/ru/post/159313)
  - [doka - Типы ](https://doka.guide/js/typecasting)
  - [doka - Типы. Преобразование типов ](https://doka.guide/js/typecasting/#preobrazovanie-tipov)
  - [freecodecamp.org - 10 способов преобразовать строку к числу (en)](https://www.freecodecamp.org/news/how-to-convert-a-string-to-a-number-in-javascript/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Приведение типов)
<details id="objectReference"><summary><b>Приведение типов</b></summary><p>

[//]: # (Кратко)
- <details><summary><b>Кратко</b></summary><p>

  - `Boolean(42)`
    - **false** — 0, null, undefined, NaN, "", «ложные объекты» (добавляются в JS браузерами, например `document.all`)
    - **true**  — все остальное. В частности "0", строки из пробелов (" "), все объекты (не ложные)

  - `String(42)`
    - **null**      -> "null"
    - **undefined** -> "undefined"
    - **true**      -> "true"
    - **число**     -> "число"
    - **объект**
      - если у объекта есть свой метод `toString()`   — вернётся строковый результат вызова `toString()`.
      - если у объекта нет своего метода `toStriпg()` — вернётся внутренний `[[Class]]` (например `[ object Object]`).
    - **массив** — своя версия `toString()`, выполнит строковую конкатенацию всех значений (каждое приводится к строке), разделяя их `,` (`[1,2,3] -> "1,2,3"`)

  - `Number('42')`
    - Если JS не сможет привести значение к числу — получим `NaN`
    - NaN           -> NaN
    - undefined     -> NaN,
    - null          -> 0
    - true / false  -> 1 / 0
    - String        -> пробелы по краям обрезаются. Если остаётся пустая строка -> 0. Из непустой строки «считывается» число. При ошибке -> NaN

  - `parseInt(42)` / `parseFloat(42)` (разбор строк)
    - Это не совсем «функция преобразования». Это скорее считывание числового значения из строки
    - Разбор идёт слева направо
    - Пробелы игнорируются
    - Устойчиво к нечисловым символам — при обнаружении такого символа просто прекращается,
    - Применяйте разбор строк в тех случаях, когда вас не интересуют другие нечисловые символы, которые могут присутствовать в правой части.

  - `ToPrimitive`
    - Если у объекта есть метод `valueOf()` и он возвращает примитивное значение — используется это значение.
    - Если метода нет, то используется результат `toString()` (если возможно). Этот метод наследуется от Object, но может быть переопределен.
    - Если ни один из этих методов не выдаёт примитивное значение — ошибка `TypeError`.

  - `Symbol` --> `*`
    - разрешено явно и неявно преобразование к boolean (результат всегда true).
    - разрешено явное преобразование к строке
    - запрещено неявное преобразование к строке и любое преобразование к number (происходит ошибка).

  - `Boolean` --> `Number`
    - true -> 1
    - false -> 0
    - Самый простой метод — использовать унарный `+`

  - Неявное преобразование `*` --> `Boolean` происходит в:
    - Условие в команде `if ( .. )` .
    - Условие (вторая часть) в заголовке `for ( .. ; .. )`.
    - Условие в циклах `while ( .. )` и `do .. while( .. )`.
    - Условие (первая часть) в тернарных выражениях `? :`.
    - Левый операнд для операторов `||` или `&&` .

  - Оператор `==`
    - сначала преобразует тип (если надо). Когда с обеих сторон будут значения одинаковых типов — действует как `===`.
    - преобразует нечисловые значения ("42" и true) в числа перед сравнением.
    - если оба сравниваемых значения изначально являются строками — используется алфавитное сравнение строк.
    - Операторы `>`, `<`, `>=`, `<=` ведут себя как `==`

    - Правила
      - `string`  вначале преобразуется к числу
      - `boolean` вначале преобразуется к числу. Опасно!
      - `object`  вначале преобразуется к примитиву
      - `null`    == `undefined`

    - Эвристики
      - Никогда не используйте `==` если один из операндов может быть `boolean`.
      - Избегайте `==` если один из операндов может `[]`, `""` или `0`
      -
      - В этих случаях почти всегда лучше использовать `===` вместо `==` или другие методы (например `if (Boolean(a)) {...}`).

    - Особые случаи
      - ```js
        "" == 0;      // true. 
        "" == [];     // true. 
        0  == [];     // true. 
        [] == ![];    // true. То же что [] == false.
        2  == [2];    // true. Из массива считывается строка. Она приводится к числу
        "" == [null]; // true. [null] -> [] -> "" -> 0.  
        0  == "\n";   // true. Преобразование пустых строк "", "\n", " " и т.д. дает 0.
        ```  

  - Сравнение объектов
    - Два объекта равны только если оба ссылаются на одно значение. Никакое преобразование типа при этом не выполняется.
    - `==`` и `=== `при сравнении любых объектов ведут себя идентично! Включая функции и массивы

  - Специальное равенство — метод `Object.is(..)`
    - Можно проверить два значения на `===` без исключений (с учетом `NaN`, `+0`, `-0`).
    - Используют для сравнение с NaN (не равно ничему, даже самому себе) или для сравнений `+0` и `-0`

  - Оператор унарный `+`
    - число можно преобразовать в строку простым «сложением» его с пустой строкой: `42 + '' // '42'`
    - если один из операндов `+` является строкой (или становится ею из переобразования объекта/массива) — выполнит конкатенацию строк. Поэтому при математическом сложении внимательно проверяем, что оба операнда — числа
    - если один из операндов является BigInts — выдаёт TypeError
    - если один из операндов является Symbol  — выдаёт TypeError
    - в остальных случаях всегда выполняется числовое сложение.
      - `[1,2] + [3,4] // '1,23,4' - вначале получили две строки, потом склеили их`
    -
    - если перед строкой поставить `+` — JS попытается считать из неё число
    - Алгоритм
      - пробельные символы по краям обрезаются (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.).
      - если остаётся пустая строка — 0,
      - иначе из непустой строки «считывается» число. При ошибке результат NaN.
    - если перед boolean поставить `+` - преобразует его к числу
    -
    - Унарные оператор `+` и `-` преобразует строку в число. Минус при этом меняет знак числа.

  - Операторы `-`, `*` и `/`
    - ПРОВЕРИТЬ!!!
    - определены только для числовых операций. так что `а - 0` инициирует преобразование значения `а` в число.
    - при вычитании меняется знак числа

  - Операторы `!` и `!!`
    - `!` преобразует значение в boolean. Но при этом значение переходит из истинного в ложное, и наоборот.
    - Лучше использовать `!! ` — второй `!` возвращает разряд в исходное состояние. `Boolean(0)` — это то же самое что `!!(0)`

  - Операторы `||` и `&&`
    - Не обязательно дают boolean! Выдают значение одного из двух операндов, и он возвращается в исходном типе (без приведения к boolean).
    - Оператор выполняет логическую проверку первого операнда. Если тип операнда не `boolean` — его преобразуют к boolean.
    - `а || b;` — примерный аналог `а ? а : b;`. Если `Boolean(a) === true` — верни a, иначе верни b.
    - `а && b;` — примерный аналог `а ? b : а;`. Если `Boolean(a) === true` — верни b, иначе верни a.
    - `||` следует использовать только если все ложные значения должны пропускаться!
      - Если вместо первого операнда придёт `0`, `null`, `undefined`, `NaN` или `""`  — считаем их неверными и выбираем второй операнд (справа от `||`)
      - Иначе проверку условия в данном случае нужно сформулировать более явно — например использовать тернарный оператор `? :` .

  - Побитовые операторы `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
    - Сначала выполняет преобразование `ToNumber`, потом побитовую операцию
    - `~(-1) === -0`, а `Boolean(-0) === false`. Поэтому `~(x)` часто используют для проверки на `-1`
    - `~~` (двойная тильда)  — иногда используют для усечения дробной части числа (т.е. «преобразования» к целому числу).

  <br></p>
  </details>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Преобразования типов JS всегда дают одно из скалярных примитивных значений.
  -
  - Явные преобразования
    - Пример: `var b = String(а); //явное преобразование к строке`
    - Важно: `String()` вызывается без ключевого слова `new` — иначе будет создан объект-обёртка, а не строка!
  - Неявные преобразования
    -  Пример: `var b = а + ''; //неявное преобразование к строке`

  <br></p>
  </details>

[//]: # (Абстрактные операции)
- <details><summary><b>Абстрактные операции</b></summary><p>

  - Это «операции только для внутреннего использования». Вызываются «под капотом» для проведения преобразования типов.
  -
  - `ToStriпg`
    - Преобразование любого нестрокового значения в строку.
    - Встроенные примитивные значения содержат естественное преобразование к строковому виду:
      - null -> "null",
      - undefined -> "undefined ",
      - true -> "true".
      - числа выражаются в естественном виде. Но очень малые или очень большие — в экспоненциальной форме (например `1.07е21`)
      - для обычных объектов, если не указана своя реализация `toStriпg()` — вернётся внутренний `[[Class]]` (например `[ objectObject]`).
      - для объектов, которые содержат свой метод `toString()` и этот объект используется в строковом контексте, автоматически будет вызвана его реализация `toString()` и будет использован строковый результат этого вызова.
      - Массивы имеют переопределенную версию по умолчанию `toString()` — выполняет строковую конкатенацию всех своих значений (каждое из которых преобразуется к строке), разделяя их `,` (`[1,2,3] -> "1,2,3"`)
  -
  - `ToNumber`
    - Есть два варианта: `parseIn()` и `Number()`
    - `parseIn()` — разбор числового значения из строки
      - устойчив к нечисловым символам. При обнаружении такого символа просто прекращается
      - разбор идёт слева направо.
      - работает со строковыми значениями. Передавать сюда что-то кроме строк полностью бессмысленно
      - применяйте `parseIn()` если вас не интересуют другие нечисловые символы, которые могут присутствовать в правой части.
    - `Number()` — преобразование типа
      - при обнаружении нечислового символа происходит сбой, а результатом операции является значение NaN.
      - применяйте `Number()`, когда допустимы только числовые значения, а строки вида "42рх" должны отвергаться.
    - Пример
      - ```js
        var а = "42";
        var b = "42рх";
        Number(а) ; // 42
        parseInt(а) ; // 42

        Number(b) ; // NaN
        parseInt(b); // 42  
        ``` 
  -
  - `ToBoolеаn`
    - даёт `false`
      - undefined
      - null
      -  +0, -0 и NaN
      - ""
      -  «ложные объекты>, которые добавляются в JS браузерами.  Например `document.all`
    - даёт `true`
      - все остальные
  -
  - `ToPrimitive`
    - Чтобы выполнить преобразование объекта к эквивалентному примитивному значению, абстрактная операция `ToPrimitive` проверяет соответствующее значение на наличие метода `valueOf()`.
    - Если метод `valueOf() `доступен и возвращает примитивное значение, это значение используется для преобразования типа.
    - Если нет, то `toString()` предоставляет значение для преобразования (если возможно).
    - Если ни одна операция не может предоставить примитивное значение, выдается ошибка `TypeError`.

  <br></p>
  </details>

[//]: # (Функции явного преобразования)
- <details><summary><b>Функции явного преобразования</b></summary><p>

  - `Boolean(42)`   // Приводит к логическому значению.
    - 0, null, undefined, NaN, "" — **false**
    - Все остальное — **true**
    - "0" и строки из одних пробелов типа " " при логическом преобразовании всегда **true**.
  -
  - `String(42)`    // Приводит к строке.
  -
  - `Number('42')`  // Приводит к числу.
    - Если JS не сможет привести значение к числу — получим `NaN`
    - undefined -> NaN,
    - null  -> 0
    - true / false  -> 1 / 0
    - String - пробелы по краям обрезаются. Если остаётся пустая строка -> 0. Иначе из непустой строки «считывается» число. При ошибке -> NaN
    - Применяйте преобразование строки в число, когда допустимы только числовые значения, а строки вида "42рх" должны отвергаться.
  -
  -
  - `parseInt(42)` //Строка -> число целое
    - Это не совсем «функция преобразования». Это скорее считывание числового значения из строки
    - Разбор идёт слева направо
    - Пробелы игнорируются
    - `parseIn()` устойчив к нечисловым символам — при обнаружении такого символа просто прекращается ),
    - Применяйте разбор строк в тех случаях, когда вас не интересуют другие нечисловые символы, которые могут присутствовать в правой части.
  - `parseFloat(42)` //Строка -> число с запятой

  <br></p>
  </details>

[//]: # (Неявные преобразования)
- <details><summary><b>Неявные преобразования</b></summary><p>

  - `Number` --> `String`
    - Оператор унарный `+`
      - число можно преобразовать в строку простым «сложением» его с пустой строкой: `42 + '' // '42'`
      - если один из операндов `+` является строкой (или становится ею в переобразования объекта/массива), то выполняется операция конкатенации строк. Поэтому при математическом сложении переменных внимательно проверяем, что оба операнда — числа
      - если один из операндов является BigInts — выдаёт TypeError
      - если один из операндов является Symbol — выдаёт TypeError
      - в остальных случаях всегда выполняется числовое сложение.
        - `[1,2] + [3,4] // '1,23,4' - вначале получили две строки, потом склеили их`
  -
  - `String` --> `Number`
    - Оператор унарный `+`
      - если перед строкой поставить `+` — JS попытается считать из неё число
      - Алгоритм
        - пробельные символы по краям обрезаются (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.).
        - если остаётся пустая строка — 0,
        - иначе из непустой строки «считывается» число. При ошибке результат NaN.
    - Оператор унарный `-`
      - определен только для числового вычитания, так что `а - 0` инициирует преобразование значения `а` в число.
      - при этом меняется знак числа
      - если знак менять не надо — ставим не `--(a)` (это оператор декремента), но `- -(a)` (разбиваем операторы пробелом)
    - Операторы `*` и `/`
      - `а * 1` или `а / 1` встречается реже. Также преобразует к числу.
  -
  - `Boolean` --> `Number`
    - Самый простой метод неявного преобразования — использовать унарный `+`
    - Правила
      - true -> 1
      - false -> 0
  -
  - `*` --> `Boolean`
    - Операторы `!` и `!!`
      - Унарный оператор отрицания `!` явно преобразует значение в boolean.
      - Проблема в том, что значение при этом переходит из истинного в ложное и наоборот.
      - Лучше использовать `!! ` — второй `!` возвращает разряд в исходное состояние.
      - `Boolean(0)` — это то же самое что `!!(0)`
    - Где происходит
      - Условие в команде `if ( .. )` .
      - Условие (вторая часть) в заголовке `for ( .. ; .. )`.
      - Условие в циклах `while ( .. )` и `do .. while( .. )`.
      - Условие (первая часть) в тернарных выражениях `? :`.
      - Левый операнд для операторов `||` или `&&` .

  <br></p>
  </details>

[//]: # (Преобразование «Symbol» -> «*»)
- <details><summary><b>Преобразование «Symbol» -> «*»</b></summary><p>

  - разрешено явно и неявно преобразование к boolean (результат всегда равен true).
  - разрешено явное преобразование к строке
  -
  - запрещено неявное преобразование к строке (при попытке выполнения — ошибка).
  - запрещено любое преобразовать в number (происходит ошибка)

  <br></p>
  </details>

[//]: # (Преобразование объектов)
- <details><summary><b>Преобразование объектов</b></summary><p>

  - **Object -> Boolean**
    - Любой объект в логическом контексте – `true`.
    - Даже если это пустой массив или объект (`[]` или  `{}`).
  -
  - **Object -> String**
    - метод `toString`
      - Если в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования.
      - Метод toString не обязан возвращать именно строку. Моет вернуть любой примитив, например число
      - Все объекты, включая встроенные, имеют свои реализации метода toString, например:
        - ```js
          alert( [1, 2] ); // toString для массивов выводит список элементов "1,2"
          alert( new Date ); // toString для дат выводит дату в виде строки
          alert( function() {} ); // toString для функции выводит её код
          ```
    - метод `valueOf`
      - обязан возвращать примитивное значение, иначе его результат будет проигнорирован
    -
    - Обычно это преобразование происходит, когда мы выводим на экран объект при помощи `alert(obj)` и в подобных контекстах.
  -
  - **Object -> Number**
    - метод `valueOf`
    - метод `toString`
    -
    - Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции.
    - Например, объекты `Date` могут быть вычтены, и результатом `date1 - date2` будет разница во времени между двумя датами.
  -
  - **Алгоритм**
    - Есть ли в объекте метод `valueOf()`?
      - Если есть и возвращает примитивное значение — используем его.
    - Иначе ищем, есть ли в объекте переопределение метода `toString()`?
      - Если есть и возвращает примитивное значение — используем его.
    - Иначе реализация `toString()` по умолчанию
      - у массива это переопределенная версия — выполняет строковую конкатенацию всех своих значений (каждое из которых также преобразуется к строковой форме), разделяя их "," (`[1,2,3] -> "1,2,3"`)
      - у обычного объекта это (`Object.prototype.toStriпg()`) — возвращает внутренний `[[Class]]`, например "[objectObject]".

  <br></p>
  </details>

[//]: # (Сравнение)
- <details><summary><b>Сравнение</b></summary><p>

  - Равенство строгое и нестрогое (`==` и `===`)
    - `==` допускает преобразование типа при проверке равенства,
    - `===` запрещает преобразование типа.
  -
  - Вопрос об использовании `==` или `===` на самом деле звучит так: хотите ли вы разрешить преобразования типов при сравнении или нет?
  -
  - Сравнение объектов
    - `==`` и `=== `при сравнении двух объектов ведут себя полностью идентично! Включая функции и массивы
    - Два таких значения равны только в том случае, если оба они ссылаются в точности на одно значение. Никакое преобразование типа при этом не выполняется.
  -
  - Нестрогое сравнение `==`
    - Правила
      - `string`  вначале преобразуется к числу
      - `boolean` вначале преобразуется к числу
      - `object`  вначале преобразуется к примитиву
      - `null` == `undefined`
    - Эвристики
      - Никогда не используйте `==` если один из операндов может быть `boolean`
      - Избегайте `==` если один из операндов может `[]`, `""` или `0`
      -
      - В этих случаях почти всегда лучше использовать `===` вместо `==`, чтобы избежать нежелательных преобразований типов.
    -
    - Сравнение числа и строки
      - Правило: строка преобразуется к числу, потом идёт сравнение
    - Сравнение с boolean
      - Правило: boolean-операнд приводим к числу (1 или 0), и результат сравниваем с другой частью
      -
      - Если с одной из сторон стоит `boolean` — оно всегда сначала преобразуется в число.
      - Рекомендую никогда, никогда, ни при каких обстоятельствах не использовать `==` с `true` или `false`. Никогда.
      - Примеры:
        - ```js
          var а = "42";
          var Ь = true;
          а == Ь; // false. 
          //("42" == Number(true)) -> ("42" == Number(true)) -> ("42" == 1) -> (42 == 1)
          ```
        - ```js
          var а = "42";
          var Ь = false;
          а == Ь; // false. 
          //("42" == Number(false)) -> ("42" == Number(false)) -> ("42" == 0) -> (42 == 0)
          ```
        - ```js
          var а = "42";
          
          // плохо (проверка не проходит!):
          if (а == true) {...}
          
          // тоже плохо (проверка не проходит, т.к. строго равенство не преобразует типы — сравниваем String и Boolean):
          if (а === true) {...}
          
          // достаточно хорошо (неявное преобразование):
          if (а) {...}
          
          // лучше (явное преобразование):
          if (!!а) {...}
          
          // тоже хорошо (явное преобразование):
          if (Вооlеап( а )) {...}
          ```
    - Сравнение null с undefined
      - Правило: `null` == `undefined`. Всегда.
      -
      - ```js
        var а = doSomething();
        
        // Сработает если doSomething() вернет null или undefined
        // Не пройдет при любом другом значении (включая 0, false и "").
        if (а == null) {...}

        //Альтернатива (не очень-то изящная)
        if (а === undefined || а === null) {...}
        ``` 
    - Сравнение объекта и необъекта
      - Правило: объект приводим к примитиву, и результат сравниваем с другой частью
    - Сравнения ложных значений
      - ```js
        "0" == null;        // false
        "0" == undefined;   // false
        "0" == false;       // true - ОЙ!
        "0" == NaN;         // false
        "0" == 0;           // true
        "0" == "";          // false
        
        false == null;      // false
        false == undefined; // false
        false == NaN;       // false
        false == 0;         // true - ОЙ!
        false == "";        // true - ОЙ!
        false == [ ];       // true - ОЙ!
        false == {};        // false

        "" == null;         // false
        "" == undefined;    // false
        "" == NaN;          // false
        "" == 0;            // true - ОЙ!
        "" == [];           // true - ОЙ!
        "" == {};           // false

        0 == null;          // false
        0 == undefined;     // false
        0 == NaN;           // false
        0 == [];            // true - ОЙ!
        0 == {};            // false
      ```
      - Итого, есть 7 нестандартных случаев. Их надо запомнить.
      - Обратите внимание: в списке нет ни одного ложного отрицательного срабатывания (т.е. такого, которе при сравнении даст «false»)
      - 4 из 7 пунктов включают сравнение `== false`, которое, никогда, никогда не следует использовать. Это правило запоминается довольно легко.
        - ```js
          "0" == false;       // true - ОЙ!
          false == 0;         // true - ОЙ!
          false == "";        // true - ОЙ!
          false == [ ];       // true - ОЙ!
          ```
      - Список сокращается до 3 пунктов:
        - ```js
          "" == 0; // true - ОЙ!
          "" == []; // true - ОЙ!
          0  == []; // true - ОЙ!
          ```
    - Особые случаи
      - ```js
        [] == ![];          // true. То же что [] == false.
        2  == [2];          // true. Из массива считывается строка. Она приводится к числу
        "" == [null];       // true. [null] -> [] -> "" -> 0.  
        0  == "\n";         // true. Преобразование пустых строк "", "\n", " " и т.д. дает 0.
        ```  
  -

  <br></p>
  </details>

[//]: # (Операторы сравнения)
- <details><summary><b>Операторы сравнения</b></summary><p>

  - Операторы `==` и `===` действуют одинаково!
  -
  - Одно отличие — `==` допускает преобразование типа перед сравнением. Позволяет сначала выполнить преобразование типа, и когда с обеих сторон будут значения одинаковых типов действует точно также как `===`.
  - Оператор `==` преобразует нечисловые значения ("42" и true) в числа перед сравнением. Т.е. оператор отдает предпочтение примитивным числовым значениям.
  - Операторы относительного сравнения обычно используют сравнения чисел, кроме того случая, в котором оба сравниваемых значения уже являются строками; в таком случае используется алфавитное сравнение строк.
  -
  - Операторы `>`, `<`, `>=`, `<=` ведут себя как `==`!

  <br></p>
  </details>

[//]: # (Специальное равенство — Object.is)
- <details><summary><b>Специальное равенство — Object.is(..)</b></summary><p>

  - Метод, может использоваться для проверки двух значений на строгое равенство без каких-либо исключений (с учетом `NaN`, `+0`, `-0`).
    - сравнение с NaN (это значение не равно ничему, даже самому себе)
    - сравнение `+0` и `-0`
  -
  - Пример
    ```js
      var а = 2 / "foo"; //получается (2 / NaN) -> NaN
      Object.is( а, NaN ); //true
    ```

  <br></p>
  </details>

[//]: # (Унарные операторы «+» и «-» )
- <details><summary><b>Унарные операторы «+» и «-»</b></summary><p>

  - Унарный оператор `+` преобразует строку в число.
  -
  - Унарный оператор `-` тоже выполняет преобразование строки в число (как и `+`). Но он также меняет знак числа.
    - Тем не менее нельзя поставить два минуса `- -` рядом друг с другом для восстановления знака, поскольку такие символы будут интерпретированы как оператор декремента. Вместо этого нужно поставить между ними пробел: `- - "3.14"` (преобразуется к числу `3.14`).
  -
  - `+new Date();` иногда используют чтоб преобразовать дату в число
    - Не делайте так! Используйте `new Date().getTime()` или, для текущей даты — `Date.now()`

  <br></p>
  </details>

[//]: # (Операторы «||» и «&&»)
- <details><summary><b>Операторы «||» и «&&»</b></summary><p>

  - Не обязательно дают boolean!
  - Они выдают значение одного (и только одного) из двух операндов. При этом он может быть не boolean.
  - ```js
    var а = 42;
    var b = "аЬс";
    var с = null;
    а || b; //  42
    а && b; // "аЬс"
    с || b; // "аЬс"
    с && b; // null
    ``` 
  - Операторы выполняют логическую проверку первого операнда (а или с). Если операнд не относится к типу `boolean` (как в данном случае), происходит нормальное преобразование к `ToBoolean` для выполнения проверки.
  - Оператор `||`
    - если условие истинно — результатом выражения `||` становится значение первого операнда (`а` или `с`).
    - если условие ложно — результатом выражения `||` становится значение второго операнда (`b`).
  - Оператор `&&` наоборот
    - если условие истинно, то результатом выражения `&&` становится значение второго операнда (`b`).
    - если же условие ложно, то результатом выражения `&&` становится значение первого операнда (`а` или `с`).
  -
  - На эти операторы можно взглянуть иначе:
    `а || b;` // приблизительно эквивалентно `а ? а : b;`
    `а && b;` // приблизительно эквивалентно `а ? b : а;`
  -
  - Популярное применение
    - ```js
      function foo(a,b) {
        а = а || "hello";
        b = b || "world";
        console.log( а + " " + b );
      }
      foo(); // "hello world"
      foo( "yeah", "yeah!" ); // "yeah yeah!"
    
      Но будьте внимательны!
      foo( "That's it!", "" ); // "That's it! world" <--Ой!
      ```
    - Видите проблему? `""` как второй аргумент является ложным значением (см. «ToBoolean»), поэтому проверка `b = b || "world"` не проходит, и    используется значение по умолчанию `"world"` - хотя, наверное, разработчик хотел, чтобы `b` было присвоено явно переданное значение `""`.
    -
  - Идиома `||` встречается очень часто, она очень полезна. Но ее следует использовать только в тех случаях, когда все ложные значения должны пропускаться! Т.е. если вместо первого операнда придёт `0`, `null`, `undefined`, `NaN` или `""`  — мы считаем их неверными и выбираем второй операнд (то что стоит справа от `||`)
  - Иначе проверку условия в данном случае нужно сформулировать более явно — например использовать тернарный оператор `? :` .

  <br></p>
  </details>

[//]: # (Побитовые операторы)
- <details><summary><b>Побитовые операторы («~», «|», ...)</b></summary><p>

  - Список побитовых операторов
    - `a & b` — Побитовое И (AND)
      - Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
    - `a | b` — Побитовое ИЛИ (OR)
      - Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
    - `a ^ b` — Побитовое исключающее ИЛИ (XOR)
      - Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
    - `~a` — Побитовое НЕ (NOT)
      - Заменяет каждый бит операнда на противоположный.
    - `a << b` — Левый сдвиг
      - Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
    - `a >> b` — Правый сдвиг, переносящий знак
      - Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
    - `a >>> b` — Правый сдвиг с заполнением нулями
      - Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.
  - сначала выполняет преобразование `ToNumber`;
  - с некоторыми специальными числовыми значениями он дает эффект, приводящий к изменению значения числа. Эти специальные числа непредставимы в 32-разрядном формате (поскольку они происходят из 64-разрядного стандарта IEEE754), поэтому `Toint32` просто возвращает 0 как результат для таких значений.
  - ```js
    0 | -0; // 0
    0 | NaN; // 0
    0 | Infinity; // 0
    0 | -Infinity; // 0
    ```
  - `~х` примерно то же, что `-(x+l)`. `~42; // -(42+1) ==> -43`
  - `~(-1) === -0`, а `Boolean(-0) === false`. Поэтому `~(x)` часто используют для проверки на `-1`
    - `-1` часто является результатом при определении строковой операции `indexOf( .. )`, которая ищет вхождение подстроки и возвращает индекс его начальной позиции (начиная с нуля) — если вхождение не найдено, возвращается `-1`. Здесь и пригодится такая проверка.
    - Также используется для логической проверки присутствия/отсутствия подстроки в другой строке.
    - ```js
      var a = "Hello World";
      ~a.indexOf( "lo" );
    ```
  - иногда используют `~~` (двойная тильда) для усечения дробной части числа (то есть его «преобразования» к целому числу).
    - эта конструкция надежно работает для 32-разрядных значений
    - с отрицательными числами она работает не так, как `Math. floor( .. )` — кажется всегда округляет вниз (проверить)

  <br></p>
  </details>

[//]: # (Оператор «typeof»)
- <details><summary><b>Оператор «typeof»</b></summary><p>

  - Применение `typeof` к переменной не означает «К какому типу относится эта переменная?»
  - Потому что переменные JS не обладают типами.
  - Вместо этого вы спрашиваете: «К какому типу относится значение в этой переменной?»
  -
  - В JS нет «принудительного контроля типов» — движок не требует, чтобы в переменной всегда хранились переменные исходного типа, с которым она начала свое существование. В одной команде присваивания переменной может быть присвоена строка, в другой - число, и т. д.
  - В JS у переменных нет типов. Типы есть у значений. Переменная может хранить любое значение в любой момент времени.
  -
  - `typeof` возвращает тип примитива, или object в противном случае
  - нюансы
    - typeof `null` — `object` (хотя реальный тип 'null')
    - typeof `function` — `function` (хотя реальный тип 'object')
    - typeof `NAN` — `number`
    - typeof `new Number(123)` — `object`
    - typeof `[1,2]` — `Object` (все массивы = объекты)
  -
  - Безопасная проверка глобальных переменных с помощью `typeof`
    - Вы должны внимательно отнестись к проверке глобальной переменной в остальном коде приложения, чтобы избежать ошибки `RefereпceError`.
    - Здесь `typeof` приходит на помощь:
      - ```js
        //Упс! Это вызовет ошибку! 
        if (DEBUG) { 
          console.log( "Debugging is starting" ); 
        } 

        // Безопасная проверка существования 
        if (typeof DEBUG !== "undefined") { 
          console.log( "Debugging is starting" ); 
        } 
        ```
    -
    - Есть другой способ выполнения тех же проверок глобальных переменных без «защиты typeof» — проверка факта, что все глобальные переменные также являются свойствами глобального объекта (в браузере — объект window):
      - ```js
        if (window.DEBUG) { 
          // ...
        } 
        ```
      - В отличие от обращений к необъявленным переменным, попытка обращения к несуществующему свойству объекта (даже глобального) ошибку `ReferenceError` не выдает.

  <br></p>
  </details>

[//]: # (Проверь себя)
- <details><summary><b>Проверь себя</b></summary><p>

  - Чему будет равно выражение в каждой строке?
  - ```
    1)  true + false
    2)  12 / "6"
    3)  "number" + 15 + 3
    4)  15 + 3 + "number"
    5)  [1] > null
    6)  "foo" + + "bar"
    7)  'true' == true
    8)  false == 'false'
    9)  null == ''
    10) !!"false" == !!"true"
    11) [‘x’] == ‘x’
    12) [] + null + 1
    13) [1,2,3] == [1,2,3]
    14) {}+[]+{}+[1]
    15) !+[]+[]+![]
    16) new Date(0) - 0
    17) new Date(0) + 0
    ```
  - 
  - Ответ
  - ```
    1)  true + false             // 1
    2)  12 / "6"                 // 2
    3)  "number" + 15 + 3        // 'number153'
    4)  15 + 3 + "number"        // '18number'
    5)  [1] > null               // true
    6)  "foo" + + "bar"          // 'fooNaN'
    7)  'true' == true           // false
    8)  false == 'false'         // false
    9)  null == ''               // false
    10) !!"false" == !!"true"    // true
    11) ['x'] == 'x'             // true
    12) [] + null + 1            // 'null1'
    13) [1,2,3] == [1,2,3]       // false
    14) {}+[]+{}+[1]             // '0[object Object]1'
    15) !+[]+[]+![]              // 'truefalse'
    16) new Date(0) - 0          // 0
    17) new Date(0) + 0          // 'Thu Jan 01 1970 02:00:00(EET)0'
    ```
  - Подробный разбор: [Habr - Неявное преобразование типов в JavaScript](https://habr.com/ru/company/ruvds/blog/347866/)
  
  <br></p>
  </details>
  

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Таблица преобразования типов JS](https://dorey.github.io/JavaScript-Equality-Table/)
  - [Doka - Преобразование типов](https://doka.guide/js/typecasting/#preobrazovanie-tipov)
  - [learn.javascript.ru - Преобразование типов](https://learn.javascript.ru/type-conversions)
  - [Medium - Преобразование типов в JavaScript](https://medium.com/@sergeybulavyk/%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B2-javascript-35a15ddfc333)
  - [proglib.io - 5+5=? Преобразование значений в строку или число в JavaScript](https://proglib.io/p/5-5-preobrazovanie-znacheniy-v-stroku-ili-chislo-v-javascript-2022-05-15)
  - [Habr - Неявное преобразование типов в JavaScript](https://habr.com/ru/company/ruvds/blog/347866/)
  - [freecodecamp.org - 10 способов преобразовать строку к числу (en)](https://www.freecodecamp.org/news/how-to-convert-a-string-to-a-number-in-javascript/)
  - [MDN - Приоритет операторов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_precedence)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Значения и ссылки)
<details id="objectReference"><summary><b>Значения и ссылки</b></summary><p>


[//]: # (Копирование «по значению»)
- <details><summary><b>Копирование «по значению»</b></summary><p>

  - Примитивы при присваивании переменных копируются целиком - `по значению`. 
  - Boolean, string, numbers, bigInt, symbol, null, undefined
  - ```js
    var message = "Привет!";
    var phrase = message;
    // Две независимые переменные, каждая хранит значение "Привет!"
    // Изменение `message` никак не влияет на `phrase`
    ```

  <br></p>
  </details>


[//]: # (Копирование «по ссылке»)
- <details><summary><b>Копирование «по ссылке»</b></summary><p>

  - Объекты (в том числе массивы и функции) копируются `по ссылке`.
  - В переменной, которой присвоен объект, хранится не сам объект, а «ссылка» на него (адрес его места в памяти).
  - Если есть две переменные с одной и той же функцией - в них не лежат копии этой функции! Обе эти переменные ссылаются на одну и ту же функцию:
    - ```js
      function func() {
      alert('!');
      };
  
      var test = func; //И `test` и `func` указывают на одну и ту же функцию. Изменим одну - изменится и вторая
      ``` 
  -
  - Ссылки JS не похожи на ссылки/указатели других языков — они никогда не указывают на другие переменные/ссылки, а только на используемые значения. `a` не может ссылаться на `b`, но они могут ссылаться на общий объект.
  -
  - Так как ссылки указывают на сами значения, а не на переменные, одна ссылка не может использоваться для изменения того, на что ссылается другая ссылка:
    - ```js
      var а = [1,2,3];
      var Ь = а;
      а; // [1,2,3]
      Ь; // [1,2,3]

      // позднее
      ь = [4,5,6];
      а; // [1,2,3]
      Ь; // [4,5,6]
      ``` 

  - Выполняя присваивание `b = [4,5,б]`, мы абсолютно ничего не делаем для изменения того, на что сейчас ссылается `а` (`[1,2,3]`).
  - Чтобы это произошло, переменная `b` должна быть указателем, а не ссылкой на массив, но в JS такой возможности нет.
  -
  - Чаще всего такие недоразумения происходят с параметрами функций:

    - ```js
      function foo(x) {
        x.push( 4 );
        х; // [1,2,З,4]
      
        х = [4,5,6];
        x.push( 7 );
        х; // [4,5,6,7]
      }
      
      var а = [1,2,З];
      foo( а );
      а; // [1,2,З,4], а не [4,5,6,7] 
      ``` 

  - При передаче аргумента `а` копия ссылки `а` присваивается `х`.
  - `х` и `а` - разные ссылки, указывающие на одно значение `[1,2,3]`.
  - Теперь внутри функции можно использовать эту ссылку для изменения самого значения (`push(4)`).
  - Но когда мы выполняем присваивание `х = [4,5,6]`, оно никак не влияет на то, на что указывает исходная ссылка, она все еще указывает на (уже измененный) `[1,2,3,4]``.
  - Ссылка `х` не может использоваться для изменения того, на что указывает `а`.
  - Можно только изменить содержимое общего значения, на которое указывает как `а`, так и `х`.
  - Чтобы переменная а изменилась и содержала `[4,5,6,7]`, вам не удастся создать новый массив и выполнить присваивание, необходимо изменить существующее значение массива:
    - ```js
      function foo(x) {
      x.push( 4 );
      x // (1,2,3,4]
    
      x.length = 0; // очистить существующий массив на месте
      x.push( 4, 5, 6, 7 );
      x; // (4,5,6,7]
      }
      
      var а = [1,2,З];
      foo( а ) ;
      а; // [4,5,6,7] а не [1,2,3,4]
      ``` 
  - Как видите, `x.length = 0` и `x.push(4,5,6,7)` не создают новый массив, а изменяют существующий общий массив.
  - И конечно, `а` ссылается на новое содержимое `[4,5,6,7]`.
  -
  - **Способы копировать объект**
    - См. ниже — [«Объекты. Копирование объектов»](#objectCopy)
    - [Medium - Копирование объектов в JavaScript (2019)](https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff)

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Копирование объектов и ссылки](https://learn.javascript.ru/object-reference)
  - [TOП-12 JavaScript-концепций: от ссылок до асинхронных операций](https://proglib.io/p/js-concepts/)
  - [Передача параметров по значению и по ссылке](https://metanit.com/web/javascript/3.7.php)
  - [Habr - Функции в Javascript: ссылки и вызовы](https://habr.com/ru/sandbox/18362/)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Область видимости)
<details id="eventHoisting"><summary><b>Область видимости</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - `Область видимости` — механизм языка (набор правил). Решает 2 вопроса:
    - как язык узнаёт какие переменные доступны для данной конкретной команды
    - как вести себя в ситуации когда есть две переменных с одинаковыми именами
  - 
  - Видимость в основном определяется движком JS в фазе компиляции, т.е. до того как код отдаётся на выполнение.
  - Все идентификаторы регистрируются в соответствующих областях видимости во время компиляции. Более того, каждый идентификатор создается в начале той области видимости, которой он принадлежит, при каждом входе в эту область видимости.
  - Кроме объявлений, все вхождения переменных/идентификаторов в программе играют одну из 2 ролей. Они являются:
    - либо приемником присваивания (например левая часть выражения a=b).
      - если переменной присваивается значенеи — это приёмник
    - либо источником значения (например правая часть выражения a=b)
      - если переменной НЕ присваивается значение — это источник

  - Цепочка областей видимости программы — концепция вложенности области видимости.
    - От глобальной области видимости вниз.
    - Расположение областей видимости, вложенных друг в друга — естественая иерархия областей видимости

  - Все правила области видимости (включая повторное объявление переменных, созданных с `let`) применяются на уровне экземпляра области видимости.
    - Т.е. каждый раз, когда во время выполнения программа входит в область видимости, происходит сброс в исходное состояние.
    - Поэтому Каждая итерация цикла имеет собственный новый экземпляр области видимости, и в каждом экземпляре области видимости
  - 
  - Во внутреннем представлении область видимости может рассматриваться как объект, содержащий свойство для каждого из доступных идентификаторов. Однако «объект» области видимости недоступен для кода JS — он является внутренней частью реализации движка.
  - 
  - Правила лексических областей видимости в языках программирования существуют для того, чтобы правильно организовать переменные в вашей программе — как для практических целей, так и для передачи семантических сигналов о коде.
  - 
  - `Замыкание` является естественным результатом лексической видимости в языках, в которых функции являются полноправными значениями, как в JS. Когда функция создает ссылки на переменные из внешней области видимости, а потом эта функция передается как значение и выполняется в других областях видимости, она сохраняет доступ к переменным исходной области видимости. В этом состоит суть замыкания.
  - Неочевидные случаи возникновения области видимости:
    - область видимости параметров функции — со значениями по умолчанию, переменные списки параметров (с использованием `...`) и деструктурированные параметры.;
    - область видимости имен функций 

  <br></p>
  </details>

[//]: # (Программа может)
- <details><summary><b>Программа может</b></summary><p>

  - объявить глобальную переменную в области видимости верхнего уровня с использованием объявлений var и function или let, const и class;
  - также добавлять объявления глобальных переменных как свойства объекта глобальной области видимости, если для объявления используется ключевое слово var или function;
  - обращаться к объекту глобальной области видимости (для добавления и получения глобальных переменных как свойств) через window, self или global.

  <br></p>
  </details>

[//]: # (Лексическая и динамическая области)
- <details><summary><b>Лексическая и динамическая области</b></summary><p>

  - В JS используется механизм `лексической области видимости` (бывает ещё динамическая)
    - Механизм поиска значений: смотрим в текущей области, если нет — идём на уровень выше, и так далее.
    - главная характеристика «лексической области видимости» — означает, что видимость задаётся исключительно текстом программы, исходным кодом. То есть можно смотреть на программу, не запуская её, и понять область видимости в любой точке.
    - здесь область видимости определяется на этапе компиляции, который называется «разбиение на лексемы/лексический разбор»
      - это этап, когда строка символов разбивается на осмысленные (для языка) фрагменты, называемые лексемами.
      - Пример: `var a = 2;` — скорее всего, эта программа будет разбита на следующие лексемы: `var`, `a`, `=`, `2` и `;`.
    - У реализации «лексической области видимости» в JS есть две особенности:
      - `поднятие` (hoisting) — все переменные, объявленные в любой точке области видимости, интерпретируются так, словно объявлены в ее начале
      - переменные, объявленные с ключевым словом `var`, имеют функциональную область видимости, даже если располагаются в блоке.
  -
  - Динамическая область видимости
    - встречается реже. Например в таком режиме может работать Perlю
    - локальная область видимости ограничена временем исполнения функции. Имя доступно, пока функция выполняется, и исчезает, когда функция возвращает управление вызвавшему её коду.
    - Каждый идентификатор имеет глобальный стек привязок и при поиске значения используется самая последняя привязка.
    - Другими словами, сначала компилятор ищет имя в текущем блоке, а затем последовательно во всех вызвавших текущий блок функциях.
    - При использовании динамических областей видимости недостаточно знать где написан код, нужно знать как он запускается. Каждый раз при запуске функции создаётся новая область видимости.
    - Так, если функция f вызывает не вложенную в неё функцию g, то
      - при лексическом подходе функция g не имеет доступа к локальным переменным функции f.
      - при динамическом подходе функция g будет иметь доступ к локальным переменным функции f, поскольку g была вызвана во время работы f.

  <br></p>
  </details>

[//]: # (Новая область видимости создается)
- <details><summary><b>Новая область видимости создается</b></summary><p>

  - глобальная — одна на все приложение
  - своя область видимости верхнего уровня для каждого файла/модуле
  - своя область видимости для каждого определения функции (declaration или expression). В том числе для стрелочных!
  - своя область видимости для каждого блока ограниченного `{}` (например — цикле), если в нём используются `let` или `const`(См. ниже)
    - ```js
      var keeps = [];
      for (var i = 0; i < 3; i++) {
        keeps[i] = function keepI(){
          return i; // замыкание по `i`
        };
      }
      keeps[0](); // 3 -- ПОЧЕМУ!?
      keeps[1](); // 3
      keeps[2](); // 3
      ```
  <br></p>
  </details>

[//]: # (Затенение)
- <details><summary><b>Затенение</b></summary><p>

  - Переменная (параметр) X из локальной ОВ замещает переменную X из внешней ОВ. Т.е. параметр `затеняет` (затеняемую) глобальную переменную.
  - Каждая новая область видимости предоставляет пространство для хранения ее собственного набора переменных. 
    - Если имя переменной повторяется на разных уровнях цепочки, происходит затенение, которое блокирует доступ к внешней переменной с этой точки по направлению к внутренним областям.
  - Различия между лексическими областями видимости играют важную роль, когда в программе встречаются 2 и более переменные с одинаковыми именами, определенные в разных областях видимости.
  - В одной области видимости не может быть двух и более переменных с совпадающими именами; такие множественные ссылки будут интерпретироваться как одна переменная.
  - Если требуется создать 2 и более переменные с одинаковыми именами, необходимо использовать разные (часто вложенные) области видимости. В этом случае очень важно, как эти области видимости расположены относительно друг друга.
  - JS на самом деле не хочет, чтобы мы «повторно объявляли» переменные в пределах области видимости. Это противоречит духу языка.
  - 
  - **Глобальный объект и затенение**
    - К глобальной переменной можно обратиться из области видимости, в которой эта переменная была затенена, но обычно ссылки на лексический идентификатор будет недостаточно.
    - В глобальной области видимости объявления `var` и объявления функций также предоставляются как свойства (с таким же именем, как у идентификатора) `глобального объекта` — по сути, объектного представления глобальной области видимости. Для браузера это глобальный объект с именем `window`.
    - При объявлении в глобальной области видимости переменной через `var` (а также при объявлении функции), в глобальном объекте (например `windows`) появляется одноименное свойство с соответствующим значением.
    - Через это свойство можно не только читать, но и менять значение переменной (связь двусторонняя: поменял переменную - поменялось свойство, поменялось свойство - изменилась переменная). Можно даже таким образом создать переменную (просто создав свойство windows.someName)
    - Выражение `window.studentName` обращается к глобальной переменной `studentName` как свойству `window` (глобального объекта). Это единственный способ обратиться к замещенной переменной из области видимости, в которой находится замещающая переменная.
    - Этот трюк подходит только для обращения к переменной из глобальной области видимости и только к переменным, объявленным с ключевым словом `var` или `function`.
    -
    - Не работает в модулях
    - Не работает для `let` и `const`
    - Не все комбинации замещения объявлений допустимы. `let` может замещать `var`, но `var` не может замещать `let`:
      - Настоящая причина, по которой выдается ошибка `SyntaxError`, заключается в том, что `var` фактически пытается пересечь границу («перепрыгнуть») одноименного объявления `let`, что недопустимо.
      - ИТОГ: 
        - объявление `let` (во внутренней области видимости) всегда может затенить объявление `var` во внешней области видимости. 
        - объявление `var` (во внутренней области видимости) может затенить объявление `let` во внешней области видимости только в том случае, если между ними есть граница функции.
    - 
    - Когда использовать `var`, а когда `let`/`const`
      - Объявил `windows.name = 1`.
      - Объявил на верхнем уровне `let name = 2`.
      - `console.log(windows.name) //1`
      - `console.log(name) //2`
      -
      - Вывод: поэтому рекомендуют глобальные переменные объявлять через `var`, а `let` и `const` использовать в блоках и функциях
      - Все эти ловушки с глобальными объявлениями можно просто обойти: всегда используйте `var` для глобальных имен. `let` и `const` следует зарезервировать для блоковых областей видимости

  <br></p>
  </details>

[//]: # (Область видимости имени функции)
- <details><summary><b>Область видимости имени функции</b></summary><p>

  - `function askQuestion() {...}` — такое объявление функции создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор с именем askQuestion.
  - `var askQuestion = function() {...}` — такое объявление создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор ПЕРМЕННОЙ с именем askQuestion.
    - Сама функция при этом не «поднимается» (см. Симпсон К - Вы не занете JavaScript. Книга 2. Область видимости и замыкания (2 изд) Глава 5).
    - у анонимных функциональных выражений нет идентификатора, влияющего на какую-либо из областей видимости.
  - `var askQuestion = function someName() {...}` — такое объявление создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор ПЕРМЕННОЙ с именем askQuestion.
    - При этом `someName` объявляется как идентификатор в области видимости функции (условно), не поднимается наверх.
    - Плюс к тому переменная `someName` определяется как доступная только для чтения.
  - Стрелочные функции являются лексически анонимными — в программе не существует напрямую связанного с ними идентификатора, который ссылается на функцию.

  <br></p>
  </details>

[//]: # (Глобальные средства DOM)
- <details><summary><b>Глобальные средства DOM</b></summary><p>

  - В приложениях JS на базе браузеров возможно такое: элемент DOM с идентификатором id автоматически создает глобальную переменную, которая ссылается на него.
  - Лучше этот фокус не использовать, но знать полезно

  <br></p>
  </details>

[//]: # (Глобальная область видимости)
- <details><summary><b>Глобальная область видимости</b></summary><p>

  - Приложение часто состоит из N файлов. Движок JS собирает их в один контекст исполнения. Как?
    1. Если вы напрямую используете модули ES (без их транспиляции в другой формат упаковки модулей)
    - эти файлы загружаются по отдельности средой JS. Затем каждый модуль импортирует ссылки на любые другие модули, к которым он должен обращаться.
    - Файлы модулей взаимодействуют друг с другом исключительно через эти директивы импортирования, никакая общая внешняя область видимости им для этого не нужна.
    2. Если вы используете упаковщик в своем процессе сборки приложения
    - все файлы обычно объединяются посредством конкатенации перед их передачей браузеру и движку JS, после чего обрабатывается только один большой файл.
    - Даже когда все фрагменты приложения хранятся в одном файле, потребуется некий механизм, при помощи которого каждый фрагмент может зарегистрировать имя, к которому будут обращаться другие фрагменты, а также некоторые средства для реализации таких обращений.
    3. Независимо от того, используется ли для приложения программа-упаковщик или же файлы (кроме модулей ES) просто загружаются в браузере по отдельности (при помощи тегов `<script>` или других средств динамической загрузки ресурсов JS) — если не существует одной охватывающей области видимости для всех этих фрагментов, глобальная область видимости становится единственным способом организации взаимодействия между ними.
  -
  - Если js-файлы скриптов загружаются по отдельности как обычные автономные файлы .js в среде браузера, каждое объявление переменной верхнего уровня оказывается глобальной переменной, так как глобальная область видимости оказывается единственным общим ресурсом для этих двух разных файлов — с точки зрения движка JS, они являются независимыми программами.
  -
  - Глобальная область видимости не должна становиться свалкой для всех переменных вашего приложения. Свалка только создает хаос для многочисленных ошибок.
  -
  - Зачем нужна Глобальная область видимости
    - ведения учета того, где код приложения размещается во время выполнения
    - возможности каждого фрагмента по обращению к другим фрагментам для взаимодействия с ними
    - движок JS предоставляет доступ к своим встроенным
      - примитивам: undefined, null, Infinity, NaN;
      - платформенным средствам: Date(), Object(), String() и т. д.;
      - глобальным функциям: eval(), parseInt() и т. д.;
      - пространствам имен: Math, Atomics, JSON;
      - сопутствующим средствам: Intl, WebAssembly;
    - среда, под управлением которой работает движок JS, предоставляет доступ к своим встроенным
      - консоли (и ее методам);
      - средствам DOM (window, document и т. д.);
      - таймерам (setTimeout(..) и т. д.);
      - API веб-платформы: navigator, history, геолокация, WebRTC
      - т. д.
    - И это далеко не все глобальные средства, с которыми может взаимодействовать ваша программа.

  <br></p>
  </details>

[//]: # (Модули)
- <details><summary><b>Модули</b></summary><p>

  - Область видимости верхнего уровня в модуле происходит от глобальной области видимости почти так же, как если бы все содержимое модуля было упаковано в функцию.

  <br></p>
  </details>

[//]: # (Поднятие, hoisting)
- <details><summary><b>Поднятие (hoisting)</b></summary><p>

  - `Поднятие` (hoisting) — ситуация, когда переменная видима от начала своей вмещающей области видимости, хотя ее объявление может находиться ниже в области видимости.
  - Метафора поднятия: объявления функций поднимаются первыми, а затем после всех функций немедленно поднимаются переменные. 
    - Это не совсем точная модель, но допустимое приближение.
  - Поднятие обычно описывается как реальный механизм движка JS, но в действительности это скорее метафора для описания различных аспектов обработки объявлений переменных JS в фазе компиляции
  - 
  - Поднятие `var` и `функций`
    - Т.е, как переменной `greeting` может быть присвоено значение (ссылка на функцию) с момента выполнения области видимости? 
      - Ответ — в специальной характеристике формальных объявлений function, называемой `поднятием функций`. 
      - Когда идентификатор объявления function регистрируется в начале своей области видимости, он дополнительно автоматически инициализируется ссылкой на эту функцию. 
      - Поэтому функция можно вызвать в первой строке кода, даже если она определена в пятой.
    - Поднятие функций применяется только к `Functional Declaration` (а конкретно тех, которые располагаются вне блоков — см. раздел FiB главы 6), но не к присваиваниям `Functional Expression`.
    - Важное отличие `Functional Declaration` от `Functional Expression` присваивания функции переменной var . 
      - `Объявление функции` поднимается и инициализируется своим значением функции (это `поднятие функции`). 
      - Переменная `var` тоже поднимается и автоматически инициализируется `undefined`. 
        - Все последующие присваивания `функциональных выражений` этой переменной не выполняются до того момента, когда это присваивание будет обработано во время выполнения. 
      - В обоих случаях идентификатор (имя) поднимается. Но связывание ссылки на функцию не обрабатывается во время инициализации (начало области видимости), если только идентификатор не был создан в формальном объявлении function (`Functional Declaration`).
    - И `поднятие функции`, и `поднятие var`-переменных связывают свои идентификаторы с ближайшей вмещающей **областью видимости функции** (а если ее нет — глобальной областью видимости), а не с блоковой областью видимости.
  - 
  - Поднятие `let` и `const`
    - Объявления с `let` и `const` тоже поднимаются (см. TDZ). 
      - Но эти две формы объявлений связываются со своим вмещающим блоком, а не с вмещающей функцией, как в случае с объявлениями var и function
    - Если повторное присваивание для объявлений `const` невозможно, а объявления `const` всегда требуют присваивания, появляется четкая техническая причина, по которой для `const` должны быть запрещены повторные объявления: 
      - любое повторное объявление `const` также неизбежно станет повторным присваиванием `const`. А это запрещено!

  <br></p>
  </details>

[//]: # (Temporal Dead Zone, TDZ)
- <details><summary><b>Temporal Dead Zone (TDZ)</b></summary><p>

  - `TDZ` — период, в котором переменная существует, но все еще остается неинициализированной, и поэтому к ней невозможно обратиться никаким способом. Период от входа в область видимости до точки автоматической инициализации переменной.
  - `Ошибка TDZ` возникает из-за того, что объявления let/const поднимаются в начало своих областей видимости, но, в отличие от var, они откладывают автоматическую инициализацию своих переменных до той точки последовательности выполнения, в которой появляется исходное объявление. Это временное окно, независимо от его длины, и образует область TDZ
  -
  - **Механизм**
    - Компилятор удаляет все объявления `var`/`let`/`const` и заменяет их командами **регистрации** соответствующих идентификаторов в начале каждой области видимости.
    - при этом всем переменным `var` в момент регистрации присваивается занечение `undefined` — к ним уже можно обратиться, но занчение будет undefined. У let и const не так
    - В строках кода, где изначально объявлялись  `var`/`let`/`const`, компилятор оставляет специальные команды **инициализации**.
    - Т.е., после обработки кода компилятором, получаем такую ситуацию:
      - `var` — зарегистрирован в самом верху кода, инициализирован. Значение = `undefined`, пока выполнение не дойдёт до строчки, где ему присвоится иное значение (если такая есть)
      - функции, объявленные как `functional expression` — зарегистрирован в самом верху кода, инициализирован. Значение = ссылка на эту функцию.
        - Важно: если в функции используются внешние переменные — нет никакой гарантии что они к этому момнеты будут зарегистрированы и инициализированны нужными значениями. Поэтому вызывать функцию до момента её объявления — сомнительная идея.
      - функции, объявленные как `functional declaration` — ведут себя как выражения, в рамках которых они объявлены
      - `let` и `const`— зарегистрирован в самом верху кода, не инициализирован. Находятся в TDZ пока пока выполнение не дойдёт до строчки, где им присваивается занчение (если такая есть). После этого момента TDZ завершается, а переменная может свободно использоваться в оставшейся части области видимости.
    - Формально у var тоже есть область TDZ, но она имеет нулевую длину, а следовательно, остается ненаблюдаемой для наших программ! Наблюдаемые TDZ существуют только у let и const..
  -
  - **Как избежать ошибок TDZ?**
    - Всегда размещайте объявления let и const в начале области видимости.
    - Так вы уменьшите окно TDZ до нулевой (или почти нулевой) длины, и проблема исчезнет сама собой.

  <br></p>
  </details>

[//]: # (Принцип наименьшего раскрытия)
- <details><summary><b>Принцип наименьшего раскрытия</b></summary><p>

  - В безопасности есть «принцип наименьших привилегий», он выражает защитную позицию программной архитектуры: компоненты системы должны проектироваться так, чтобы они функционировали с наименьшими привилегиями, наименьшим уровнем доступа и наименьшим раскрытием.
  - Одна из разновидностей этого принципа - `Принцип наименьшего раскрытия`. Сосредоточен на более низком уровне — мы применим  его к взаимодействиям между областями видимости.
  - Переменные, зарегистрированные в каждой области видимости, должны раскрываться наименьшим необходимым образом.
  - Применительно к областям видимости переменных/функций принцип наименьшего раскрытия фактически говорит: 
    - по умолчанию раскрытие должно ограничиваться абсолютным минимумом, а все остальное должно остаться приватным настолько, насколько это возможно. 
    - Объявляйте переменные в областях видимости наименьшего размера и наибольшего уровня вложенности, вместо того чтобы размещать все в глобальной области видимости (или даже внешней функции).
  - 
  - Почему не надо размещать все переменные программы в глобальной области видимости?
    - Когда переменные, используемые одной частью программы, раскрываются для другой части через область видимости, возникают 3 главных риска:
      - Конфликты имен
      - Неожиданное поведение
        - если вы раскроете переменные/функции, использование которых должно быть приватным для некоторой части программы, это позволит другим разработчикам использовать их непредвиденным образом. Это приведет к нарушению ожидаемого поведения и появлению ошибок.
        - Например, если ваша часть программы предполагает, что массив содержит только числа, но чей-то посторонний код обратится к массиву и включит в него логические значения и строки, это может привести к непредвиденным сбоям в вашем коде.
      - Непреднамеренная зависимость
        - раскрывая переменные/функции без необходимости, вы подталкиваете других разработчиков к тому, чтобы использовать эти в остальном приватные части и зависеть от них. И хотя сейчас работоспособность вашей программы от этого не пострадает, в будущем вы уже не сможете легко провести рефакторинг без риска нарушить работоспособность других частей продукта, которые не контролируете.
  - 

  <br></p>
  </details>

[//]: # (Создание областей видимости с блоками)
- <details><summary><b>Создание областей видимости с блоками</b></summary><p>

  - Любая пара фигурных скобок `{...}`, являющаяся командой, будет действовать как блок. Но не обязательно как область видимости. 
  - Блок становится областью видимости только в случае необходимости для размещения объявлений с блоковой областью видимости (т. е. `let` или `const`).
  - Не все пары фигурных скобок  `{...}` создают блоки (а следовательно, становятся кандидатами для превращения в области видимости):
    - `объектные литералы` используют пары фигурных скобок { .. } для ограничения своих списков «ключ — значение», но такие объектные значения не являются областями видимости;
    - `class` использует фигурные скобки { .. } для определения тела, но блок или область видимости при этом не определяется;
    - `тело функции `заключается в { .. }, но с технической точки зрения это блоком не является — это одна команда для тела функции. Тем не менее это (функциональная) область видимости;
    - пара фигурных скобок { .. } в команде `switch` (в которую заключается набор условий case) не определяет блок/область видимости.
  - Кроме этих «неблоковых» примеров пара фигурных скобок { .. }  может определить блок, присоединенный к команде (как if или for), или автономный (просто как пара фигурных скобок { .. } в коде)
  - Используйте явные блоковые области видимости (т.е. просто пары фигурных скобок в коде) для сужения раскрытия идентификаторов до минимального практического уровня.
  - 
  - **Про `var`**
    - `var` присоединяется к ближайшей вмещающей области видимости функции, где бы она ни находилась. Это справедливо даже в том случае, если `var` размещается внутри блока.
    - В большинстве случаях использование `var` следует ограничивать областью верхнего уровня функции. Почему бы не использовать let в этой же точке?
      - Потому что var визуально отличается от let
      - и потому четко сигнализирует: эта переменная имеет функциональную область видимости.
      - Использование let в области видимости верхнего уровня, особенно если оно не находится в нескольких начальных строках функции и когда все остальные объявления в блоках используют let, не привлекает внимания к отличиям от объявлений с функциональной областью видимости.
      - Иначе говоря, я считаю, что var лучше передает функциональную область видимости, чем let, а let одновременно передает (и реализует) блоковую область видимости там, где недостаточно var.
      - Когда использовать let а когда var?
        - Выбор не зависит от того, какое ключевое слово положено использовать в конкретной ситуации. Чтобы принять решение, спросите себя, какое минимальное раскрытие области видимости будет достаточным для этой переменной.
        - Ответив на этот вопрос, вы будете знать, к какой области видимости должна принадлежать переменная — блоковой или функциональной. Если вы изначально решили, что переменная должна иметь блоковую область видимости, а позднее осознаете, что ее следует поднять до функциональной области видимости, это повлияет не только на местоположение объявления этой переменной, но и на используемое при объявлении ключевое слово.
        - Если объявление принадлежит блоковой области видимости, используйте let.
        - Если оно принадлежит функциональной области видимости, используйте var (еще раз: это только мое мнение).
  - 
  - **Про объявления функций**
    - Никогда не размещайте объявления функций непосредственно внутри любого блока!
    - Они по-разному ведут себя в разных средах выполения JS
    - Например, избегайте объявлений
      - внутри if
      - внутри while
      - и т.д.
    - 
    - Всегда размещайте объявления функций в любой точке области верхнего уровня функции (или глобальной  области видимости).
    - Важно заметить, что здесь в команде if размещается функциональное выражение, а не объявление. Размещение функциональных выражений в блоках — абсолютно нормальное и допустимое решение. В нашем обсуждении FiB речь идет о нежелательности функциональных объявлений в блоках.
    - См. Симпсон К — Вы не знаете JS. Книга 2. Область видимости и замыкания (изд. 2) Глава 6 — Объявления функций в блоках (FiB)
    - 

  <br></p>
  </details>

[//]: # (Изменение области видимости во время выполнения)
- <details><summary><b>Изменение области видимости во время выполнения</b></summary><p>
  
  - Работает только в **НЕ `strict` режиме**. 
  - Есть 2 случая, когда область видимости может измениться уже после компиляции (т.е. во время выполнения программы)
  - Их не надо использовать! Делают код запутанным + очень снижают быстродействие.
  - Вот они
    - Функция `eval(...)` —  получает строку с кодом, который должен быть откомпилирован и выполнен «на ходу», во время выполнения программы. Если эта строка кода содержит var или объявление функции, эти объявления изменят текущую область видимости
    - Ключевое слово `with` — динамически преобразует объект в локальную области видимости. Его свойства интерпретируются как идентификаторы в блоке новой области видимости.
      - ```js
        var badIdea = { oops: "Ugh!" };
        with (badIdea) {
        console.log(oops); // Ugh!
        }
        ```
      - Глобальная область видимости здесь не изменяется, но объект `badIdea` приводится в область видимости во время выполнения, а не во время компиляции, а его свойство oops превращается в переменную в этой области видимости

  <br></p>
  </details>

[//]: # (Замыкания)
- <details><summary><b>Замыкания</b></summary><p>

  -
  -
  -

  <br></p>
  </details>

[//]: # (Глобальные переменные DOM)
- <details><summary><b>Глобальные переменные DOM</b></summary><p>

  - Возможно, вы знаете, что объявление переменной в глобальной области видимости (с var или без) создает не только глобальную переменную, но и ее зеркальную копию: одноименное свойство в глобальном объекте (window в браузере).
  - Но менее известно то, что (из-за унаследованного поведения браузеров) при создании элементов DOM с атрибутами id создаются одноименные глобальные переменные.
  - Пример:
    - ```js
	  // В HTML имеем <div id="foo"></div>
	  if (typeof foo == "undefined") { // проверка существования глобальной переменной foo
	  	// Никогда не выполняется
	  	foo = 42;
	  }
	  console.log( foo ); // элемент HTML
      ```
  - Вероятно, вы привыкли управлять проверками глобальных переменных (с использованием typeof или .. в проверках wiпdow) в предположении, что такие переменные создаются только кодомJS. Но как вы видите, они также могут создаваться контентом управляющей страницы HTML, что легко может привести вас в полное замешательство, если вы не будете осторожны.
  - И это еще одна причина, по которой вам следует (если это возможно) избегать глобальных переменных. А если без них не обойтись, используйте переменные с уникальными именами, у которых вероятность совпадения минимальна. Вы также должны следить за тем, чтобы избегать конфликтов имен не только с другим кодом, но и с контентом HTML.

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Лексическое всплытие](https://learn.javascript.ru/bubbling-and-capturing)
  - [learn.javascript.ru - Всплытие и перехват](https://learn.javascript.ru/event-bubbling)
  - [Wiki — Область видимости](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8)
  - Симпсон К - Вы не занете JavaScript. Книга 2. Область видимости и замыкания (2 изд)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Глобальный объект)
<details id="gloablObject"><summary><b>Глобальный объект</b></summary><p> 

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>
  
  - Предоставляет переменные и функции, доступные в любом месте программы. <br>
  - По умолчанию это те, что встроены в язык или среду исполнения. Но можно добавлять и свои.<br>
  - Включает в себя как встроенные объекты (например, `Array`) так и характерные для окружения свойства (например, `window.innerHeight` – высота окна браузера).
  - 
  - В браузере он называется window, в Node.js — global, в другой среде исполнения может называться иначе.<br>
  - В 2020 г. в JS добавили стандартное имя для глобального объекта `globalThis` — должно поддерживаться в любом окружении..
  - 
  - Ко всем свойствам глобального объекта можно обращаться напрямую:
  - ```js
      alert("Привет");
      // это то же самое, что и
      window.alert("Привет");
    ```
  - Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую, как window.x.
  - 
  - В браузере глобальные функции и переменные, объявленные с помощью var (не let/const!), становятся свойствами глобального объекта:
  - ```js
      var gVar = 5;
      alert(window.gVar); // 5 (становится свойством глобального объекта)
    ```
  - 
  - Не рекомендуется использовать глобальные переменные. Следует применять их как можно реже. Дизайн кода, при котором функция получает входные параметры и выдаёт определённый результат, чище, надёжнее и удобнее для тестирования, чем когда используются внешние, а тем более глобальные переменные. Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.

  <br></p>
  </details>

[//]: # (Объект window)
- <details><summary><b>Объект window</b></summary><p>

  - Объект window - это ключевой объект в клиентском JavaScript. Через него доступны все остальные объекты. Например, любой объект Window содержит свойство document, ссылающееся на связанный с окном объект Document, и свойство location, ссылающееся на связанный с окном объект Location.
  - И когда мы пишем, например:  `document.write('Строка')`, то мы можем себе позволить это только потому, что браузер понимает такую сокращённую запись. А полная запись вообще-то должна выглядеть так: `window.document.write('Строка');`
  - То есть объект Window - это глобальный объект в начале цепочки областей видимости, и все клиентские объекты в JavaScript доступны как свойства других объектов. Это значит, что имеется иерархия JavaScript-объектов, в корне которой находится объект Window.
    Кроме того, внутри window находится объект document, через который мы будем работать с содержимым страницы в следующих уроках.
  - Объект window задает глобальный контекст выполнения. window хранит внутри себя все остальные глобально доступные свойства и объекты. Каждый раз, когда мы вызываем глобальные функции, такие как alert() или console.log(), браузер ищет их в объекте window. То есть в действительности происходит вызов window.alert(). То же самое относится и ко всем остальным функциям используемым напрямую, без импортов:
  - ```js
      console.log('hey');
      // window.console.log('hey');

      Math.abs(5);
      // window.Math.abs(5);

      // Можно даже так
      close();
      // вместо window.close()

    ```

  <br></p>
  </details>

[//]: # («Глобальные объекты» , стандартные встроенные объекты)
- <details><summary><b>«Глобальные объекты» (или стандартные встроенные объекты)</b></summary><p>

  - Термин «глобальные объекты» (или стандартные встроенные объекты) здесь не следует путать с самим глобальным объектом.
  - Далее в главе под этим обозначением понимаются объекты в глобальном пространстве имён (но только, если не используется строгий режим ECMAScript 5! В противном случае они возвращают undefined).
  - Сам же глобальный объект в глобальном пространстве имён доступен через оператор `this`.
  - На самом деле, глобальное пространство имён состоит из свойств глобального объекта (в том числе включая унаследованные свойства, если они есть).
  - [Подробнее - MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects)

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Глобальный объект](https://learn.javascript.ru/global-object)
  - [Hexlet - Глобальный объект Window](https://ru.hexlet.io/courses/js-dom/lessons/window/theory_unit)
  - [MDN - Объект Window](https://developer.mozilla.org/ru/docs/Web/API/Window)
  - [MDN - Стандартные встроенные объекты](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects)
  - [Объект window в JavaScript](https://info-master.su/programming/web/js/window-object.php)
  - [Habr - Глобальные объекты и места их обитания (2016)](https://habr.com/ru/company/playrix/blog/316416/?ysclid=l8xvbyp6ji236101828)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Замыкания)
<details id="closures"><summary><b>Замыкания</b></summary><p>

[//]: # (Определения)
- <details><summary><b>Определения</b></summary><p>

  - Из книги Симпсона
    - `Замыкание` — когда функция использует переменную из другой области видимости, даже выполняясь в области видимости где эта переменная должна   быть недоступна.
    - Ключевые части определения:
      - в замыкании должна быть задействована функция;
      - она должна обращаться хотя бы к одной переменной из внешней области видимости;
      - функция должна вызываться из другой ветви цепочки областей видимости относительно той, в которой находится переменная.
    -
    - Замыкание позволяет внутренней функции продолжать обращаться к внешним переменным даже после завершения внешней области видимости.
      - Вместо того чтобы уничтожаться в ходе сборки мусора, экземпляры внешних переменных будут оставаться в памяти.
      - И позднее, при вызове экземпляра внутренней функции, эти переменные будут доступны с сохранением своих текущих значений.

  - Прочее (старые версии, осымслять)
    - Функция, которая содержит ссылки на переменные из родительской области видимости.
    - Способность функции запоминать контекст (LexicalEnvironment), в которой она была создана.
    - Приём, позволяет вызывать n экземпляров функции, и в каждом запомнить своё значение внутренних переменных.
    -
    - Функция, которая запоминает свои внешние переменные и может получить к ним доступ.
    - Функция вместе со всеми внешними переменными, которые ей доступны.
    - Комбинация функции и лексического окружения, в котором она была объявлена.
    -
    - «Брать из замыкания» — из внутренней функции получаем/меняем переменные родительской функции.
    -
    - Это замыкание если:
      - родительская функция возвращает дочернюю функцию (через return). Именно функцию, а не результат её работы!
      - дочерняя использует переменные из родительской

  <br></p>
  </details>

[//]: # (Описание 1)
- <details><summary><b>Описание 1</b></summary><p>

  - Вложенная функция запомнила значение `Х` из области своего создания (родительской функции).
  - Её вызывают уже вне этой области, а она возвращает это Х.
  - Т.е. она "замыкает" внешние переменные в себе.
  
  <br></p>
  </details>

[//]: # (Описание 2)
- <details><summary><b>Описание 2</b></summary><p>

  - есть функция `fA`
  - в ней есть переменная `X` и другая функция `fB`
  - функция `fB` использует эту переменную `X`
  - функция `fA` возвращает в return функцию `fB`. Именно функцию, а не результат её работы. (`return fB;` а
  не `return fB();` )
  - каждый запуск `fA` создаёт новую функцию `fB` с замыканием, которая хранит своё значение `X`.<br>
  `var one=fA(1); var two=fA(5);`
  
  <br></p>
  </details>

[//]: # (Описание 3)
- <details><summary><b>Описание 3</b></summary><p>

  Когда вызываю функцию - в ней создаются переменные локальной области видимости (т.е. доступные только самой функции)
  .<br>
  Под эти переменные движок JS выделяет память.

  Когда обычная функция завершает свое выполнение - она освобождает память, которую ей выделели.<br>
  Если, конечно, на переменные не осталось ссылок.

  В случае с замыканием, ты возвращаешь дочернюю функцию обратно (делаешь return), т.е. ссылки на переменные остаются.<br>
  Движок не может освободить память => и переменные родителя остаются доступными дочерней функции (и более никому).<br>
  Это и называется "замыкание" - переменные замкнуты на саму функцию.<br>
  Пока возвращенная функция остается в доступе замыкание существует.

  <br></p>
  </details>

[//]: # (Пример 1)
- <details><summary><b>Пример 1</b></summary><p>
  
  ```js
  function fA() {
    var currentCount = 1;
  
    function fB() { // (**)
      return currentCount++;
    };
    return fB;
  }
  
  var counter1 = fA();     // (*)
  console.log(counter1()); // 1
  console.log(counter1()); // 2
  console.log(counter1()); // 3
  
  // создаём другой счётчик, он будет независим от первого
  var counter2 = fA();
  console.log(counter2()); // 1
  ```
  
  **Пояснение**
  
  1. В строке (*) запускается fA(). Создаётся LexicalEnvironment для переменных текущего вызова. В функции есть одна
   переменная var currentCount, которая станет свойством этого объекта. Она изначально инициализуется в undefined,
   затем, в процессе выполнения, получит значение 1.
  2. В процессе выполнения fA() создаёт функцию fB в строке (**). При создании эта функция получает внутреннее свойство
   Scope со ссылкой на текущий LexicalEnvironment.
  3. Далее вызов fA() завершается и функция (**) возвращается и сохраняется во внешней переменной counter (*). Итоговым
   значением, записанным в переменную counter, является функция ` function() { return currentCount++; };` , а её Scope=
   currentCount: 1
  4. Возвращённая из fA() функция counter помнит (через Scope) о том, в каком окружении была создана. Это и используется
   для хранения текущего значения счётчика.
  5. Когда-нибудь функция counter будет вызвана. Эта функция состоит из одной строки: `return currentCount++`. Своих
   переменных и параметров в ней нет, поэтому её Lexical Environment пуст.
  6. Но, у неё есть свойство Scope - оно указывает на внешнее окружение. Чтобы увеличить и вернуть currentCount,
   интерпретатор ищет в текущем объекте переменных Lexical Environment, не находит, затем идёт во внешний объект, там
   находит, изменяет и возвращает новое значение. Как изменяет? Переменную во внешней области видимости можно не только
   читать, но и изменять.
  7. В примере было создано несколько счётчиков. Все они взаимно независимы, потому что при каждом запуске fA() создаётся
   свой объект переменных LexicalEnvironment, со своим свойством currentCount, на который новый счётчик получит ссылку
   Scope.
  
  <br></p>
  </details>
  
[//]: # (Пример 2 - стрелочная функция)
- <details><summary><b>Пример 2 - стрелочная функция</b></summary><p>
  
  ```js
  const add = x => y => {
    const z = x + y;
    console.log(x + '+' + y + '=' + z);
    return z;
  };
  
  const res = add(3)(6); // вернёт 9 и выведет в консоль 3+6=9
  console.log(res);
  ```
  
  **Пояснение**
  
  - В переменную add помещается функция от аргумента x,
  - результатом которой будет являться другая функция, а именно функция от аргумента y,
  - результат которой вычисляется приведённым в фигурных скобках блоком кода.
  - Этот блок кода опирается на аргумент y своей функции и на замыкание, создаваемое для аргумента x внешней функции.
  
  **При вызове add(3)(6):**
  
  - функция, хранящаяся в переменной add, вызывается с аргументом 3
  - и возвращает функцию, завязанную на значение 3 в замыкании x.
  - в рамках такого обращения, эта функция выполняется с аргументом y = 6 и возвращает 9.
  
  <br></p>
  </details>


[//]: # (Пример 3 - анонимная самовыполняющуяся функция)
- <details><summary><b>Пример 3 - анонимная самовыполняющуяся функция (IIFE)</b></summary><p>
  
  **`IIFE` (immediately-invoked function expressions)**
  
  - В прошлом в JS не было лексического окружения на уровне блоков кода.
  - Придумали функции, запускаемые сразу после объявления.
  - Создаётся и немедленно вызывается Function Expression. Код выполняется сразу, и у него есть свои локальные   переменные.
  - Function Expression обёрнуто в скобки (function {...}), потому что, когда JavaScript встречает "function" в основном   потоке кода, он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, так что   такой код вызовет ошибку. Даже если мы скажем: «хорошо, давайте добавим имя», – это не сработает, потому что   JavaScript не позволяет вызывать Function Declaration немедленно. Так что скобки вокруг функции – это трюк, который   позволяет показать JavaScript, что функция была создана в контексте другого выражения, и, таким образом, это   функциональное выражение: ей не нужно имя и её можно вызвать немедленно.
  - Кроме скобок, существуют и другие пути показать JavaScript, что мы имеем в виду Function Expression - стваить вначале `+` или `!`, например
  
  - ```js
    var fn = (
      function () {
        var numberOfCalls = 0;
        return function () {
          return ++numberOfCalls;
        }
      }
    )();
    ```
  
  <br></p>
  </details>

[//]: # (Механизм - кратко)
- <details><summary><b>Механизм - кратко</b></summary><p>
  
  - Все функции, блоки кода и скрипты имеют скрытый объект `LexicalEnvironmen`.
  - Все переменные и параметры функций = свойства объекта `LexicalEnvironmen`.
  - Каждый запуск функции создает новый такой объект.
  - При создании функция также получает скрытое св-во `[[Environment]]`
  - это ссылка на родительский `LexicalEnvironment`, в котором функция была создана.
  - При вызове функция будет искать переменные:
  - внутри своего `LexicalEnvironmen`,
  - затем во внешних `LexicalEnvironment` (переходя по ним через св-ва `[[Environment]]`).
  
  <br></p>
  </details>

[//]: # (Механизм - Lexical Environment и [[Environment]])
- <details><summary><b>Механизм - Lexical Environment и [[Environment]]</b></summary><p>

  - При запуске функции, в ней создаётся объект `LexicalEnvironmen`.
  - Его свойства - все переменные внутри функции, аргументы функции и вложенные функции.
  - В конце выполнения функции объект `LexicalEnvironmen` обычно удаляется и память очищается. Если нет замыкания.
  - Если переменная не найдена в `LexicalEnvironmen` функции – она будет искаться снаружи, через ссылку в
  свойстве `[[Environment]]`<br>
  <br>
  
  **Уточнения**
  
  - Скрытый объект `LexicalEnvironmen` есть у функции, блока кода и скрипта.
  - Состоит из двух частей:
  - Объект `Environment Record`, в нём как свойства хранятся:
    - все локальные переменные
    - другие функции, объявленные внутри текущей
    - значение `this`
    - псевдомассив `arguments`
    - параметры функций
  - Ссылка на внешнее лексическое окружение
    - На код снаружи от текущих фигурных скобок.
    - У глобального объекта эта ссылка == null.
    - **Кажется это и есть скрытое свойство `[[Environment]]`**.
    - Функция получает его при «рождении».
  - "Переменная" – это просто свойство специального внутреннего объекта `Environment Record`.
  - «Получить / изменить переменную» = «получить / изменить свойство этого объекта».
  - `strict mode`
  - Если переменная не была найдена ни в одном внешнем окружении, это будет ошибкой в `strict mode`.
  - Без `strict mode`, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.
  - `Function Declaration`
  - `function say(name){/*...*/}`
  - полностью инициализируются не тогда, когда выполнение доходит до них (как let), а раньше — когда создаётся лексическое окружение.
  - поэтому мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.
  - В процессе выполнения функция будет оперировать данными \ информацией. Функция - это одно, а данные, с
  которыми функция работает - это совершенно другое. Данные, с которыми работает функция в процессе своего выполнения,
  лежат в отдельном месте оперативной памяти. Это место даже имеет специальное название - лексическое
  окружение `Lexical environment`.
  
  <br></p>
  </details>

[//]: # (Механизм - Global object)
- <details><summary><b>Механизм - Global object</b></summary><p>

  Все функции, блоки кода и скрипты имеют скрытый объект `LexicalEnvironmen` — на верхнем уровне это «global object».<br>
  `Global object` = частный случай объекта `LexicalEnvironment`<br>
  Глобальные переменные и функции - те, которые не находятся внутри какой-то функции. На "верхнем уровне".
  
  В JS все глобальные переменные и функции = свойства объекта `global object`. <br>
  В браузере этот объект доступен под именем window. <br>
  Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.
  
  У глобального объекта ссылка на внешнее лекс. окружение (св-во `[[Environment]]`) == null.
  
  <br></p>
  </details>

[//]: # (Механизм - Scope)
- <details><summary><b>Механизм - Scope (разбираться)</b></summary><p>

  Разбираться: [pikabu - Замыкание в JS по-человечески](https://pikabu.ru/story/zamyikanie_v_js_pochelovecheski_9330642)
  
  Есть понятие `scope` = область видимости функции.<br>
  Есть понятие `Scope` = имя ссылки, которая лежит в `[[Enviroment]]`<br>
  
  `scope` — набор информации, с которой работает выполняемый код в текущий момент.<br>
  `scope` = философское понятие, `LexicalEnvironmen` — его техническая реализация. Как-то так.<br>
  Внутри `[[Enviroment]]` хранятся данные `Scope`, которые указывают на `LexicalEnvironmen`. Или что-то в этом духе.<br>
  
  При анализе кода функции движок JS создаёт `функциональный объект` — там хранит данные о функции.<br>
  Мы хотим, чтобы переменная X была в `scope` (области видимости функции). <br>
  Но этой переменной нет в `LexicalEnvironmen` функции.
  Поэтому смотрим в свойство `[[Environment]]` — там лежит ссылка на родительский `LexicalEnvironmen`.<br>
  Будем искать в нём. И так дальше, пока не найдём или не дойдём до корня (глобальный объект).
  Набор связанных между собой (специальной ссылкой) `LexicalEnvironmen`, расширяющих область видимости конкретной функции
  - `scope chain`.<br>
  После того, как ссылка `Scope` лексического окружения функции была скопирована с ссылки `[[Environment]]`
  функционального объекта функции — область видимости функции была расширена областью видимости родителя,
  образовав `scope chain`.
  
  ***
  
  При создании функции в ней создаётся св-во `Scope` (область видимости*).<br>
  В нём хранится ссылка на внешний объект `LexicalEnvironment`, в котором создана функция — глобальный объект (window) или
  другая функция.<br>
  Св-во `Scope` никогда не меняется, всюду следует за функцией, "привязывает" её к месту своего рождения.
  
  Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания
  функции. <br>
  Функция по ссылке `Scope` обращается во внешний `LexicalEnvironmen` и берёт значение, которое там есть на момент
  обращения.
  
  Разница между созданием замыкания и созданием scope-объекта:
  
  - замыкание (функция + ссылка на текущую цепочку scope-объектов) создается при определении функции,
  - новый scope-объект создается при каждом вызове функции. Используется для модификации цепочки scope-объектов замыкания
  
  <br></p>
  </details>

[//]: # (Замыкания и переменные)
- <details><summary><b>Замыкания и переменные</b></summary><p>

  - Значение читается из переменной, находящейся в замыкании. Но замыкание — живая ссылка, а не «моментальный снимок» значения на некоторый момент.
  - Ссылка сохраняет доступ к полноценной переменной — можно не только читать значения. В замыкании также можно **обновлять переменную** (присваивать новое значение).
  - Создал замыкание по переменной в функции — можно пользоваться этой переменной (для чтения / записи) в любой точке, где мы хотим вызвать эту функцию (пока ссылка на функцию существует в программе).
  - Пример:
      - ```js
          function makeCounter() {
            var count = 0;
            return getCurrent(){
              count = count + 1;
              return count;
            };
          }
      
          var hits = makeCounter();
          /// позднее
          hits(); // 1
          // позднее
          hits(); // 2
          hits(); // 3
        ```
  - 
  - Может возникнуть ошибочное впечатление, что замыкания ориентированы на значения, а не на переменные.
  - Не пытайся использовать замыкание для фиксации значения на некоторый момент — в замыкание функции включается переменная, а не ее значение. 
  - При вызове функции будет использовано текущее значение переменной, а не  её значение на момент создания замыкания.
  - Пример этой ошибки — определение функций в цикле:
    - ```js
      var keeps = [];
      for (var i = 0; i < 3; i++) {
        keeps[i] = function keepI(){
          return i; // замыкание по `i`
        };
      }
      keeps[0](); // 3 -- ПОЧЕМУ!?
      keeps[1](); // 3
      keeps[2](); // 3 
      ```
    - Каждая сохраненная функция возвращает 3, потому что `var` поднимается из цикла — к концу цикла единственной переменной i в программе было присвоено значение 3. Каждая из трех функций в массиве keeps имеет индивидуальные замыкания, но все они замыкаются по одной общей переменной i.
  
  <br></p>
  </details>

[//]: # (Замыкания и функции)
- <details><summary><b>Замыкания и функции</b></summary><p>

  - Замыкания присущи только функциям!
    - Замыкание является аспектом поведения функций и только функций.
    - Если вы работаете не с функцией, то замыкание не действует.
    - Объект не может иметь замыкания, класс не может иметь замыкания (хотя его отдельные функции/методы — могут).
  - 
  - Каждая функция создаёт свою область видимости, в том числе и стрелочная.
  - Важно помнить — даже крошечные стрелочные функции могут участвовать в системе замыканий.
  - Чтобы замыкание проявилось, функция должна быть вызвана, причем вызвана НЕ в той ветви цепочки областей видимости, в которой она была определена.
  -
  - Предполагается, что функции являются «полноправными значениями» (как в JS), которые могут передаваться в программах, как и любые другие значения. Замыкание представляет собой ссылочную связь, которая соединяет эту функцию с областями видимости/переменными за ее пределами независимо от того, где находится эта функция.
  - 
  - Хотя окружающая область видимости замыкания обычно происходит от функции, в принципе это не обязательно; необходимым условием является лишь наличие внутренней функции во внешней области видимости.

  <br></p>
  </details>

[//]: # (Замыкание и экземпляры функции)
- <details><summary><b>Замыкание и экземпляры функции</b></summary><p>

  - Замыкание связывается с экземпляром функции, а не с её «лексическим определением».
  - Т.е. связывание происходит не с кодом функции (который написан один раз)
  - А с каждым выполнении этой функции. Вызвали её 10 раз — получили 10 замыканий. И у каждого замыкания свой экземпляр области видимости.

  <br></p>
  </details>

[//]: # (Зачем используются)
- <details><summary><b>Зачем используются</b></summary><p>

  - `State для функции` — создать функцию у которой есть своё изменяемое состояние.
    - Т.е. привязать к функции данные, сохраняющиеся между ее вызовами.
    - автономное атомарное хранилище данных + доступ к этим данным.
  - `Передача параметров в функцию`, которую вызывает другая функция
    - т.е. создание функций, в свою очередь тоже создающих функции.
    - Через замыкание возвращаемая внутренняя функция «запоминает» параметры, переданные внешней функции.
  - `Изоляция данных` — ограничение доступа к данным, ограничение их области видимости.
  - Эмуляция `private методов` функций.
    - N языки (Java...) позволяют объявлять private методы — могут быть вызваны только методами того же класса, в котором
      объявлены. Средство организации пространства имен — чтоб не засорять публичный интерфейс кода внутренними методами
      классов. JS так не умел, это эмулировали замыканиями.
  - Обработка `callback`
    - Функция обратного вызова. Выполняется после того, как другая функция завершила выполнение.
    - Например: кликнул по кнопке, вызвалась функция, что-то сделала
    - Могу через замыкание создать функцию-фабрику, она принимает размер шрифта X и меняет его на всей странице.
    - Создаю N экземпляров из функции-фабрики, передавая туда разные Х. Каждый экземпляр вешаю как callback на кнопку (
      onClick)
    - Кликая по разным кнопкам - меняю размер шрифта на сайте
    - ```js
      function makeSizer(size) {
        return function() {
          document.body.style.fontSize = size + 'px';
        };
      };
      
      <input onclick="makeSizer(12)" type="button" value="12pt">
      <input onclick="makeSizer(14)" type="button" value="14pt">
      ```
    - ИЛИ:
    - внутреннюю функцию не возвращаем, а вешаем на какое-либо событие — поскольку событие возникает уже после того, как
      исполнилась функция, замыкание опять же помогает не потерять переданные при создании обработчика данные.
  - Можно использовать везде, где используют `объект с одним методом`
    - Позволяют связать данные (лексическое окружение) с функцией, которая их использует. Как в ООП — объекты связывают
      данные (св-ва объекта) с методами.
  - 
  - [Habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)

  <br></p>
  </details>

[//]: # (Основные преимущества замыканий)
- <details><summary><b>Основные преимущества замыканий</b></summary><p>

  - Повышение эффективности
    - экземпляр функции может запомнить ранее определенную информацию, вместо того чтобы каждый раз вычислять ее заново.
  - Улучшение читаемости кода.
    - Замыкания ограничивают раскрытие за счет инкапсуляции переменной внутри экземпляров функции, при этом сохраняя на будущее возможность доступа к информации в этих переменных. С полученными, более специализированными, экземплярами функций проще взаимодействовать — хранимую информацию не нужно передавать при каждом вызове.
    - Т.е. можно создавать «частично применённые» и «каррированные» функции. В этих приемах изменяется форма функций, получающих несколько входных значений, чтобы некоторые входные данные предоставлялись заранее, а другие — позднее. Исходные входные данные запоминаются через замыкание.
    - Создавая экземпляр функции, который инкапсулирует некоторую информацию (посредством замыкания), функция с хранимой информацией может использоваться позднее напрямую без повторной передачи этих входных данных. Это способствует упрощению кода, а также предоставляет возможность назначения частично применяемым функциям более содержательных семантических имен.

  <br></p>
  </details>

[//]: # (Альтернатива замыканиям)
- <details><summary><b>Альтернатива замыканиям</b></summary><p>

  Вместо замыканий можно использовать функцию как объект.<br>
  Создать в объекте функции свойство и привязать к нему значение. Это значение будет сохраняться между вызовами функции,
  также как в замыкании.<br>
  Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны.
  
  Пример:
  ```js
  function makeCounter() {
  function counter() {
    return counter.currentCount++;
  };
  counter.currentCount = 1;

  return counter;
  }
  
  var counter = makeCounter();
  alert(counter()); // 1
  alert(counter()); // 2
  ```
  
  Принципиальная разница:
  - во внутренней механике
  - свойство функции общедоступно, в отличии от переменной из замыкания. К свойству имеет доступ любой, у кого есть объект
  функции. Например, его можно в любой моменты вызвать и прочитать, или перезаписать
  
  Подробнее — [learn.javascript.ru - Объект функции, NFE](https://learn.javascript.ru/function-object#polzovatelskie-svoystva)

  <br></p>
  </details>

[//]: # (Производительность)
- <details><summary><b>Производительность</b></summary><p>

  - Не нужно без необходимости создавать функции внутри функций в тех случаях, когда замыкания не нужны.<br>
  - Использование этой техники снижает производительность и в скорости, и в потреблении памяти.
  
  - Замыкания и утечки памяти
    - Замыкания неразрывно связаны с экземпляром функции => ее замыкание по переменной продолжается, пока существует ссылка на эту функцию.
    - Замыкание может мешать освобождению переменной, работа с которой завершена  — приводит к утечке памяти.
    - Поэтому важно освобождать ссылки на функции (а следовательно, и их замыкания), когда они перестают быть нужны.
    - Важно знать, где в наших программах появляются замыкания и какие переменные в них включаются. Следует тщательно управлять этими замыканиями, чтобы в памяти удерживался минимально необходимый объем памяти, а память не расходовалась понапрасну.
    -
  
  <br></p>
  </details>

[//]: # (Разное)
- <details><summary><b>Разное</b></summary><p>

  - Все функции в JS = замыкания.
    - Когда создается функция — всегда создается замыкание.
    - Чаще оно пустое - обычно функции ничего не используют из внешнего LexicalEnvironmen.
  - В функциональном программировании замыкания не приветствуются. Но знать и уметь надо, а в JS - обязательно.
  - Замыкания внутри цикла + `var`
    - Пока в ES6 не ввели ключевое слово `let`, часто возникала проблема при создании замыканий внутри цикла.
    - Будьте внимательны с использованием var/let в циклах.
    - Либо используем let (` for (let i = 0; i < someVariable; i++){...}`),
    - Либо реализуем замыкание в отдельной функции снаружи цикла, а в цикле вызываем эту функцию при каждой итерации.
    - Или сделать ещё один уровень вложенного замыкания.
      Подробнее: [MDN - Замыкания](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B9_%D0%B2_%D1%86%D0%B8%D0%BA%D0%BB%D0%B5_%D0%BE%D1%87%D0%B5%D0%BD%D1%8C_%D1%87%D0%B0%D1%81%D1%82%D0%B0%D1%8F_%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0)
      , [Habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)
  - «Замкнутые» данных сохраняются в не в «стеке» а в «куче»
    - Это структура в памяти JS-движка.
    - Стек — стопка тарелок. Положил сверху, взял сверху. LIFO (Last In, First Out)
    - Куча — просто склад переменных. Обратился по имени (ссылке) - получил данные.
    - Позволяет сохранять данные после вызова функции. Даже после того, как контекст выполнения удаляется из стека выполнения вызова.
  - Замыкание является естественным результатом лексической видимости в языках, в которых функции являются полноправными значениями, как в JS. Когда функция создает ссылки на переменные из внешней области видимости, а потом эта функция передается как значение и выполняется в других областях видимости, она сохраняет доступ к переменным исходной области видимости; в этом состоит суть замыкания.
  - Замыкание — одна из самых важных характеристик языка, изобретенных в программировании. Замыкания лежат в основе многих фундаментальных парадигм программирования, включая функциональное программирование (FP), модули и даже в какой- то степени объектно-ориентированное проектирование.
  - Изначально замыкание было математической концепцией из области лямбда-исчисления.

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Замыкания](https://learn.javascript.ru/closures)
  - [MDN - Замыкания](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)
  - [Habr - Замыкания в JavaScript](https://habr.com/ru/post/38642/)
  - [htmlacademy - Замыкания в JavaScript](https://htmlacademy.ru/blog/useful/javascript/lets-learn-javascript-closures)
  - [Wikipedia](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%  BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
  - [pikabu - Замыкание в JS по-человечески](https://pikabu.ru/story/zamyikanie_v_js_pochelovecheski_9330642)
  - [Hexlet - Возврат функций из функций](https://ru.hexlet.io/courses/js-functions/lessons/return-function/theory_unit)
  - [code.mu - Продвинутая работа с функциями](http://code.mu/books/javascript/advanced/prodvinutaya-rabota-s-funkciyami-javascript.html)
  - [proglib - Пора понять замыкания в JavaScript! Часть 1. Готовим фундамент](https://proglib.io/p/js-closures-1/)
  - [proglib - Пора понять замыкания в JavaScript! Часть 2. Переходим к делу](https://proglib.io/p/js-closures-2/)
  - [learn.javascript.ru - Объект функции, NFE](https://learn.javascript.ru/function-object#polzovatelskie-svoystva)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Значения, данные, литералы, переменные)
<details id="types"><summary><b>Значения, данные, литералы, переменные</b></summary><p>

- `Значения` — самая фундаментальная единица информации в программе
- Значения содержат `данные`.
  - используются программой для хранения состояния
  - в JS значения существуют в двух формах: `примитивы` и `объекты`
- Значения встраиваются в программы в виде `литералов`
  - `литерал` = какое-то безымянное значение. Любое значение указанное явным образом в коде. 
  - Например: строка, число, булевой значение, содержимое объекта или массива, регулярное выражение...
  - "My name is Kyle." является примитивным строковым литералом
- Переменная — идентификатор, которому присвоено некое значение (например литерал или другая переменная)
  - переменная не содержит информацию о типе значений, которые в ней хранятся. Можно записать в переменную строку, а потом понять на число — это не вызовет ошибки. Поэтому JS иногда называют «нетипизированным» языком.

<br></p>
</details>

[//]: # (Переменные — var, let и const)
<details id="variables"><summary><b>Переменные — var, let и const</b></summary><p>

Не надо объявлять переменные без указания директивы (например var или let).

```js
//Т.е. так писать не стоит
a = 1

//Надо так
var a = 1
let a = 1
const a = 1
```

**Var**

- Способ объявления переменной
- Область видимости переменной `var` — функция.
  - При использовании в цикле у нас будет одна `var` на все итерации цикла. Не создаётся заново в каждой итерации.
- `var` допускает повторное объявление (перемнной просто присвоится новове значение). Для `let` в таком случае будет выдана ошибка SyntaxError.
- Переменные `var` существуют и доступны до объявления. Они равны `undefined`.
  - Называется [«Поднятие (всплытие) переменных» (MDN)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var#%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
  - Объявление переменных (как и любые другие объявления) обрабатываются до выполнения кода => в каком бы месте кода мы не объявили переменную, это равнозначно тому, что переменную объявили в самом начале кода.
    - Формально работает для всех переменных, но реально обращаться к `let` и `const` можно только после присвоения, до тех по выдаёт ошибку [ReferenceError](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError). Этот эффект называется [«Временные мёртвые зоны» (MDN)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let#%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BC%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D0%B5_%D0%B7%D0%BE%D0%BD%D1%8B_%D0%B8_%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8_%D0%BF%D1%80%D0%B8_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8_let) — если в блоке кода я пытаюсь использовать переменную до того, как она объявлена. Формально она существует (см выше «Поднятие переменных»), но обращаться к ней нельзя (в отличии от `var`).
    - См. также [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#varconstlet)
- Часто считается устаревшим способом объявления переменной.
- Используем `var` если
  - будем переопределять значение переменной.
  - хотим чтоб переменная была видна на уровне всей функции
  - хотим чтоб переменная существовала до объявления (и была равна `undefined`).
  - 
  - Всегда используйте `var` в области видимости верхнего уровня любой функции (независимо от того, находится ли это объявление в начале, середине или конце функции).
  - Используйте var в глобальной области видимости (но старайтесь минимально использовать глобальную область видимости)
*
  - *Let**

- Область видимости переменной `let` – блок {...}, в котором объявлена.
- Это, в частности, влияет на объявления внутри if, while или for.
- let видна только после объявления. До тех пор их просто нет.
- При использовании в цикле, для каждой итерации создаётся своя переменная.
- Введена в язык в ES6 (ES-2015)
- Используйте `let` в блочной области видимости.

**Const**

- Способ объявления переменной. 
- Запрещает повторное присваивание этой переменной И всё.
  - Например я могу создать массив `const = someArr`, а потом сделать `someArr.push('sometning')`. Т.е. у меня const, но её значение изменилось.
  - Использовать просто как синтаксическую подсказку — эту перемнную не надо менять (и она не меняется сама). Напримре для неизменного числа или строки. Gеременная никогда не находится слева от `=` — ей нигде не присваивается значение повторно.
  - `const` (и `let`) предназначены для использования в блоках, а блоки должны быть короткими => область, в которой могут применяться `const` весьма мала.
- Создаёт константу — переменную, которую нельзя менять. При попытке изменения выдаст ошибку.
  - задаёт значение в момент объявления и не может изменить.
  - переменные const, не являются немодифицируемыми — просто им невозможно присвоить новое значение.
  - указывает компилятору следить чтобы переменной больше не присваивалось других значений.
- В остальном - аналогичная let.
- Функции обычно лучше создавать через const.
- Хороший вариант объявления чего-то, что мы не собираемся менять.
- Не стоит использовать const для хранения объектов
  - Объектные значения могут изменяться, даже без повторного присваивания. Это приводит к путанице.
  - Иначе говоря: если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё.
  - Например: `names[2] = "Tom"`.
- В случае использования const современные JavaScript-движки могут выполнить ряд дополнительных оптимизаций.
- Введена в язык в ES6 (ES-2015)
- 
  <br>
  <br>

**Константы и `const`**

- Кратко
  - const HEADER_COLOR — значение жёстко задано в момент написания программы и не будет меняться, пока я не перепишу этот код руками. 
    - Например цвет заголовков.
  - const header_color — значение не будет меняться после присвоения. Но при разных запусках функции может присваиваться разное значение. 
    - Например, цвет заголовков может меняться в зависимости от того какая тема оформления настроена у пользователя в cookies. Или от времени суток.  Но, после того как функция запущена и некое значение присвоено — оно не меняется, до следующего запуска функции.



- `const` Запрещает повторное присваивание этой переменной И всё.
  - Например я могу создать массив `const = someArr`, а потом сделать `someArr.push('sometning')`. Т.е. у меня const, но её значение изменилось.
  - Использовать просто как синтаксическую подсказку — эту перемнную не надо менять (и она не меняется сама). Напримре для неизменного числа или строки. Gеременная никогда не находится слева от `=` — ей нигде не присваивается значение повторно.
  - `const` (и `let`) предназначены для использования в блоках, а блоки должны быть короткими => область, в которой могут применяться `const` весьма мала.


Константы, которые жёстко заданы всегда, во время всей программы, обычно пишутся в верхнем регистре. <br>
Например: const ORANGE = "#ffa500".

Большинство переменных – константы в другом смысле: они не меняются после присвоения. <br>
Но при разных запусках функции это значение может быть разным. <br>
Для таких переменных можно использовать const и обычные строчные буквы в имени.

Использование `const` вместо `var` / `let` не говорит о том, что значение является константой или что оно иммутабельно (
неизменяемо). Ключевое слово `const` просто указывает компилятору следить за тем, что переменной больше не будет
присвоено никаких других значений.

**Правила именования переменных (договоренности)**

- `Name`  = функция-конструктор (http://learn.javascript.ru/constructor-new) / или класс
- `NAME`  = константа (http://learn.javascript.ru/variables , http://learn.javascript.ru/let-const)
- `_name` = приватные методы и свойства (http://theory.phphtml.net/books/javascript/oop/)


**Затенение свойств глобального объекта глобальными переменными**

  - при объявлении в глобальной области видимости переменной через `var` (а также при объявлении функции), в глобальном объекте (например `windows`) появляется одноименное свойство с соответствующим значением.
  - через это свойство можно не только читать, но и менять значение переменной (связь двусторонняя: поменял переменную - поменялось свойство, поменялось свойство - изменилась переменная). Можно даже таким образом создать переменную (просто создав свойство windows.someName)
  - не работает для `let` и `const`
  - не работает в модулях
  - фокус
    - Объявил `windows.name = 1`. 
    - Объявил на верхнем уровне `let name = 2`.
    - `console.log(windows.name) //1`
    - `console.log(name) //2`
    - 
    - Вывод: поэтому рекомендуют глобальные переменные объявлять через `var`, а `let` и `const` использовать в блоках и функциях
    - Все эти ловушки с глобальными объявлениями можно просто обойти: всегда используйте `var` для глобальных имен. `let` и `const` следует зарезервировать для блоковых областей видимости

**Ссылки**

- [learn.javascript.ru - Переменные](https://learn.javascript.ru/variables)
- [learn.javascript.ru - Устаревшее ключевое слово "var"](https://learn.javascript.ru/var)
- [learn.javascript.ru - Переменные: let и const](https://learn.javascript.ru/let-const)
- [Habr - Область видимости переменной в Javascript (ES4-5)](https://habr.com/ru/post/78991/)

<br><p>
</details>

[//]: # (Лексическое всплытие и погружение)
<details id="eventHoisting"><summary><b>Лексическое всплытие и погружение</b></summary><p>

  - Организация процесса обработки события (например клика по div), при котором вначале срабатывают обработчики на целевом объекте (сам div), потом на его родителе, потом выше...
  - Отсюда различия между `event.target` (куда кликнули) и `this` (где сейчас включился обработчик).
  - Обратный процесс называетя «Погружение» — вообще-то вначале идёт «погружение» и только потом «всплытие».
  - Всплытие можно искуственно прервать (не желательно без чёткой необходимости) - `event.stopPropagation()` и `event.stopImmediatePropagation()`.
  - Бывают особые случаи — например событие `focus` не всплывает и др.
  
  - **Ссылки:**
    - [learn.javascript.ru - Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing)
    - [learn.javascript.ru - Всплытие и перехват (old)](https://learn.javascript.ru/event-bubbling)
  
<br></p>
</details>

[//]: # (Ключевые и зарезервированные слова)
<details id="keyword"><summary><b>Ключевые и зарезервированные слова</b></summary><p>

  - В JS есть список слов, которые нельзя использовать в качестве: переменных, имен функций, меток или параметров.
  - Правила относительно зарезервированных слов довольно сложны. Есть исключения, когда некоторые из этих слов можно применять. Но даже в этих случаях так делать не нужно.

  - В частности это
    - «ключевые слова»
    - «слова, зарезервированные на будущее»
    - литерал `null`
    - логические литералы `true`/`false`.

  - Примеры
    - `arguments`, `await`, `break`, `case`, `catch`, `class`, `const`, `continue`, `debugger`, `default`, `delete`, `do`, `else`, `enum`, `eval`, `export`, `extends`, `false`, `finally`, `for`, `function`, `if`, `implements`, `import`, `in`, `Infinity`, `instanceof`, `interface`, `let`, `NaN`, `new`, `null`, `package`, `private`, `protected`, `public`, `return`, `static`, `super`, `switch`, `this`, `throw`, `true`, `try`, `typeof`, `undefined`, `var`, `void`, `while`, `with`, `yield`

    - [Полный список на MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0)

<br></p>
</details>


---


[//]: # (Методы примитивов)
<details id="primitiveMethods"><summary><b>Методы примитивов</b></summary><p>


[//]: # (Заметки)
- <details><summary><b>Заметки</b></summary><p>

  - Конструкторы String/Number/Boolean предназначены только для внутреннего пользования!<br>
  - Категорически не рекомендуется самому вручную использовать конструкторы вроде `new Number(100)`.
  - 
  - Примитивы `null` и `undefined` не имеют «объектов-обёрток», не имеют методов.

  <br></p>
  </details>

[//]: # (Объектные обертки примитивов)
- <details><summary><b>Объектные обертки примитивов</b></summary><p>

  - JS предоставляет объектные обертки для примитивных значений (`String`, `Number`, `Boolean` и т. д.). 
  - Объектные обертки предоставляют значениям доступ к поведению, соответствующему каждому подтипу объекта ( `String#trim()` и `Array#concat()` ).
  - Если у вас имеется простое скалярное примитивное значение (например, "аЬс") и вы обращаетесь к его свойству `length` или вызываете некий метод `String. prototype`, JS автоматически «упаковывает» значение (заключает его в соответствующую объектную обертку), для того чтобы реализовать обращение к свойству/ методу.
  - 
  - Когда создаётся объект-обёртка (на примере Number):
    - если применить к числу эти методы — `(5).toFixed(3)`
    - если вызвать на числе конструктор new Number() — `let num = new Number(100) // typeof num === object`

  <br></p>
  </details>

[//]: # (Методы String)
- <details><summary><b>Методы String</b></summary><p>

  - Строки, в отличии от массивов, неизменяемы. Поэтому ни один строковый метод не может изменить свое содержимое «на месте», он должен создавать и   возвращать новые строки.
  - Многие методы массивов недоступны для строк. Но можно «позаимствовать» неизменяющие методы массивов для строки. Пример: `var с =   Array.prototype.join.call( myString, "-" );`
  - 
  - `repeat()` — создать строку путем многократного повторения другой строки
  - `indexOf()` — поиск подстроки в строке. Вернёт индекс первого вхождения подстроки
  - `lastIndexOf()` — поиск подстроки в строке. Вернёт индекс последнего вхождения подстроки
  - `includes()` — содержит ли строка опр. подстроку.
  - `search()`— содержит ли строка указанное значение или регулярное выражение. Возвращает индекс начала совпадения.
  - `substr()` — извлекает часть строки указанной длины. Устаревший метод
  - `substring()` — извлекает символы из строки между двумя указанными индексами.
  - `slice()` — извлекает часть строки и возвращает новую строку. Почти идентичен `substring()`, но немного «глупее»
  - `toLowerCase()` — перевод символов в нижний регистр
  - `toUpperCase()` — перевод символов в верхний регистр
  - `charAt()` — получить определенный символ в строке по индексу
  - `charCodeAt()` — получить определенный символ в строке по индексу
  - `trim()` — удаление начальных и концевых пробелов в стоке
  - `trimStart()` — удаляет пробел с начала строки
  - `trimEnd()` — удаляет пробел с конца строки
  - `trimLeft()` — удаляет пробел с левой части строки
  - `trimRight()` — удаляет пробел с правой части строки
  - `concat()` — объединяет две и более строк. Возвращает одну объединённую.
  - `replace()` — заменяет первое вхождение одной подстроки на другую (заменяет только первое вхождение подстроки)
  - `replaceAll()` — позволяет заменить все вхождения подстроки:
  - `split()` — разбивает строку на массив подстрок по опр. разделителю
  - `startsWith()` — возвращает true, если строка начинается с определенной подстроки.
  - `endsWith()` — возвращает true, если строка оканчивается на определенную подстроку.
  - `padStart()` — растянуть строку на N символов и заполнить строку слева.
  - `padEnd()` — растянуть строку на N символов и заполнить строку справа.
  - `join()` — Склеить массив строк в одну. **Метод массива!**
  - 
  - `String.fromCharCode()` — Возвращает строку, созданную из указанной последовательности значений Юникода.
  - `String.fromCodePoint()` — Возвращает строку, созданную из указанной последовательности кодовых точек Юникода.
  - `String.raw()` — Возвращает строку, созданную из сырой шаблонной строки.
  - Унаследованные из Function: `apply`, `call`, `toSource`, `toString`.
  - 
  - **Свойства**
    - `length` указывает на длину строки
    - `arity`, `caller`, `constructor`, `name`
  - 
  - **Приёмы**
    - `'Hello'.split('')` — преобразовать строку в массив символов
    - `Array.from('Hello')` — преобразовать строку в массив символов
    - `[...'Hello']` — преобразовать строку в массив символов `let symbArray = [...'Привет']; // П,р,и,в,е,т`
  
  [//]: # (Стандратные методы с MDN)
  - <details><summary><b>Стандартные методы с MDN</b></summary><p>
  
    - [String.prototype[@@iterator]()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator)
    - [String.prototype.at()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/at)
    - [String.prototype.charAt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/charAt)
    - [String.prototype.charCodeAt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)
    - [String.prototype.codePointAt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
    - [String.prototype.concat()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/concat)
    - [String.prototype.endsWith()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)
    - [String.fromCharCode()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)
    - [String.fromCodePoint()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)
    - [String.prototype.includes()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/includes)
    - [String.prototype.indexOf()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)
    - [String.prototype.lastIndexOf()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)
    - [String.prototype.localeCompare()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)
    - [String.prototype.match()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/match)
    - [String.prototype.matchAll()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll)
    - [String.prototype.normalize()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    - [String.prototype.padEnd()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd)
    - [String.prototype.padStart()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)
    - [String.raw()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/raw)
    - [String.prototype.repeat()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/repeat)
    - [String.prototype.replace()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replace)
    - [String.prototype.replaceAll()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)
    - [String.prototype.search()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/search)
    - [String.prototype.slice()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/slice)
    - [String.prototype.split()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/split)
    - [String.prototype.startsWith()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)
    - [String.prototype.toLocaleLowerCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase  )
    - [String.prototype.toLocaleUpperCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase  )
    - [String.prototype.toLowerCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)
    - [String.prototype.toString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toString)
    - [String.prototype.toUpperCase()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)
    - [String.prototype.trim()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
    - [String.prototype.trimEnd()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd)
    - [String.prototype.trimStart()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart)
    - [String.prototype.valueOf()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/valueOf)
    -
    - [String.prototype.anchor()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/anchor) — Deprecated
    - [String.prototype.big()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/big) — Deprecated
    - [String.prototype.blink()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/blink) — Deprecated
    - [String.prototype.bold()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/bold) — Deprecated
    - [String.prototype.fixed()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/fixed) — Deprecated
    - [String.prototype.fontcolor()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/fontcolor) — Deprecated
    - [String.prototype.fontsize()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/fontsize) — Deprecated
    - [String.prototype.italics()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/italics) — Deprecated
    - [String.prototype.link()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/link) — Deprecated
    - [String.prototype.small()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/small) — Deprecated
    - [String.prototype.strike()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/strike) — Deprecated
    - [String.prototype.sub()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/sub) — Deprecated
    - [String.prototype.substr()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substr) — Deprecated
    - [String.prototype.substring()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substring)
    - [String.prototype.sup()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/sup) — Deprecated
    
    <br></p>
    </details>
  
  - **Ссылки**
    - [Шпаргалка - методы строк](https://tproger.ru/articles/metody-strok-v-javascript-shpargalka-dlja-nachinajushhih/)
    - [Mentanit - Строки, объект String и его методы](https://metanit.com/web/javascript/6.1.php)
    - [Дока - Обёртка String](https://doka.guide/js/string-wrapper/)
    - [MDN - String](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String#methods)

  <br></p>
  </details>

[//]: # (Методы Number)
- <details><summary><b>Методы Number</b></summary><p>

  - `Number.isNaN()` — проверить значение на NaN
  - `Number.isFinite()` — true это число, false если специальное значение или нечисловой тип
  - `toString()` — преобразует число в строку в указанной системе счисления.
  - `toFixed()` — преобразует число в строку с указанным количеством знаков после запятой. Округляет. Возвращает строку.
  - `toLocaleString()` — преобразует число в строку, учитывая локаль пользователя
  -
  - Если надо вызвать методы на целом числе `5`:
  - `(5).toFixed(3)`
  - `5..toFixed(3)`
  -
  - Обёртка хранит полезные константы:
  - `Number.MAX_SAFE_INTEGER` — максимально возможное целое значение числового типа, 253-1.
  - `Number.MIN_SAFE_INTEGER` — минимально возможное целое значение числового типа, -253-1.
  - `Number.MAX_VALUE` — максимально большое число, представимое с помощью числового типа.
    - Больше, чем Number.MAX_SAFE_INTEGER, из-за особенностей хранения чисел с плавающей точкой.
  - `Number.MIN_VALUE` — минимальное положительное число, представимое с помощью числового типа.
  -
  - [Дока - Обёртка Number](https://doka.guide/js/number-wrapper/#formatirovanie-chisla)
  - [MDN - Number](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number#methods)

  <br></p>
  </details>

[//]: # (Методы Boolean)
- <details><summary><b>Методы Boolean</b></summary><p>

  - `valueOf()` — возвращает примитивное значение (primitive) настоящего объекта Boolean.
  - ```js
    let a = new Boolean(true);
    console.log( a ); // [Boolean: true]
    console.log( typeof a ); // object
    
    let a2 = a.valueOf();
    console.log( a2 );  // true
    console.log( typeof a2 ); // boolean
    ```
  - `toString` — возвращает строку "true" или "false" в зависимости от значения объекта.
  - Унаследованные из Function: `apply`, `call`, `toSource`, `toString`.
  
  - [betacode.net - Руководство ECMAScript Boolean](https://betacode.net/12197/ecmascript-boolean)
  - [MDN - Boolean](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean#methods)
  
  <br></p>
  </details>
  
[//]: # (Методы BigInt)
- <details><summary><b>Методы BigInt</b></summary><p>
  
  - `asIntN()` — оборачивает BigInt в пределах от -2width-1 до 2width-1-1
  - `asUintN()` — оборачивает a BigInt в пределах от 0 до 2width-1
  - `toLocaleString()` — возвращает строку с языкозависимым представлением числа. Переопределяет метод
  Object.prototype.toLocaleString().
  - `toString()` — возвращает строку, представляющую указанный объект по указанному основанию системы счисления.
  Переопределяет метод Object.prototype.toString().
  - `valueOf()` — возвращает примитивное значение указанного объекта. Переопределяет метод Object.prototype.valueOf().
  
  - [MDN - BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D1%8D%  D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0)
  
  <br></p>
  </details>

[//]: # (Методы Symbol)
- <details><summary><b>Методы Symbol</b></summary><p>
  
  - `for(key)` — ищет существующие символы по заданному ключу и возвращает его (если нашёл). Иначе создаёт новый символ
  для данного ключа в глобальном реестре символов.
  - `keyFor(sym)` — получает по разделяемому символу его ключ из глобального реестра символов.
  - `toString()` — Возвращает описание символа в виде строки.
  - `valueOf()` — Возвращает примитивное значение символьного объекта.
  
  - **Свойства**
    - `asyncIterator` — возвращает асинхронный итератор по умолчанию.
    - `hasInstance` — определяет, распознает ли объект конструктора объект как свой инстанс.
    - `isConcatSpreadable` — указывает, должен ли быть объект сплющен до элементов массива.
    - `iterator` — возвращает итератор по умолчанию.
    - `match` — сравнивает со строкой.
    - `matchAll` — возвращает итератор, который выдает совпадения регулярного выражения со строкой.
    - `replace` — заменяет совпадающие подстроки строки.
    - `search` — возвращает индекс в строке, который соответствует регулярному выражению.
    - `split` — разделяет строку по индексам, которые соответствуют регулярному выражению.
    - `species` — создает производные объекты.
    - `toPrimitive` — преобразует объект в примитивное значение.
    - `toStringTag` — возвращает описание объекта по умолчанию.
    - `description` — возвращает описание объекта в виде строки.
  
  - [MDN - Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol#methods)
  - [Тип данных Symbol в JS](https://codechick.io/tutorials/javascript/js-symbol)
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Методы примитивов (общие вопросы)](https://learn.javascript.ru/primitives-methods)
  -
  - [MDN - String](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String#methods)
  - [Шпаргалка - методы строк](https://tproger.ru/articles/metody-strok-v-javascript-shpargalka-dlja-nachinajushhih/)
  - [Дока - Обёртка String](https://doka.guide/js/string-wrapper/)
  - [Metanit - Строки, объект String и его методы](https://metanit.com/web/javascript/6.1.php)
  -
  - [MDN - Boolean](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean#methods)
  - [betacode.net - Руководство ECMAScript Boolean](https://betacode.net/12197/ecmascript-boolean)
  -
  - [MDN - Number](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number#methods)
  - [Дока - Обёртка Number](https://doka.guide/js/number-wrapper/#formatirovanie-chisla)
  -
  - [MDN - BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0)
  -
  - [MDN - Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol#methods)
  - [Тип данных Symbol в JS](https://codechick.io/tutorials/javascript/js-symbol)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Массивы)
<details id="array"><summary><b>Массивы</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>
  
  - Структура для работы с **упорядоченными** наборами данных.
  - Особый тип объектов, с дополнительными свойствами и ограничениями.
  
  <br></p>
  </details>


[//]: # (Не использовать как объект)
- <details><summary><b>Не использовать как объект</b></summary><p>
  
  - Элементы в массиве должны идти подряд, иначе теряется большая часть преимуществ этой структуры.
  - Добавление нечислового свойства: `arr.test = 5`
  - Создание «дыр»: добавление `arr[0]`, затем `arr[1000]` (между ними ничего нет).
  - Заполнение массива в обратном порядке: `arr[1000]` , `arr[999]` и т.д.
  
  <br></p>
  </details>


[//]: # (Многомерные массивы)
- <details><summary><b>Многомерные массивы</b></summary><p>
  
  - Массивы, которые содержат массивы

  <br></p>
  </details>


[//]: # (Псевдомассивы)
- <details><summary><b>Псевдомассивы</b></summary><p>
  
  - Объекты, у которых есть индексы и свойство length, т. е., они выглядят как массивы.
  
  <br></p>
  </details>


[//]: # (Объявление массива)
- <details><summary><b>Объявление массива</b></summary><p>
  
  - `let arr = [5, 27, "a"]`
  - `let arr = new Array(5, 27, "a")` - если вызвать с одним аргументом-числом - создаст массив без элементов, но заданной длины (length)
  
  <br></p>
  </details>


[//]: # (Свойство «length»)
- <details><summary><b>Свойство «length»</b></summary><p>
  
  - Наибольший цифровой индекс +1 (т.к. нумерация с нуля)
  - Можно сказать, это общее число элементов в массиве - если он заполнен без дырок
  - Если уменьшить `length` - укоротим массив, удалим элементы с конца
  
  <br></p>
  </details>


[//]: # (Перебор массива)
- <details><summary><b>Перебор массива</b></summary><p>
  
  - `For` - Перебор по индексам
  - `For of` - выводит значения элементов, но не сообщает их индекс
  - `For in`
    - метод объектов. Плохая идея
    - Выполняет перебор всех свойств объекта, а не только цифровых
    - В 10-100 раз медленнее, т.к. оптимизирован под обычные объекты
  - +
  - `forEach(func)` – вызывает func для каждого элемента. Ничего не возвращает.
  - Методы преобразования - `map`, `sort` и т.д.
  
  <br></p>
  </details>


[//]: # (Оператор «in»)
- <details><summary><b>Оператор «in»</b></summary><p>
  
  - проверка существования элемента в объекте (в т.ч. массиве)
  - принимает индекс элемента
  - возвращает `true`/`false` — элемент с таким индексом существует / нет

  <br></p>
  </details>


[//]: # (Реализация метода «toString» для массивов)
- <details><summary><b>Реализация метода «toString» для массивов</b></summary><p>
  
  - Вернёт список элементов, разделённых запятыми.
    - `alert(['a', 17, 'c']);` // a,17,c
  - Быть аккуратно с бинарным "+" - произведет сложение строк!
    - `alert( "" + 1 )` // "1"
    - `alert( "1" + 1 )` // "11"
    - `alert( "1,2" + 1 )` // "1,21"
  
  <br></p>
  </details>


[//]: # (Мутирующие / не мутирующие методы)
- <details><summary><b>Мутирующие / не мутирующие методы</b></summary><p>

  - [sort()](https://learn.javascript.ru/array-methods#sort-fn) - сортировка «на месте».
    - `arr.sort(/*функция сортировки*/)`
  - [reverse()](https://learn.javascript.ru/array-methods#reverse) - смена порядка элементов на обратный.
  - [splice()](https://learn.javascript.ru/array-methods#splice) - добавлять, удалять и заменять элементы.
  
  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Массивы](https://learn.javascript.ru/array)
  - [learn.javascript.ru - Объекты](https://learn.javascript.ru/object)
  - [learn.javascript.ru - Шпаргалка Методы массивов](https://learn.javascript.ru/array-methods#itogo)
  - [Habr - Несколько полезных кейсов при работе с массивами в JavaScript](https://habr.com/ru/post/279867/)
  - [Козлова О - JS Interview Questions. Массивы](https://medium.com/@olgakozlova/javascript-interview-questions-part-i-arrays-e996f6433089)
  - [Хватит использовать массивы! Как JavaScript Set ускоряет код](https://proglib.io/p/javascript-sets/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Массивы. Методы массивов)
<details id="arrayMethods"><summary><b>Массивы. Методы массивов</b></summary><p>
  
[//]: # (Шпаргалки)
- <details><summary><b>Шпаргалки</b></summary><p>

  - [learn.javascript.ru - Шпаргалка](https://learn.javascript.ru/array-methods#itogo)
  - [Habr - 15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году](https://habr.com/ru/company/plarium/blog/483958/)

  <br></p>
  </details>

[//]: # (Основные)
- <details><summary><b>Основные</b></summary><p>

  - [push(...items)](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – добавляет элементы в конец,
  - [pop()](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – извлекает элемент из конца,
  - [shift()](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – извлекает элемент из начала,
  - [unshift(...items)](https://learn.javascript.ru/array#metody-pop-push-shift-unshift) – добавляет элементы в начало.
  - [splice](https://learn.javascript.ru/array-methods#splice)* - добавлять, удалять и заменять элементы. **Мутирующий!**
  - [slice](https://learn.javascript.ru/array-methods#slice) - создаёт новый массив и копирует в него эл-ты с опр. индексами
  - [concat](https://learn.javascript.ru/array-methods#concat) - создаёт новый массив и копирует в него данные из
    старых
  - [forEach](https://learn.javascript.ru/array-methods#perebor-foreach) - перебор
  - [indexOf/lastIndexOf и includes](https://learn.javascript.ru/array-methods#indexof-lastindexof-i-includes) - поиск
    в массиве
  - [find и findIndex](https://learn.javascript.ru/array-methods#find-i-findindex) - поиск первого совпадения
  - [filter](https://learn.javascript.ru/array-methods#filter) - поиск всех совпадений. Вернёт новый массив.
  - [map](https://learn.javascript.ru/array-methods#map) - преобразование. Вернёт новый массив с таким же кол-вом элементов
  - [sort(fn)](https://learn.javascript.ru/array-methods#sort-fn)* - сортировка «на месте». **Мутирующий!**
  - [reverse](https://learn.javascript.ru/array-methods#reverse)* - смена порядка элементов на обратный.  **Мутирующий!**
  - [split и join](https://learn.javascript.ru/array-methods#split-i-join) - разбивка/объединение
  - [join](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join) — преобразует все элементы массива в строки и объединяет их в одну большую строку
  - [reduce/reduceRight](https://learn.javascript.ru/array-methods#reduce-reduceright) - вычисление одного значения на основе массива. Перебрать массив и вычислить значение.
  - [Array.isArray](https://learn.javascript.ru/array-methods#array-isarray) - отличить массив от объекта
  - [every(fn)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/every) - удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
  - [some(fn)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/some) - удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.
  - 
  - 
  - `Array.from()` — преобразовать перебираемый объект в массив (например строку в массив символов)
  -
  -
  - **Добавления/удаления элементов**
    - `push(...items)` – добавляет элементы в конец. Работает заметно быстрее чем shift/unshift
    - `pop()` – извлекает элемент с конца. Работает заметно быстрее чем shift/unshift
    - `shift()` – извлекает элемент с начала,
    - `unshift(...items)` – добавляет элементы в начало.
    - `splice(pos, deleteCount, ...items)` – начиная с индекса pos , удаляетdeleteCount элементов и вставляет items .
    - `slice(start, end)` – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end ).
    - `concat(...items)` – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items . Если какой-то из items является массивом, тогда берутся его элементы.
  
  - **Поиска среди элементов**
    - `indexOf/lastIndexOf(item, pos)` – ищет item , начиная с позиции pos , и возвращает его индекс или -1 , если ничего не найдено.
    - `includes(value)` – возвращает true , если в массиве имеется элемент value , в противном случае false .
    - `find/filter(func)` – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
    - `findIndex` — похож на find , но возвращает индекс вместо значения.
  
  - **Перебора элементов**
    - `forEach(func)` – вызывает func для каждого элемента. Ничего не возвращает.
  
  - **Преобразования массива**
    - `map(func)` – создаёт новый массив из результатов вызова func для каждогоэлемента.
    - `sort(func)` – сортирует массив «на месте», а потом возвращает его.
    - `reverse()` – «на месте» меняет порядок следования элементов напротивоположный и возвращает изменённый массив.
    - `split/join` – преобразует строку в массив и обратно.
    - `reduce(func, initial) `– вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

  <br></p>
  </details>

[//]: # (Новые)
- <details><summary><b>Новые</b></summary><p>
  
  - [findLast()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast)
    и [findLastIndex()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex)
    — поиск в массивах «с конца
  - [at()](https://learn.javascript.ru/array#poluchenie-poslednih-elementov-pri-pomoschi-at) — обращаться к массивам с
    конца. И строкам тоже
  - [flat()](https://ru.hexlet.io/blog/posts/flat-i-flatmap-novye-metody-dlya-raboty-s-massivami-v-ecmascript)
    и [flatMap()](https://ru.hexlet.io/blog/posts/flat-i-flatmap-novye-metody-dlya-raboty-s-massivami-v-ecmascript) —
    рекурсивно сгладить массивы до заданной глубины и вернуть новый массив. Т.е. многомерный массив сделать одномерным.
    - [flat)()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) на MDN
    - [flatMap()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap) на MDN
    
  <br></p>
  </details>

[//]: # (Чаще всего спрашивают)
- <details><summary><b>Чаще всего спрашивают</b></summary><p>

  - [map](https://learn.javascript.ru/array-methods#map) - преобразование. Каждый элемент исходного массива обрабатываем в функции, преобразуем и   результат записываем в новый массив.
    - `const result = numbers.map(n => n*2)`
    - Вернёт массив, со всеми элементами массива numbers, умноженными на 2.
    - Если не надо возвращать массив — используй `for`/`forEach`.
      - ```js
        let myArray = [1, 2, 3, 4, 5];
        for (let i = 0; i <= myArray.length - 1; i++) {
          console.log(myArray[i]);
        }
        ```
      - ```js
        let myArray = [1, 2, 3, 4, 5];
        for (let item of myArray) {
          //Не предоставляет доступа к индексу текущего элемента, только к его значению
          console.log( item );
        }
        ```
  - [filter](https://learn.javascript.ru/array-methods#filter) - Каждый элемент исходного массива обрабатываем в функции. Функция вернёт true/false   => если true, то результат пишем в новый массив.
    - `const result = numbers.filter(n => n > 3)`
    - Вернёт массив, со всеми элементами массива numbers, которые > 3.
  - [reduce](https://learn.javascript.ru/array-methods#reduce-reduceright) - перебрать массив и вычислить одно значение. Каждый элемент исходного   массива обрабатываем в функции, на выходе получаем одно значение
    - `const sum = numbers.reduce((acc, n) => acc + n, 0)`
    - Вернёт сумму всех элементов массива numbers (acc). 0 = значение acc на первом шаге

  - `Array.from()` — преобразовать перебираемый объект в массив (например строку в массив символов)
    
  <br></p>
  </details>

[//]: # (Мутирующие методы)
- <details><summary><b>Мутирующие методы</b></summary><p>

  - [sort()](https://learn.javascript.ru/array-methods#sort-fn) - сортировка «на месте».
  - [reverse()](https://learn.javascript.ru/array-methods#reverse) - смена порядка элементов на обратный.
  - [splice()](https://learn.javascript.ru/array-methods#splice) - добавлять, удалять и заменять элементы.
    
  <br></p>
  </details>

[//]: # (Методы «map»/«filter»/«reduce» вместо циклов «for» и «forEach»)
- <details><summary><b>Методы «map»/«filter»/«reduce» вместо циклов «for» и «forEach»</b></summary><p>

  Пришли в JS из функционального программирования. <br>
  Используя эти три метода, вы избегаете циклов `for` и `forEach` в большинстве ситуаций. Вместо них можно использовать совокупность `map`, `filter` и `reduce`.<br>
  Подробнее: [tproger.ru — Шпаргалка по современному JS](https://tproger.ru/translations/javascript-cheatsheet/#arrmthdsmapfltrrdc)
  ```js
  //Посчитать сумму оценок студентов с результатом 10 и выше
  const students = [
    { name: "Nick", grade: 10 },
    { name: "John", grade: 15 },
    { name: "Julia", grade: 19 },
    { name: "Nathalie", grade: 9 },
  ];

  const aboveTenSum = students
    .map(student => student.grade) // формируем массив оценок
    .filter(grade => grade >= 10) // отбираем оценки выше 10
    .reduce((prev, next) => prev + next, 0); // суммируем каждую оценку выше 10

  console.log(aboveTenSum) // 44 = 10 (Nick) + 15 (John) + 19 (Julia). Nathalie игнорируется, поскольку её оценка ниже 10
  ```
    
  <br></p>
  </details>

[//]: # (Список с MDN)
- <details><summary><b>Список с MDN</b></summary><p>
  
  - [Array.prototype\[@@iterator\]()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator)
  - [Array.prototype.at()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/at)
  - [Array.prototype.concat()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)
  - [Array.prototype.copyWithin()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)
  - [Array.prototype.entries()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)
  - [Array.prototype.every()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/every)
  - [Array.prototype.fill()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)
  - [Array.prototype.filter()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
  - [Array.prototype.find()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
  - [Array.prototype.findIndex()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)
  - [Array.prototype.flat()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
  - [Array.prototype.flatMap()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)
  - [Array.prototype.forEach()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
  - [Array.from()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
  - [Array.prototype.group()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/group)
  - [Array.prototype.includes()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)
  - [Array.prototype.indexOf()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  - [Array.isArray()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  - [Array.prototype.join()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join)
  - [Array.prototype.keys()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)
  - [Array.prototype.lastIndexOf()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
  - [Array.prototype.map()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
  - [Array.of()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/of)
  - [Array.prototype.pop()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
  - [Array.prototype.push()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
  - [Array.prototype.reduce()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
  - [Array.prototype.reduceRight()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)
  - [Array.prototype.reverse()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
  - [Array.prototype.shift()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
  - [Array.prototype.slice()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
  - [Array.prototype.some()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
  - [Array.prototype.sort()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
  - [Array.prototype.splice()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
  - [Array.prototype.toLocaleString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString)
  - [Array.prototype.toString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/toString)
  - [Array.prototype.unshift()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
  - [Array.prototype.values()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/values)
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Шпаргалка](https://learn.javascript.ru/array-methods#itogo)
  - [Habr - 15 методов работы с массивами в JavaScript, которые необходимо знать в 2020 году](https://habr.com/ru/company/plarium/blog/483958/)
  - [Habr - Область видимости переменной в Javascript (ES4-5)](https://habr.com/ru/post/78991/)
  
  <br></p>
  </details>

<br><p>
</details>

[//]: # (Объекты)
<details id="objects"><summary><b>Объекты</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Структура для хранения данных в формате «ключ - значение».
  - 
  - {Ключ/имя/идентификатор свойства: значение свойства}
  - К значениям можно обращаться как к свойствам в синтаксисе .propName или ["propName"].
  - Квадратные скобки также позволяют обратиться к свойству объекта, имя которого может быть результатом выражения.
    Например, имя свойства может храниться в переменной:
    ```js
    let key = "likes birds";
    // то же самое, что и user["likes birds"] = true;
    user[key] = true;
    ```
  - 
  - 
  - В других языках программирования такую структуру данных также называют «словарь» и «хэш».
  - В JS объекты также используются как элементы ООП, это немного отдельно.
  - Массив
    - это разновидность объекта. Обладает дополнительными свойствами и ограничениями
    - Массивы рассчитаны на числовое индексирование; это означает, что значения хранятся в позициях, обычно называемых индексами, которые принимают положительные целые значения.
  - 
  - Объекты и классы
    - JS — один из очень немногих языков, в которых объекты можно создавать явно и непосредственно, без предварительного определения их структуры виклассе. 
    - Многие годы разработчики реализовывали на основе прототипов паттерн проектирования «класс», так называемое прототипическое наследование (см. приложение А, раздел «Прототипические «классы»). Затем с появлением в ES6 ключевого слова class язык ускорил свое движение по направлению к программированию в стиле ОО/классов.
    - Но я считаю, что это стремление только скрывает красоту и мощь системы прототипов — способности двух объектов просто соединиться друг с другом и взаимодействовать динамически (во время выполнения функции/метода) посредством совместного использования контекста this.
    - Классы — всего лишь один из паттернов, которые можно реализовать на основе этой мощи. Можно подойти с совершенно другой стороны: просто принять объекты как объекты, забыть о классах и предоставить объектам взаимодействовать через цепочку прототипов. Такой подход называется делегированием поведения. Я считаю, что для организации поведения и данных делегирование работает лучше, чем наследование классов.
    
  <br></p>
  </details>

[//]: # (Разные виды объектов)
- <details><summary><b>Разные виды объектов</b></summary><p>

  - «простой объект» («plain object») или просто Object
  - массивы
  - функции
  - Date
  - Error
  - RegExp
  - все структуры которые создаются с ключевым словом `new`: Map, Set, WeakMap, WeakSet...
  
  см. раздел «[Что является объектом](#whatIsObject)»

  <br></p>
  </details>

[//]: # (Что является объектом в JS?)
- <details id="whatIsObject"><summary><b>Что является объектом в JS?</b></summary><p>

  - **Объекты**
    - собственно объекты (логично)
    - массивы
    - функции
    - RegExp
    - все структуры которые создаются с ключевым словом `new`: Map, Set, WeakMap, WeakSet...
  - **Не совсем объекты**
    - у String, Number, Boolean можно вызывать некоторые методы объектов, например `str.length` — в памяти временно создаётся объект
  - **Не объекты**
    - Null — значение не определено. 'typeof' выдаст Object. Ошибка языка
    - undefined — неинициализированное значение (не было изначально)
    -
    - BigInt — какие-то методы есть, может и такой же вариант как у String, Number, Boolean
    - Symbol — какие-то методы есть, может и такой же вариант как у String, Number, Boolean
  
  <br></p>
  </details>

[//]: # (Св-ва в объекте упорядочены спец. образом)
- <details><summary><b>Св-ва в объекте упорядочены спец. образом</b></summary><p>

  - св-ва с целочисленными ключами сортируются по возрастанию
  - остальные располагаются в порядке создания.
  - «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
  - То есть, "49" – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится.
  - А вот свойства "+49" или "1.2" таковыми не являются

  <br></p>
  </details>

[//]: # (Объекты хранятся и копируются «по ссылке»)
- <details><summary><b>Объекты хранятся и копируются «по ссылке»</b></summary><p>

  - Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.
  - Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.
  - Два объекта равны только в том случае, если это один и тот же объект.
    - Операторы `==` и `===` для объектов работают одинаково.
    - две переменные ссылаются на один и тот же объект, поэтому они равны друг другу
    - два разных объекта не равны, хотя оба пусты...
    - Для сравнений вроде `obj1 > obj2` или для сравнения с примитивом `obj == 5` объекты преобразуются в примитивы.
  
  <br></p>
  </details>

[//]: # (Создание объекта)
- <details><summary><b>Создание объекта</b></summary><p>

  - Конструктор объекта - `const user = new Object({name: 'Ivan'});`
  - Литеральная нотация - `let user = {name: 'Ivan'}`
  -
  - 2 формы создания объекта
    - Литеральная (декларативная)
      ```js
      var myObj = {
        key: value
      }; 
      ```
    - Сконструированная
      ```js
      var myObj = new Object();
      myObj.key = value;
      ```
    - Обе формы равнозначны
  
  <br></p>
  </details>

[//]: # (Доступ к свойству через [])
- <details><summary><b>Доступ к свойству через []</b></summary><p>

  - Если имя св-ва = n слов (`['key name']`)
  - Если имя св-ва = результат выражения. Например хранится в переменой (`[variable]`),  (`[variable + 'SomeText']`)
  - Если имя св-ва = вычисляемое свойство. Имя будет выдано другой переменной/функцией по результатам ее работы
  
  <br></p>
  </details>

[//]: # (Трансформация объектов)
- <details><summary><b>Трансформация объектов</b></summary><p>

  - У объектов нет множества методов, которые есть в массивах, например map, filter и других.
  - Если нужен аналог - можно использовать метод `Object.entries` с последующим вызовом `Object.fromEntries` :
    1. Вызов `Object.entries(obj)` возвращает массив пар ключ/значение для obj .
    2. На нём вызываем методы массива, например, `map` .
    3. Используем `Object.fromEntries(array)` на результате, чтобы преобразовать его обратно в объект.
  
  <br></p>
  </details>

[//]: # (Оператор «in»)
- <details><summary><b>Оператор «in»</b></summary><p>

  - Проверка существования св-ва в объекте.
  - Если св-ва нет - вернёт undefined
  - Позволяет отследить когда свойство есть, но его значение = undefined
  - `alert( "age" in user );` // true если user.age существует. "age" в кавычках — это имя свойства объекта user
  - `variable_with_key_name in user` // variable_with_key_name без кавычек - это не имя свойства, а ссылка на переменную, в которой это имя лежит
  
  <br></p>
  </details>

[//]: # (Цикл «for ... in»)
- <details><summary><b>Цикл «for ... in»</b></summary><p>

  - перебор всех св-в объекта
  - ```js
      for (key in object) { 
        // выполнится для каждого св-ва объекта
      }
      for (let key in object) { 
        // ... 
      }
    ```
  
  <br></p>
  </details>

[//]: # (Способы создания метода объекта)
- <details><summary><b>Способы создания метода объекта</b></summary><p>

  - Отдельно создали функцию, потом присвоили её св-ву объекта
  - Добавляем методу св-во и после = сразу пишем функцию
  - В самом объекте сразу пишем свойства, а после пишем функцию
  - В самом объекте пишем
    ```js
    // У этих объектов одинаковые методы
    user = { 
      sayHi: function() { 
        alert("Привет"); 
      }
    }; 
  
    // сокращённая запись
    user = {
      sayHi() {  
        alert("Привет");
      }
    };
    ```
  
  <br></p>
  </details>

[//]: # (Ключевое слово «this»)
- <details><summary><b>Ключевое слово «this»</b></summary><p>
  
  - Ключевое слово для доступа из метода объекта к другой информации в этом объекте
  - Значение this - объект перед точкой
  - Не является фиксированным. Его значение вычисляется в момент
  - Вызов функции без объекта:
    - В "use strict"
      - this == undefined
      - в таком коде значением this будет являться undefined . Если мы попытаемся получить доступ к name , используя this.name – это вызовет ошибку.
    - В нестрогом режиме значением this в таком случае будет глобальный объект (window для браузера).
    - Обычно подобный вызов является ошибкой программирования. Если внутри функции используется this, тогда ожидается, что она будет вызываться в   контексте какого-либо объекта.
  - У  стрелочных функций нет «this»
    - Его значение берётся снаружи - из внешней «нормальной» функции. Т.е
  - Методы могут ссылаться на объект через this .
  - Значение this определяется во время исполнения кода.
  - При объявлении любой функции в ней можно использовать this , но этот this не имеет значения до тех пор, пока функция не будет вызвана.
  - Эта функция может быть скопирована между объектами (из одного объекта в другой).
  - Когда функция вызывается синтаксисом «метода» – object.method() , значением this во время вызова является объект перед точкой.
  
  <br></p>
  </details>

[//]: # (Функция конструктор объектов и оператор «new»)
- <details><summary><b>Функция конструктор объектов и оператор «new»</b></summary><p>

  - Чтобы создавать много однотипных функций по шаблону
  - Это обычные функции.
  - Технически любая функция может быть использована как конструктор. То есть, каждая функция может быть вызвана при помощи оператора new, и   выполнится алгоритм создания нового объекта из конструктора (см. [Конструктор](#constructor) )
  -
  - **Классы**<br>
    - Для создания сложных объектов есть и более «продвинутый» синтаксис чем конструктор – классы.
    - см. раздел «[Классы](#classes)»
  
  <br></p>
  </details>

[//]: # (Объекты — другие темы)
- <details><summary><b>Объекты — другие темы</b></summary><p>

  - [Методы объектов](#objectMethods)
  - [Копирование объектов](#objectCopy)
  - [Перебор свойств объектов](#objectEnumeration)
  - [Преобразование объектов в примитивы](#objectToPrimitive)
  - [Аттрибуты свойств. Флаги, дескрипторы, методы доступа](#propertiesAttributes)
  - [Перебор структур данных. Методы «keys», «values», «entries»](#keysValuesEntries)
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Объекты](https://learn.javascript.ru/object)
  - [learn.javascript.ru - Массивы](https://learn.javascript.ru/array)
  - [learn.javascript.ru - Шпаргалка Методы массивов](https://learn.javascript.ru/array-methods#itogo)
  - [Habr - Несколько полезных кейсов при работе с массивами в JavaScript](https://habr.com/ru/post/279867/)
  - [Козлова О - JS Interview Questions. Массивы](https://medium.com/@olgakozlova/javascript-interview-questions-part-i-arrays-e996f6433089)
  - [Хватит использовать массивы! Как JavaScript Set ускоряет код](https://proglib.io/p/javascript-sets/)
    
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Объекты. Методы объектов)
<details id="objectMethods"><summary><b>Объекты. Методы объектов</b></summary><p>


[//]: # (Шпаргалки)
- <details><summary><b>Шпаргалки</b></summary><p>

  - [MDN - Методы конструктора Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object#methods)
    
  <br></p>
  </details>

[//]: # (Базовые)
- <details><summary><b>Базовые</b></summary><p>

  - `delete user.age` - удаление свойства
  -
  - `keys()` — возвращает ключи объекта.
  - `values()` — возвращает значения объекта.
  - `entries()` — создает вложенный массив пар «ключ-значение» объекта
  -
  - `assign()` — копирование свойств объекта в другой объект.
  - `create()` — создать новый объект из существующего.
  -
  - `freeze()` — «замораживает» объект. Предотваращает изменения свойств и т.д.
  - `seal()` — предотвращает добавление новых свойств, но позволяет изменять существующие.
  - `getPrototypeOf()` — получения внутреннего скрытого [[Prototype]] объекта, также доступного через свойство __proto__
  - 
  - ... там ещё много. Изучать
  - что-то добавили в последние несколько лет

  - [Некоторые методы объектов](https://techrocks.ru/2021/10/27/40-javascript-methods-you-should-know/#object)
      
  <br></p>
  </details>
  
[//]: # (Новые)
- <details><summary><b>Новые</b></summary><p>

  - [hasOwn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn) (en) — ES13 ( 2022). проверяет:   принадлежит ли св-во этому объекту? Или оно унаследовано / не существует?
  - [fromEntries](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) — ES10 (2019). преобразует   список пар ключ-значение в объект. Обратное методу `Object.entries`.
    
  <br></p>
  </details>

[//]: # (Методы конструктора Object)
- <details><summary><b>Методы конструктора Object</b></summary><p>

  - [assign()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) - копирование свойств объекта в другой объект.
    - При объединении двух объектов с `Object.assign` первый объект мутируется. Другие объекты остаются неизменными.
  - [create()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create) - создать новый объект из существующего.
  - [keys()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) - возвращает массив ключей объекта (имена всех **собственных** перечислимых свойств объекта).
  - [values()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values) - возвращает значения объекта.
  - [freeze](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) - «замораживает» объект. Другой код не сможет удалить или изменить никакое свойство.
  - [seal](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) - предотвращает добавление новых свойств, но позволяет изменять существующие.
  - [entries()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) - создает вложенный массив пар «ключ-значение» объекта
  - [defineProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) - добавляет к объекту именованное свойство, описываемое переданным дескриптором.
  - [defineProperties](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties) - добавляет к объекту именованные свойства, описываемые переданными дескрипторами.
  - [getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) - возвращает дескриптор свойства для именованного свойства объекта.
  - [getOwnPropertyDescriptors](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors) - возвращает все собственные дескрипторы свойств данного объекта.
  - [getOwnPropertyNames](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames) - возвращает массив, содержащий имена всех переданных объекту **собственных** перечисляемых и неперечисляемых свойств.
  - [getOwnPropertySymbols](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) - Возвращает массив всех символьных свойств, найденных непосредственно в переданном объекте.
  - [getPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) - получение внутреннего скрытого свойства [[Prototype]] объекта (оно также доступно через свойство `__proto__`)
  - [is](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is) - определяет, являются ли два значения различимыми (то есть, одинаковыми)
  - [isExtensible](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible) - определяет, разрешено ли расширение объекта.
  - [isFrozen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen) - определяет, был ли объект заморожен.
  - [isSealed](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed) - определяет, является ли объект запечатанным (sealed).
  - `observe()` — асинхронно наблюдает за изменениями в объекте.
  - [preventExtensions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions) - предотвращает любое расширение объекта.
  - [setprototypeof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) - устанавливает прототип (т.е. внутреннее свойство `[[Prototype]]`)
  - [fromEntries](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) - преобразует список пар ключ-значение в объект. Обратное методу `Object.entries`.
  - [hasOwn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn) (en) - проверять является ли св-во прямым свойством объекта, даже если его значение null или undefined. В отличие от оператора `in` - не проверяет это свойство в цепочке прототипов объекта.
  - [hasOwnProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) - проверять содержит ли объект указанное неунаследованно) свойство, или метод.
  - [isPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf) - проверяет существует ли указанный объект в цепочке прототипов другого объекта
  - [propertyIsEnumerable](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable) - является ли указанное свойство перечисляемым. Перечисляемые - все свойства, которые добавляются к объекту, являются перечисляемыми по умолчанию. Встроенные свойства не перечисляется.
  - [setPrototypeOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) - позволяет установить или изменить прототип указанному объекту.Создаваемый объект наследует свойства от прототипа.
  - [toLocaleString](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString) - возвращает строку, представляющую объект. Предназначен для переопределения унаследованными объектами в целях поддержки зависимости от локали.
  - [toString()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString) - возвращает строку, представляющую объект.
  - [valueOf](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf) - для преобразования объекта в примитивное значение.
    
  <br></p>
  </details>

[//]: # (Устаревшие)
- <details><summary><b>Устаревшие</b></summary><p>

  - [__defineGetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__)
    - привязывает свойство объекта к функции, вызываемой каждый раз при поиске этого свойства. Вместо него `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)`
  - [__defineSetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__) 
    - привязывает свойство объекта к функции, вызываемой каждый раз при попытке установить значение этого свойства. Вместо него рекомендуется использовать `(синтаксис инициализатора объекта (new Object(), Object.create() или литеральную нотацию)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Object_initializer)` или `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)`
  - [__lookupGetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__)
    - возвращает функцию, привязанную к геттеру указанного свойства. Вместо него `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)` и `[getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)`
  - [__lookupSetter__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__)
    - возвращает функцию, привязанную к сеттеру указанного свойства. Вместо него `[defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)` и `[getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)`
  - [__proto__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) 
    - является свойством доступа (комбинацией геттера и сеттера), которое расширяет внутренний прототип [[Prototype]] объекта ( являющийся объектом или null), через который осуществлялся доступ. Вместо него `Object.getPrototypeOf`/`Object.setPrototypeOf` /`[Object.create(proto, [descriptors])]((https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create)) `.
    
  <br></p>
  </details>

[//]: # (Про мутации объектов)
- <details><summary><b>Про мутации объектов</b></summary><p>

  - При объединении двух объектов с `Object.assign` первый объект мутируется. Другие объекты остаются неизменными.
  - Object.freeze предотвращает непосредственное изменение свойств объекта.
    
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Некоторые методы объектов](https://techrocks.ru/2021/10/27/40-javascript-methods-you-should-know/#object)
  - [Habr - Работа с объектами в JavaScript: теория и практика](https://habr.com/ru/post/48542/)
  - [8 методов объектов в JavaScript (2018)](https://www.8host.com/blog/metody-obektov-v-javascript/)
  - [40 методов JavaScript, которые вы должны знать](https://techrocks.ru/2021/10/27/40-javascript-methods-you-should-know/#object)
  - [MDN - Методы конструктора Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object#methods)
    
  <br></p>
  </details>

<br><p>
</details>

[//]: # (Объекты. Копирование объектов)
<details id="objectCopy"><summary><b>Объекты. Копирование объектов</b></summary><p>


[//]: # (Поверхностное копирование)
- <details><summary><b>Поверхностное копирование</b></summary><p>

  - Spread оператор `...`
    - копирует собственные перечисляемые свойства данного объекта в новый объект. [Подробнее](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_%D0%B2_%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D0%B0%D1%85_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
  - цикл («наивное» копирование)
    - создать новый объект и повторить структуру дублируемого объекта, перебирая его свойства и копируя их
    - пример `for (let key in user) {newObj[key] = oldObj[key]}`
    - проблемы
      - меняется метод `Object.prototype`,
      - дескрипторы свойств не скопированы (т.е. флаги `writable`, `enumerable`, `configurable`)
      - копирует только перечисляемые свойства
  - `object.assign`
    - работает для поверхностного копирования циклических объектов
    - можно использовать для копирования методов
  
  <br></p>
  </details>

[//]: # (Глубокое копирование)
- <details><summary><b>Глубокое копирование</b></summary><p>

  - цикл рекурсивный
  - `JSON.parse(JSON.stringify(object))`;
    - нельзя использовать для копирования методов объекта (вообще всех функций)
    - не работает для циклических объектов (объекты, у которых есть свойства, ссылающиеся сами на себя)
    - пример `const myDeepCopy = JSON.parse(JSON.stringify(myOriginal))`
  - [WebAPI structuredClone](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    - пример `const myDeepCopy = structuredClone(myOriginal);`
    - [Подробнее](https://habr.com/ru/companies/otus/articles/719460/)
  - [lodash.cloneDeep(obj)](https://lodash.com/docs/4.17.15#cloneDeep)
  
  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Medium - Копирование объектов в JavaScript (2019)](https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff)
  - [Habr - Независимое глубокое клонирование объектов в JavaScript (2019)](https://habr.com/ru/post/480786/)
  
  <br></p>
  </details>

  <br><p>
</details>

[//]: # (Объекты. Свойства. Дескрипторы свойств)
<details id="objectEnumeration"><summary><b>Объекты. Свойства. Дескрипторы свойств</b></summary><p>

[//]: # (Свойства объектов)
- <details><summary><b>Свойства объектов</b></summary><p>

  - область памяти, которой присвоено имя. Хранит не столько само значение, сколько ссылка на место хранения значения.
  - можно получить доступ через «обращение к свойству» (somObject.someName) или через «обращение к ключу» (somObject['someName']) — это взаимозаменяемые формы обращения.
  - В объектах имена свойств всегда являются строками. Если в качестве свойства используется любое значение кроме string  — оно сначала будет преобразовано в строку.
    - Это относится и к числам, которые обычно используются в качестве индексов массивов. Будь осторожен, не путай использование чисел между объектами и массивами
  - По спецификации, в качестве ключей для свойств объекта могут использоваться только `String` или `Symbol`
  - Вычисляемые имена свойств
    - появились в ES6
    - в позиции «ключ-имя» объявления объектного литерала указывается выражение, заключенное в `[]`
    ```js
        var prefix = "foo";
        var myObject = {
            [prefix + "bar"]: "hello",
            [prefix + "baz"]: "world"
        };
        myObject["foobar"]; // hello
        myObject["foobaz"]; // world
    ```

  <br></p>
  </details>

[//]: # (Дескрипторы свойств)
- <details><summary><b>Дескрипторы свойств</b></summary><p>

  - описывают  свойства.
  - какие данные о свойстве содержат
    - writable — возможность изменения значения св-ва
      - в частности: есть объект-родитель X, у него есть св-во X.something. Создам от X объект-потомок Y, и попытаюсь определить ему св-во Y.something. Если у X.something помечено как `writable:false` (доступное только для чтения) — я не смогу его заместить/затенить свойством Y.something. Получу ошибку (режиме strict) или просто ничего не произойдёт (без strict). Если всё-таки надо заместить/затенить X.something — надо использовать не присваивание (`=`) а `Object.defineProperty(..)`.
    - enumerable — перечисляемость св-ва в числе прочих свойств объекта. Означает «будет присутствовать в свойствах объекта при переборе».   Например в цикле `for..in`.
    - configurable— возможность изменения значения дескрипторов. False необратимо делает дескрипторы этого св-ва неизменяемым.
  - появились в ES5

  <br></p>
  </details>

[//]: # (Неизменяемость св-в или объектов)
- <details><summary><b>Неизменяемость св-в или объектов</b></summary><p>

  - Когда надо создать свойства или объекты, которые не могут быть изменены:
    - Объектные константы — задать св-ву дескрипторы `writable:false` и `configurable:false`
    - Запрет расширения (вызов `Object.preventExtensions(..)`) — запрет возможности добавления новых свойств в объект
    - Seal (вызов `Object.seal(..)`) — то же что `Object.preventExtensions(..)` + все существующие св-ва получают пометку `configurable:false`.
    - Freeze (вызов `Object.freeze(..)`) — то же что `Object.preventExtensions(..)` + все существующие св-ва получают пометку `configurable:false`   и `writable:false``**

  <br></p>
  </details>

[//]: # ([[Get]])
- <details><summary><b>[[Get]]</b></summary><p>

  - Код `myObject.a` вызывает в объекте операцию `[[Get]]`
    - ищет в объекте свойство с указанным именем.
    - если оно будет найдено — возвращает соответствующее значение.
    - если не найдено — ищет в цепочке `[[Prototype]]` (если она существует),
    - если и там не найдено — возвращает значение `undefined`
  - Это поведение отличается от обращения к **переменным** по именам идентификаторов.
    - При обращении к **переменной**, которую не удается разрешить соответствующим поиском по лексической области видимости, вы не получите результат `undefined`, как при обращении к **свойствам объектов** — вместо это будет выдана ошибка `ReferenceError`

  <br></p>
  </details>

[//]: # ([[Put]])
- <details><summary><b>[[Put]]</b></summary><p>

  - Управляет присваиванием значений существующим или новым свойствам,
  - Поведение [[Put]] при вызове зависит от ряда факторов, в том числе (и прежде всего) от того, существует ли свойство в объекте или нет.
  - Там всё сложно
  - Если свойство присутствует
    1. Свойство является дескриптором функции доступа (см. «Геттеры и сеттеры»)? Вызывается set-функция, если она существует.
    2. Свойство является дескриптором данных с характеристикой writable:false? При отсутствии режима strict происходит незаметный сбой, а в режиме strict выдается ошибка TypeError.
    3. В остальных случаях значение присваивается существующему свойству, как обычно.
  - Если свойство отсутствует
    - Мы вернемся к этой ситуации при рассмотрении [[Prototype]] в главе 10, чтобы она стала более понятной.

  <br></p>
  </details>

[//]: # (Геттеры и сеттеры)
- <details><summary><b>Геттеры и сеттеры</b></summary><p>

  - Есть возможность переопределения некоторых операций по умолчанию не на уровне объектов, а на уровне отдельных свойств; для этой цели используются `get-` и `set-`методы (геттеры/сеттеры).
  - Геттер — свойства, которые вызывают скрытую функцию для получения нужного значения.
  - Сеттер — свойства, которые вызывают скрытую функцию для присваивания значения.
  - 
  - Когда вы определяете для свойства геттер и/или сеттер, его определение становится «дескриптором методов доступа» (в отличие от «дескриптора данных»). Для таких дескрипторов характеристики value и writable дескриптора игнорируются, JS учитывает только характеристики set и get свойства (а также configurable и enumerable).
  - Т.е. мы имеем свойство объекта, которое на самом деле не содержит значения. Но при при обращении к этому свойству автоматически вызывается скрытая функция для геттера, и возвращенное этой функцией значение становится результатом обращения к свойству.
  - Если для `myObject.a` определен только геттер, при попытке задать значение (`myObject.a = 3`) операция не выдаст ошибку, а просто игнорирует присваивание.
  - Если объявлен сеттер — он будет вызван при попытке присвоить значение свойства.
  - Вам почти всегда следует объявлять как геттер, так и сеттер (определение только одного метода доступа часто приводит к неожиданному и нелогичному поведению)
  - Есть объект-родитель X, у него есть св-во X.something. Создам от X объект-потомок Y, и попытаюсь определить ему св-во Y.something.
    Если свойство X.something имеет сеттер, то всегда будет вызываться сеттер. Свойство Y.something не будет добавлено в Y (с замещением/затенением), и сеттер something не будет переопределяться. Если всё-таки надо заместить/затенить X.something — надо использовать не присваивание (`=`) а `Object.defineProperty(..)`.

  <br></p>
  </details>

[//]: # (Проверка существования св-ва)
- <details><summary><b>Проверка существования св-ва</b></summary><p>

  - Предположим у объекта есть св-во `myObject.a === undefined` и нет св-ва `b` (также его нет в цепочке прототипов)
  - Запрашиваем myObject.a — получаем undefined
  - Запрашиваем myObject.b — получаем undefined
  - Но одно св-во существует в объекте и === undefined, а второго св-ва нет.
  - Как различить эти две ситуации?
    - проверить, содержит ли объект свойство, не запрашивая значение этого свойства:
      1. Оператор `in`
        - проверяет, присутствует ли заданное свойство в объекте или на одном из более высоких уровней обхода цепочки [[Prototype]]
        - `("b" in myObject); // false`
      2. Метод `hasOwnProperty`
        - проверяет, присутствует ли заданное свойство в объекте и не обращается к цепочке [[Prototype]]
        - `myObject.hasOwnProperty( "b" ); // false`

  <br></p>
  </details>

[//]: # (Проверка перечисляемости св-ва)
- <details><summary><b>Проверка перечисляемости св-ва</b></summary><p>

  - `for..in` — неперчисляемые не выводятся в этом цикле
  - `myObject.propertyIsEnumerable( "a" )` — неперечисляемые дадут `false`. проверяет, существует ли свойство с заданным именем непосредственно у объекта, а также характеристику enumerable:true.
  - `Object.keys(..)` — возвращает массив всех перечисляемых свойств
  - `Object.getOwnPropertyNames(..)` — возвращает массив всех свойств (как перечисляемых, так и нет)

  <br></p>
  </details>

[//]: # (Перебор свойств объектов)
- <details ><summary><b>Перебор свойств объектов</b></summary><p>

  - Лучший способ пройтись циклом по объектам - это сначала преобразовать объект в массив.
  - А затем, пройтись по преобразованному массиву привычными методами.
  - 
  - После преобразования объекта в массив (с ключами `Object.keys`, значениями `Object.values` или `Object.entries`) — можно работать с ними дальше в цикле, как с обычным массивом.
  - 
  - 
  - цикл `for..in`
    - проходит не только по собственным, но и по унаследованным свойствам объекта — итерация происходит с учетом свойств в цепочке Prototype
    - Приходится проверять, принадлежит ли свойство этому объекту
    - Если унаследованные свойства не нужны, их можно отфильтровать встроенным методом `obj.hasOwnProperty(key)` — вернёт `true`, если у obj есть собственное, не унаследованное, свойство с именем key.
    - Наследованное свойствj отображается в цикле. только есkи оно перечислимо. То есть у него внутренний флаг `enumerable` стоит `true`.
  - Метод `Object.keys`
    - принимает объект в качестве аргумента
    - возвращает массив с заданными ключами объекта.
    - свойства и из цепочки прототипов не учитываются.
    - Итерируя метод `Object.keys` с методом `forEach`, мы получаем доступ к паре ключ-значение объекта.
  - Метод `Object.values`
    - принимает объект в качестве аргумента
    - возвращает массив с заданными значениями объекта.
    - свойства и из цепочки прототипов не учитываются.
    - получаем доступ только к значениям объекта.
  - `Object.entries`
    - принимает объект в качестве аргумента
    - возвращает массив массивов, каждый является парой `[key, value]` данного объекта
    - свойства и из цепочки прототипов не учитываются.
    - Так как Object.entries возвращает массив массивов, то мы деструктурируем массив в его ключ и свойство.
    - При переборе полученного массива удобнее всего будет воспользоваться деструктуризацией, присвоив переменной текущий ключ и значение.
    - ```js
      const entries = Object.entries(fruits);
      for (const [fruit, count] of entries) {
        console.log(`Всего: ${count} ${fruit}s`)
      };
      // Всего — 28 apples
      // Всего — 17 oranges
      // Всего — 54 pears
      ```
  -   
  - Метод `Object getOwnPropertyNames`
    - принимает объект в качестве аргумента
    - возвращает массив строк, соответствующих перечисляемым и неперечисляемым свойствам, найденным непосредственно в объекте.
  - 
  - Если перебирать содержимое объекта в цикле `for..in` — в перечисление будут включены все свойства, достижимые по цепочке `[[Prototype]]` (для которых разрешено перечисление).
  - Если проверять существование свойства объекта оператором `in` — он проверит всю цепочку объекта (независимо от перечисляемости).
  - 
  - **Ссылки:**
    - [Как перебрать свойства объекта в JavaScript](https://frontend-stuff.com/blog/how-to-loop-through-object-in-javascript/)
    - [Перебор элементов объекта в JavaScript](https://badtry.net/pieriebor-eliemientov-obiekta-v-javascript/)
    - [learn.javascript.ru - Объекты. Цикл "for..in"](https://learn.javascript.ru/object#forin)
    - [Перебор свойств](https://www.wm-school.ru/js/js_object-for-in.php)
  
  <br></p>
  </details>

[//]: # (Перебор значений, а не свойств)
- <details><summary><b>Перебор значений (а не свойств)</b></summary><p>

  - Объекты
    - for..in — в этом цикле мы косвенно получаем все значения (перебор ведется только по перечисляемым св-вам объекта). Теперь можно вручную обращаться к свойствам для получения значений.
      - Циклы `for..in` лучше использовать только с объектами, а для перебора массивов — традиционные циклы `for` с числовыми индексами.
      - Циклы `for..in` применительно к массивам могут дать неожиданные результаты — в перечисление массива включаются не только все числовые индексы, но и все перечисляемые свойства.
    - цикл `for..of`
      - под капотом использует объект-итератор для того, что должно перебираться, а затем перебирает последовательные возвращаемые значения, полученные при вызове метода next() этого объекта-итератора (по одному для каждой итерации цикла).
      - у «классических объектов» (но не у массивов) нет нет встроенной функции `@@iterator` — можете определить собственную реализацию `@@iterator` для объекта, который я хочу сделать перебираемым
      - самый простой вариант — перебор «значение за значением», но можно определить сколь угодно сложные правила перебора. Это мощный новый синтаксический инструмент для работы с объектами и другими структурами данных. Например, список объектов Pixel (со значениями координат x и y) может выбрать для упорядочения перебора критерий линейного расстояния от начала координат (0,0) или отфильтровать точки, находящиеся «слишком далеко», и т. д.
  - Массивы
    - цикл `for`
    - `forEach(..)`
    - `every(..)`
    - `some(..)`
    - `for..of`
      - под капотом использует объект-итератор для того, что должно перебираться, а затем перебирает последовательные возвращаемые значения, полученные при вызове метода next() этого объекта-итератора (по одному для каждой итерации цикла).
      - массивы автоматически перебираются в этих циклах
    - ???

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Объекты. Аттрибуты свойств. Флаги, дескрипторы, методы доступа)
<details id="propertiesAttributes"><summary><b>Объекты. Аттрибуты свойств. Флаги, дескрипторы, методы доступа</b></summary><p>

- ВОЗМОЖНО надо объединить с предыдущим разделом (Объекты. Свойства. Дескрипторы свойств).

  [//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - У объектов JS есть свойства. В том числе у глобального объекта.
  - У всех свойств есть имя, значение и `аттрибуты` (флаги конфигурации, метаданные).
  
  <br></p>
  </details>

[//]: # (2 типа свойств — данные и аксессоры)
- <details><summary><b>2 типа свойств — данные и аксессоры</b></summary><p>


  - `свойства-данные` (data properties) — обычные свойства. Имеют дескрипторы данных.
    - ```js
      let user = {
        name: "John"
      };
      let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
      alert( JSON.stringify(descriptor, null, 2 ) );
      /* дескриптор свойства:
        {
          "value": "John",
          "writable": true,
          "enumerable": true,
          "configurable": true
        }
      */
      ```
  - `свойства-аксессоры` (accessor properties) — функции для присвоения/получения значения. Имеют дескрипторы доступа.
    - у такого свойства может быть 2 метода: «геттер» – для чтения и «сеттер» – для записи.
    - Не имеют дескрипторов `value` и `writable`, но имеют функции `get` и `set`.
    - Снаружи объекта выглядят как обычные свойства объекта. «Под капотом» работат как функции.
    - ```js
        let user = {
          name: "John",
          surname: "Smith",
          //заведём «виртуальное» свойство-аксессор fullName.
          //для работы с ним будем испольщовать два метода
          get fullName() {
            //метод-геттер, срабатывает при чтении user.fullName
            return `${this.name} ${this.surname}`;
          }, 
          set fullName(value) {
            //метод-сеттер, срабатывает при записи user.fullName = 'Ivan Petrov'
            [this.name, this.surname] = value.split(" ");
          } 
        };
      ```
  
  <br></p>
  </details>

[//]: # (Дескрипторы свойств)
- <details><summary><b>Дескрипторы свойств</b></summary><p>

  - `Дескриптор` свойства — объект с описанием свойства: его значение и атрибуты.
  - Запрашиваем информацию о свойстве объекта (см. методы ниже) - получаем объект-дескриптор с его описанием.
  - Два типа свойств (св-ва данных / св-ва доступа) => два типа дескрипторов.
  - Дескриптор может быть только одним из этих двух типов. Не может быть одновременно обоими.
  - 
  - **Дескрипторы** (флаги, аттрибуты, метаданные):
    - дескрипторы данных
      - `enumerable` — св-во перечисляется в циклах / циклы его игнорируют. Например, цикл for..in.
      - `configurable` — св-во можно удалить, а эти атрибуты можно изменять / этого делать нельзя.
      - `writable` — св-во можно изменить / только для чтения.
      - `value` — содержит непосредственно данные, значение свойства.
    - дескрипторы доступа (для аксессоров)
      - `enumerable` — св-во перечисляется в циклах / циклы его игнорируют.
      - `configurable` — св-во можно удалить, а эти атрибуты можно изменять / этого делать нельзя.
      - `get` — функция, срабатывает при чтении свойства. Без аргументов
      - `set` — функция, срабатывает при записи свойства. Принимает один аргумент
  - 
  - Когда мы создаём свойство «обычным способом», аттрибуты writable, enumerable, configurable = `true`.
  -
  -

  <img src="/Assets/Img/js-descriptor.jpg" title="Схема 1" alt="Схема 1" />
  
  <br></p>
  </details>

[//]: # (Методы)
- <details><summary><b>Методы</b></summary><p>

  - Методы для работы с аттрибутами:
    - Метод `Object.getOwnPropertyDescriptor` — получить информацию о свойстве.
    - Метод `Object.defineProperty.` — изменить свойство.
    - Метод `Object.defineProperties(obj, descriptors)` — определять N свойств сразу.
    - Метод `Object.getOwnPropertyDescriptors(obj).` — получить все дескрипторы свойств сразу.

  - Методы ограничения доступ ко всему объекту:
    - `Object.preventExtensions(obj)` — запрещает добавлять новые свойства в объект.
    - `Object.seal(obj)` — запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих
      свойств.
    - `Object.freeze(obj)` — запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable:
      false для всех существующих свойств.

  - Методы для их проверки свойств:
    - `Object.isExtensible(obj)` — возвращает false, если добавление свойств запрещено, иначе true.
    - `Object.isSealed(obj)` — возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств
      установлено configurable: false.
    - `Object.isFrozen(obj)` — возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих
      свойств установлено configurable: false, writable: false.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Дескрипторы свойств](https://behemothoz.gitbooks.io/js-learn/content/object/deskriptori-svoistv.html)
  - [learn.javascript.ru - Флаги и дескрипторы свойств](https://learn.javascript.ru/property-descriptors)
  - [learn.javascript.ru - Свойства - геттеры и сеттеры](https://learn.javascript.ru/property-accessors)
  - [Дока - Дескрипторы](https://doka.guide/js/descriptors/)
  - [Свойства объектов JavaScript](https://msiter.ru/tutorials/javascript/js_object_properties)
  - [Habr - Подводные камни JavaScript](https://habr.com/ru/post/159313)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Объекты. Преобразование объектов в примитивы todo: доработать)
<details id="objectToPrimitive"><summary><b>Объекты. Преобразование объектов в примитивы*</b></summary><p>

  - Вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве аргумента.
  
  - Существует всего 3 типа преобразований (хинтов):
    - `string` — для alert и других операций, которым нужна строка
    - `number` — для математических операций
    - `default` — для некоторых операций
  
  - В спецификации явно указано, какой хинт должен использовать каждый оператор. И существует совсем немного операторов, которые не знают, что   ожидать, и используют хинт со значением "default" . Обычно для встроенных объектов хинт "default" обрабатывается так же, как "number" . Таким   образом, последние два очень часто объединяют вместе.
  
  - Алгоритм преобразований к примитивам следующий:
    1. Сначала вызывается метод `obj[Symbol.toPrimitive](hint)` , если он существует.
    2. Иначе, если хинт равен "string" происходит попытка вызвать obj.toString() , затем obj.valueOf() , смотря что есть.
    3. Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf() , затем obj.toString() , смотря что есть.
  
  - На практике довольно часто достаточно реализовать только obj.toString() как «универсальный» метод для всех типов преобразований, возвращающий   «читаемое» представление объекта, достаточное для логирования или отладки.
  
  - **Ссылки:**
    - [learn.javascript.ru - Преобразование объектов в примитивы](https://learn.javascript.ru/object-toprimitive)

<br><p>
</details>

[//]: # (Объекты. Прототипы todo: доработать)
<details id="prototype"><summary><b>Объекты. Прототипы</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>
  
  - В JS объекты имеют скрытое «свойство» `[[Prototype]]` (внутренний слот объекта).
  - Оно либо равно `null`, либо ссылается на другой объект. Этот объект называется «прототип».
  - 
  - Хочу прочитать свойство в object, а оно отсутствует — JS ищет его в прототипе.
  - Такой механизм — «прототипное наследование». Это одна из основных особенностей языка JS.
  - Такие свойства — «прототипно унаследованные».
  - Позволяет объектам наследовать и расширять свойства и методы объектов родителей.
  - 
  - Каждый объект имеет внутреннюю ссылку на другой объект, называемый его «прототипом».
  - У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство `prototype` = `null`.
  - По определению, `null` не имеет прототипа и является завершающим звеном в цепочке прототипов.
  - 
  - Прототипную модель наследования иногда относят к недостаткам JS, но она мощнее классической. 
  - Поверх неё можно предельно просто реализовать классическое наследование.
  - А вот попытки совершить обратное вынудят вас попотеть.
  - 
  - 
  - Прототип можно рассматривать как связь между двумя объектами.
  - Связывание прототипа происходит при создании объекта; он связывается с другим, уже существующим объектом.
  - Серия объектов, связанных через их прототипы, называется «цепочкой прототипов».
  - Прототип используется только для чтения свойств. Операции записи/удаления работают напрямую с объектом, на прототип не влияют
  - Прототипы никак не влияют на `this`.
    - Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.
    - Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с   текущим объектом, даже если они наследуются.
    - [learn.javascript.ru - Прототипное наследование. Значение «this»](https://learn.javascript.ru/prototype-inheritance#znachenie-this)
  - Цикл `for...in` проходит по собственным и унаследованным свойствам объекта.
    - итерация происходит с учетом свойств в цепочке Prototype
    - Приходится проверять, принадлежит ли свойство этому объекту
    - Если унаследованные свойства не нужны, их можно отфильтровать встроенным методом `obj.hasOwnProperty(key)` — вернёт `true`, если у obj есть   собственное, не унаследованное, свойство с именем key.
    - Наследованное свойство отображается в цикле. только если оно перечислимо. То есть у него внутренний флаг `enumerable` стоит `true`.
  - Почти все остальные методы получения ключей/значений (Object.keys, Object.values и др.) игнорируют унаследованные свойства.
  - Длительное время поиска свойств, располагающихся относительно высоко в цепочке прототипов, может негативно сказаться на производительности (  performance), особенно в критических в этом смысле местах кода. Кроме того, попытка найти несуществующие свойства неизбежно приведёт к проверке на их наличие у всех объектов цепочки прототипов.
  - Кроме того, при циклическом переборе свойств объекта будет обработано каждое свойство, присутствующее в цепочке прототипов.
  - 
  - Одна из главных причин, по которым this поддерживает динамический контекст, основанный на том, как была вызвана функция — в том, что вызовы методов для объектов, делегируемые по цепочке прототипов, продолжают поддерживать ожидаемое значение this.
    - Создали некий корневой объект A, в нём определили метод, который использует this. Например `study() { console.log(`Please study ${ this.topic}`) }`
    - От объекта A создали два разных объекта B1 и В2, которые имеют своим прототипом объект А
    - В объектах B1 и B2 создали собственные свойства .topic с разными значениями: `B1.topic = 'Alfa'; B2.topic = 'Omega'`
    - Теперь вызываем `B1.study()` — получаем `Please study Alfa`
    - Теперь вызываем `B2.study()` — получаем `Please study Omega`
    - Т.е. метод B1.study() берётся из A.study(), но его ссылка this (this.topic) для этого выполнения преобразуется в B1, так что this.topic преобразуется в "Alfa". И так же с B2.
    - ```js
      var A = {
        study() {
          console.log(`Please study ${ this.topic }`);
        }
      };

      var B1 = Object.create(A);
      B1.topic = "Alfa";
      B1.study();
      // Please study Alfa
      
      var B2 = Object.create(A);
      B2.topic = "Omega";
      B2.study();
      // Please study Omega
      ```
  - Приведенный фрагмент кода был бы намного менее полезным, если бы ссылка this преобразовывалась в A. Впрочем, во многих других языках это будет именно A, потому что метод study() определяется для A.
  - В отличие от многих других языков, динамическая природа this в JS является критическим фактором, благодаря которому делегирование прототипам — и даже class — работает так, как ожидалось!
  - 
  - Если свойство объекта отсутствует, внутренняя связь `[[Prototype]]` объекта определяет, где операция Get должна продолжить поиск.
  - Система каскадных ссылок между объектами фактически определяет «цепочку прототипов» (нечто вроде иерархической цепочки областей видимости) объектов, которые должны перебираться при разрешении свойств.
  - У всех нормальных объектов на вершине цепочки прототипов находится встроенный объект `Object.prototype` (аналог глобальной области видимости при поиске в областях видимости), на котором останавливается разрешение свойств, не найденных в предыдущих звеньях цепочки. Объект `Object.prototype` содержит `toString()`, `valueOf()` и ряд других общих функций; это объясняет, почему они доступны для всех объектов в языке.
  - Самый распространенный способ связывания двух объектов — использование ключевого слова `new` с вызовом функции.
    - В результате создается новый объект, связанный с другим объектом.
    - «Другим объектом», с которым связывается новый объект, становится объект, на который указывает свойство с (неудачным) именем `.prototype` функции, вызываемой с `new`.
    - Функции, вызываемые с `new`, часто называются «конструкторами», хотя они и не пытаются создавать экземпляры классов, как это делают конструкторы в традиционных языках, ориентированных на использование классов.
    - Хотя эти механизмы JavaScript на первый взгляд напоминают «создание экземпляров» и «наследование классов» из традиционных языков, ориентированных на использование классов, ключевое различие заключается в том, что в JS копирование не производится. Вместо этого объекты связываются друг с другом по внутренней цепочке `Prototype`. По разнообразным причинам, в том числе из-за распространенной терминологии, «наследование» (и «наследование на основе прототипов»), а также все остальные ОО-термины просто не подходят для описания того, как реально работают механизмы JS. Правильнее здесь было бы использовать термин «делегирование», потому что отношения представляются не копиями, а связями делегирования.

  <br></p>
  </details>

[//]: # (Резюме)
- <details><summary><b>Резюме</b></summary><p>

  - «Прототипное наследование» — механизм языка. Позволяет объектам наследовать и расширять свойства и методы объектов-родителей.
  - Любой объект «под капотом» создаётся с помощью «класса» (функции-конструктора, new X()).
  - У любого объекта есть свойство `__proto__`
  - `__proto__` объекта ссылается на свойство `prototype` класса (функции-конструктора, `new X()`), которым этот объект был создан
    - Чтобы знать значение `__proto__` объекта — надо знать с помощью какой функции-конструктора он создан (new Object(), new Boolean(), ...)
  - `prototype` — обычное свойство, содержит объект со своим набором свойств и методов
    - свойство `prototype` (X.prototype) — есть у класса и функций (но не стрелочных)
    - это свойство = объект (иначе говоря «ссылается на объект»). У каждой конкретной функции этот объект свой.
  - зачем классу нужен `prototype` — чтобы созданные от него объекты могли наследовать методы и свойства
    - Хочу прочитать какое-то свойство в object, а оно отсутствует — JS ищет его в прототипе. И так вверх по цепочке
  - `[[Prototype]]` — внутренний слот объекта (похоже на скрытое свойство объекта) 
    - содержит ссылку на свойство `prototype` (т.е. на объект X.prototype)
    - Указывает на следующий прототип в цепочке (`null` если это последний прототип).
    - Его нельзя менять напрямую, предназначен для работы самого движка => появились методы для работы с ним.
  - 
  - ИТОГО
  - у всех функций (в том числе у всех классов) есть свойство `prototype`. Его нет только у стрелочных функций (у них нет this).
  - это свойство = объект. Или, другими словами, ссылается на объект. У каждой конкретной функции этот объект свой.
  - когда мы в JS создаем объект — мы всегда создаём его при помощи какого-то класса (функции-конструктора, `new X()`)
  - у созданного объекта всегда есть свойство `__proto__`
  - свойства `__proto__` под капотом работает с внутренним слотом `[[Prototype]]`
  - `__proto__`/`[[Prototype]]` ссылается на класс при помощи которого мы объект создали. Точнее — на объект содержащийся в его свойстве `prototype` (X.prototype).

  <br></p>
  </details>

[//]: # (Внутренний слот)
- <details><summary><b>Внутренний слот</b></summary><p>

  - В спецификации JS есть понятие `внутренний слот объекта` - туда интерпретатор сохраняет некоторые приватные данные объекта для работы с ним.
  - Как именно это реализовано спецификация не уточняет — создатели движка решают сами. Например, это может быть область памяти, или ещё что. Важно   чтоб это работало согласно спецификации, а что «под капотом» — не важно. <br>
  - Обозначается как `[[SlotName]]` (так же обозначаются `внутренние методы`).
  -
  - Внутренний слот не является свойством объекта и не наследуются.
  -
  - **Ссылки**
    - [Спецификация ECMAScript - 6.1.7.2. Object Internal Methods and Internal Slots](https://262.ecma-international.org/6.0/#  sec-object-internal-methods-and-internal-slots)

  <br></p>
  </details>

[//]: # (Свойства объектов — [[Prototype]], prototype, __proto__)
- <details><summary><b>Свойства объектов — [[Prototype]], prototype, __proto__</b></summary><p>

  - `[[Prototype]]` — внутренний слот объекта
    - Похоже на скрытое свойство объекта.
    - Указывает на следующий прототип в цепочке (`null` если это последний прототип).
    - Его нельзя менять напрямую, предназначен для работы самого движка => появились методы для работы с ним.
  -
  -
  - `prototype` — свойство объекта
    - У объектов
      - Единственное назначение — задавать `__proto__` для новых объектов.
      - Раньше не было прямого доступа к прототипу объекта. Надёжно работало только свойство "prototype" функции-конструктора. Используется во   многих старых скриптах.
      - Без вызова оператора `new` — вообще ничего не делает.
      - ```js
          function Rabbit(name) {
            this.name = name;
          }
          Rabbit.prototype = animal;
          var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal
        ```
      - `Rabbit.prototype = animal` говорит интерпретатору: «создавая объект через `new Rabbit` запиши ему `__proto__ = animal`».
      - В `prototype` можно записать что угодно. Но работать будет только если в него записан объект.
      - В `prototype` находится объект с одним свойством: `constructor: Rabbit`
    - У функций
      - При объявлении функции, у нее создается свойство `prototype` — чтобы ее можно было использовать как конструктор,
      - Свойство `prototype` функции не имеет отношения к прототипу самой функции, а задает прототипы для дочерних объектов.
      - По умолчанию ссылается на функцию-конструктор (т.е. на саму эту фукнцию?)
      - Это позволяет реализовывать наследование и добавлять новые методы
      - Используя это свойство можно добавлять прототипу методы и свойства `Car.prototype.saloon = (this.saloon = 'great')`
  -
  -
  - `__proto__` — свойство объекта.
    - Находится не в самом объекте, а в св-ве `Object.prototype`
    - Есть у всех объектов (кроме «простейших объектов» специально созданных через `Object.create(null)`)
    - Геттер/сеттер для `[[Prototype]]`
    - `__proto__` возвращает прототи
    - Устаревший метод — сейчас используют `Object.getPrototypeOf(obj)` и `Object.setPrototypeOf(obj, proto)`
    - Унаследовано от `Object.prototype` => когда в цепочке прототипов пропадает ссылка на `Object.prototype` (например `foo.__proto__ = null`) __  proto__ перестает работать с прототипом.
      - у нас есть объекты `A` и `B`.
      - установим — `B.__proto__ = A;`
      - уберем связь между `A` и `Object.prototype` — `A.__proto__ = null`
      - Связь с `Object.prototype` разорвана у `A` и `__proto__` возвращает undefined даже у дочернего объекта `B`,

  <br></p>
  </details>

[//]: # (Пример использования __proto__)
- <details><summary><b>Пример использования __proto__</b></summary><p>

  - ```js
    let animal = {
      eats: true
    };
    let rabbit = {
      jumps: true
    };
    
    rabbit.__proto__ = animal;
    ```
  -
  - Если мы ищем свойство или метод в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.

  <br></p>
  </details>

[//]: # (Свойство constructor)
- <details><summary><b>Свойство «constructor»</b></summary><p>

  - Указывает на функцию-конструктор, с помощью которой создавался объект.
  - Ссылка на функцию, с помощью которой был создан объект.
  - Содержится в свойстве `prototype`.
  - 
  - Можно его использовать для создания объекта с тем же конструктором, что и данный:
  - ```js
    var rabbit = new Rabbit("Кроль");
    var rabbit2 = new rabbit.constructor("Крольчиха");
    ```
  - 
  - Эта возможность бывает полезна, когда, получив объект, мы не знаем в точности, какой у него был конструктор (например, он мог быть взят из сторонней библиотеки), а нам необходимо создать ещё один такой объект.
  - 
  - Свойство `constructor` легко потерять.
  - Создаётся автоматически, а что с ним происходит дальше – это уже наша забота.
  - Если мы хотим, чтобы возможность получить конструктор, всё же, была, то можно при перезаписи гарантировать наличие `constructor` вручную
  - Чтобы сохранить верное свойство `constructor`, мы должны добавлять/удалять/изменять свойства у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком
  - Или мы можем заново создать свойство `constructor`
  - 
  - 
  - По сути свойство .constructor объекта указывает по умолчанию на функцию, которая взаимно содержит ссылку на этот объект — ссылку, которая называется .prototype. Слова «конструктор» (.constructor) и «прототип» (.prototype) имеют лишь неформальное значение по умолчанию, которое может оправдаться или не оправдаться в будущем. Лучшее, что вы можете, — почаще напоминать себе о том, что «конструктор» не означает «тот, кто сконструировал».
  - .constructor не является каким-то волшебным неизменяемым свойством. Это свойство неперечисляемое (см. предыдущий фрагмент), но оно разрешает запись (то есть может быть изменено). Более того, вы можете добавить или перезаписать (случайно или намеренно) свойство с именем constructor у любого объекта в любой цепочке [[Ptototype]] любым значением по своему усмотрению. Из-за правил обхода цепочки [[Prototype]] алгоритмом [[Get]] ссылка из свойства .constructor, где бы она ни находилась, может разрешаться совсем не так, как вы ожидаете.
  - Значение a1.constructor в высшей степени ненадежно, и полагаться на него в коде крайне небезопасно. Как правило, таких ссылок следует избегать
  - 
  - Оператор `instanceof` получает простой объект (левый операнд) и функцию (правый операнд). Он отвечает на вопрос: присутствует ли в цепочке `[[Prototype]]` для a объект, на который указывает `Foo.prototype`?
      - Вы можете запрашивать информацию о «происхождении» некоторого объекта (a), если у вас имеется функция (Foo с присоединенной ссылкой .prototype) для тестирования. 
  - Если у вас есть два произвольных объекта (допустим, a и b) и вы хотите определить, связаны ли объекты через цепочку [[Prototype]], оператор instanceof сам по себе не поможет.
  - Второй, намного лучший, подход к анализу связей `[[Prototype]]` выглядит так: `Foo.prototype.isPrototypeOf( a ); // true`
  - Обратите внимание: на этот раз функция Foo нам вообще не нужна. Нужен только объект (в данном случае произвольно названный Foo.prototype), который будет проверяться на родство с другим объектом. Вопрос, на который отвечает isPrototypeOf(..), выглядит так: встречается ли во всей цепочке [[Prototype]] объекта a объект Foo.prototype ?
  -

  - **Ссылки**
    - [learn.javascript.ru - F.prototype](https://learn.javascript.ru/function-prototype)
    - [learn.javascript.ru - Свойство F.prototype и создание объектов через new](https://learn.javascript.ru/new-prototype)
    - [Мальцев А - Создание объектов с помощью конструктора в JavaScript](https://itchief.ru/javascript/constructors)
    - [JS Advanced 1. Конструкторы и прототипы](https://gist.github.com/ncer/ea537927470b3c0b6bbd7a741e50d9fe)
    - [Habr - Прототипы в JS и малоизвестные факты](https://habr.com/ru/post/518360/)

  <br></p>
  </details>


[//]: # (Методы работы с прототипами)
- <details><summary><b>Методы работы с прототипами</b></summary><p>

  - `__proto__` - свойство. Устаревшее. Геттер/сеттер для `[[Prototype]]`
    - Указывает на следующий прототип в цепочке (`null` если это последний прототип).
  - `Object.getPrototypeOf(obj)` – возвращает значение свойства `[[Prototype]]` объекта obj.
  - `Object.setPrototypeOf(obj, proto)` – устанавливает свойство `[[Prototype]]` объекта obj как proto.
  - `Object.create(proto, [descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как proto, и
    необязательными дескрипторами свойств descriptors.
  -
  - Для изменения прототипа у существующего объекта есть всего два метода: использование сеттера `__proto__` и метод `Object.setPrototypeOf`

  <br></p>
  </details>

[//]: # (3 способа создать новый объект с прототипом Х)
- <details><summary><b>3 способа создать новый объект с прототипом Х</b></summary><p>

  - стандартный способ
    - `const foo = Object.create(myPrototype)`
    - метод Object.create позволяет создать объект, которому будут делегированы свойства и методы другого объекта
  - если нет поддержки `Object.create`, но есть `__proto__`
    - `const foo = { __proto__: myPrototype }`
  - если нет поддержки `Object.create` и нет поддержки `__proto__`
    - ```js
      const f = function () {}
      f.prototype = myPrototype;
      const foo = new f();
      ```
    - оператор `new` берет свойство `prototype` функции и использует его в качестве прототипа, т.е. устанавливает объект в `[[Prototype]]`

  <br></p>
  </details>

[//]: # (Цепочки прототипов)
- <details><summary><b>Цепочки прототипов</b></summary><p>

  - Можно строить цепочки прототипов.
  -
  - Ограничения цепочки прототипов:
    - Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
    - Значение `__proto__` может быть объектом или `null`. Другие типы игнорируются.

  <br></p>
  </details>

[//]: # (Функции, конструкторы, прототипы)
- <details><summary><b>Функции, конструкторы, прототипы</b></summary><p>

  - В большинстве языков функции — это синтаксические единицы, позволяющие выделить блок кода для повторного использования.
  - В JS функция — это ещё и тип данных.
  - Создавая функцию, мы создаем объект (сущность), в котором хранится поведение и ряд свойств.
  -
  - Как только мы создаём функцию, появляется связанный с ней объект `Prototype`.
  - Каждая функция содержит скрытое системное свойство `prototype` — связывает функцию-конструктор с прототипом
  - Каждый прототип содержит скрытое системное свойство `constructor` — связывает прототип с функцией-конструктором.
  -
  - Когда мы создаем новый объект (экземпляр), с помощью функции-конструктора (через ключевое слово new):
    - ключевое слово new создает пустой объект,
    - ключевое слово new создает в этом объекте скрытую системную ссылку `__proto__` — она связывает этот объект с его прототипом.
    - функция-конструктор заполняет пустой объект свойствами

  <br></p>
  </details>

[//]: # (Конструктор Object и его методы)
- <details><summary><b>Конструктор Object и его методы</b></summary><p>

  - Все объекты, которые создаются в JS наследуются от Object.
  - Т.е. имеют общую базовую функциональность, которая по наследству перешла от прототипа Object
  - 
  - В других языках наследование подразумевает копирование какой-то функциональности из родительского класса.
  - В JS мы указываем, что один объект связан с другим объектом посредством прототипов — у одного объекта есть прототип в виде другого объекта.
  - Object является прототипом для всех объектов, которые существуют в JS.
  - 
  - `Object.create(null)` создает объект, который не связывается с прототипом и поэтому является чисто автономным; в некоторых обстоятельствах такой способ может оказаться предпочтительным.

  <br></p>
  </details>

[//]: # (Расширение базовых прототипов)
- <details><summary><b>Расширение базовых прототипов</b></summary><p>

  - Одной из частых ошибок является расширение `Object.prototype` или других базовых прототипов.
  -
  - Такой подход называется `monkey patching` и нарушает принцип инкапсуляции.
  - Ранее он использовался в таких широко распространённых фреймворках, как например, `Prototype.js`, в настоящее время не существует разумных причин для его использования, поскольку в данном случае встроенные типы "захламляются" дополнительной нестандартной функциональностью.
  -
  - Единственным оправданием расширения базовых прототипов могут являться лишь `полифилы` - эмуляторы новой функциональности (например, `Array.forEach`) для не поддерживающих её реализаций языка в старых веб-браузерах.

  <br></p>
  </details>

[//]: # (Object.prototype)
- <details><summary><b>Object.prototype</b></summary><p>

  - цепочка `[[Prototype]]` проверяется по одному звену при выполнении различных операций поиска. Поиск останавливается при обнаружении свойства или завершении цепочки.
  - Любая нормальная цепочка `[[Prototype]]` завершается на встроенном объекте `Object.prototype`. 
  - Этот объект включает разнообразные стандартные возможности, используемые в JS, потому что все нормальные (встроенные, не являющиеся расширениями управляющей среды) объекты JS «происходят» от объекта `Object.prototype`. 
  - Этот объект находится на вершине их цепочки `[[Prototype]]`.
  - Примеры функциональности объекта `Object.prototype`:
  	- String()
  	- .valueOf()
  	- .hasOwnProperty(..)
  	- .isPrototypeOf(..)
  	- ...
  - 
  - Все функции по умолчанию получают открытое, не перечисляемое свойство с именем `prototype` — оно указывает на произвольный объект.
  - Этот объект часто называется «прототипом функции»
  - каждый объект, создаваемый вызовом `new funcName()`, наделяется связью через `[[Prototype]]` с этим объектом «funcName.prototype».

  <br></p>
  </details>

[//]: # ([[Prototype]] и «Цепочка прототипов»)
- <details><summary><b>[[Prototype]] и «Цепочка прототипов»</b></summary><p> 

  - Механизм `[[Prototype]]` представляет собой внутреннюю ссылку в объекте, которая указывает на другой объект. 
  - Эта связь (чаще всего) используется при обращении к свойству/ методу первого объекта, если выясняется, что такое свойство/метод в объекте не существует. В таком случае связь `[[Prototype]]` приказывает движку искать свойство/метод в связанном объекте. Если этот объект не может удовлетворить запрос, происходит переход по его ссылке `[[Prototype]]` и т. д. 
  - Последовательность связей между объектами образует так называемую «цепочку прототипов».

  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [IT-Kamasutra - prototype и __proto__ (YouTube)](https://youtu.be/b55hiUlhAzI)
  - [IT-Kamasutra - прототип prototype (YouTube)](https://youtu.be/QSy5LGMjMgg)
  - [Javascript-джедай #20 - Прототипы и наследование (YouTube)](https://youtu.be/4oudziatkLI)
  - [learn.javascript.ru - Прототипы](https://learn.javascript.ru/prototypes)
  - [Habr - Прототипы в JS и малоизвестные факты](https://habr.com/ru/post/518360/)
  - [learn.javascript.ru - F.prototype](https://learn.javascript.ru/function-prototype)
  - [learn.javascript.ru - Свойство F.prototype и создание объектов через new](https://learn.javascript.ru/new-prototype)
  - [Мальцев А - Создание объектов с помощью конструктора в JavaScript](https://itchief.ru/javascript/constructors)
  - [JS Advanced 1. Конструкторы и прототипы](https://gist.github.com/ncer/ea537927470b3c0b6bbd7a741e50d9fe)
  - [Спецификация ECMAScript - 6.1.7.2. Object Internal Methods and Internal Slots](`https://262.ecma-international.org/6.0/#  sec-object-internal-methods-and-internal-slots`)
  - [MDN - Object.prototype.__proto__](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
  - [MDN - Наследование и цепочка прототипов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Управляющие объекты)
<details id="funcDeclaration"><summary><b>Управляющие объекты</b></summary><p>

- Это переменные, которые определяются автоматически или иным образом создаются и передаются JS средой (браузер и т.д.)
- Пример
  - ```js
  	var а = document.createElement( "div" );
  	typeof а; // "object" - как и ожидалось
  	Object.prototype.toString.call( а ); // "[object HTMLDivElement)" — т.е. значение [[Class]] = "HTMLDivElement"
  	а.tagName; // "DIV"
    ```
  - Здесь `а` не просто объект, а специальный управляющий объект, потому что он является элементом `DOM`
- 
- Особенности
  - некоторые такие объекты существуют, но при преобразовании в boolean они дают false вместо ожидаемого значения true. См «Ложные объекты»
  - Недоступность нормальных встроенных средств `object` (таких, как `toString()`).
  - Невозможность перезаписи.
  - Некоторые предварительно определенные свойства, доступные только для чтения.
  - Наличие методов, которые не могут this-переопределяться для других объектов.
  - ...
- Console.log
  - Важный пример управляющего объекта - объект `console` и его различные функции (`log()`, `error()` и т. д.). 
  - -Объект `console` предоставляется средой размещения специально для того, чтобы ваш код мог взаимодействовать с ним для выполнения различных операций вывода, связанных с разработкой.

  - <br></p>
</details>

[//]: # (Коллекции — Map, Set, WeakMap, WeakSet)
<details id="collections"><summary><b>Коллекции — Map, Set, WeakMap, WeakSet</b></summary><p>

[//]: # (Коллекции Map)
- <details><summary><b>Коллекции Map</b></summary><p>

  - коллекция ключ/значение, как и Object. Позволяет использовать ключи любого типа, в том числе может использовать объекты в качестве ключей
  - 
  - Отличия от обычного объекта Object
    - Что угодно может быть ключом, в том числе и объекты.
    - Есть дополнительные методы, свойство size
  -
  - Как объект Map сравнивает ключи
    - Чтобы сравнивать ключи, объект Map использует алгоритм SameValueZero. Это почти такое же сравнение, что и ===, с той лишь разницей, что NaN   считается равным NaN. Так что NaN также может использоваться в качестве ключа.
  - 
  - Цепочка вызовов map.set
    - Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку
    - ```js 
      map.set("1", "str1")
      .set(1, "num1")
      .set(true, "bool1");
      ```
  - 
  - Перебор Map
    - `map.keys()`` – возвращает итерируемый объект по ключам,
    - `map.values()`` – возвращает итерируемый объект по значениям,
    - `map.entries()`` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
    - `forEach()` -  встроенный метод, похож на метод массива
    -
    - перебор Map происходит в том же порядке, в каком происходило добавление элементов.
    - перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но   поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
  -
  - Метод `Object.entries` - делает Map из Object. Можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации
  -
  - Метод `Object.fromEntries` - делает Object из Map
  -
  - Основные методы и свойства
    - `new Map()`
    - `map.set(key, value)` – записывает по ключу key значение value .
    - `map.get(key)` – возвращает значение по ключу или undefined , если ключ key отсутствует.
    - `map.has(key)` – возвращает true , если ключ key присутствует в коллекции, иначе false .
    - `map.delete(key)` – удаляет элемент по ключу key .
    - `map.clear()` – очищает коллекцию от всех элементов.
    - `map.size` – возвращает текущее количество элементов.
  
  <br><p>
  </details>

[//]: # (Коллекции Set)
- <details><summary><b>Коллекции Set</b></summary><p>

  - «множество» значений (без ключей), где каждое значение может появляться только один раз.
  - Основные методы
    - `new`
    - `add`
      - при повторных вызовах set.add() с одним и тем же значением ничего не происходит => каждое значение появляется один раз.
    - `delete`
    - `has`
    - `clear`
    - `size`
    -
  - Те же встроенные методы, что и Map :
    - `set.values()` – возвращает перебираемый объект для значений,
    - `set.keys()` – то же самое, что и set.values() , присутствует для обратной совместимости с Map ,
    - `set.entries()` – возвращает перебираемый объект для пар вида [значение, значение] , присутствует для обратной
      совместимости с Map
  -
  - Перебор Set
    - Метод `for..of` — `for (let value of set) alert(value)`
    - `forEach` — `set.forEach((value, valueAgain, set) => {...}`
    -
    - Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя
  - 
  - Альтернатива Set
    - массив для хранения значений + доп. код для проверки уже имеющегося элемента с помощью `arr.find` .
    - Но в этом случае будет хуже производительность, потому что arr.find проходит весь массив для проверки наличия элемента.
    - Множество Set лучше оптимизировано для добавлений, оно автоматически провеяется на уникальность
  
  <br><p>
  </details>

[//]: # (Коллекции WeakMap)
- <details><summary><b>Коллекции WeakMap</b></summary><p>

  - WeakMap — Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
  - ключи в WeakMap должны быть объектами, а непримитивными значениями
  - WeakMap не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
  - Если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.
  - 
  - Зачем нужен
    - В основном, WeakMap используется в качестве дополнительного хранилища данных.
      - Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то WeakMap – как раз то, что нужно.
    - Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его. Для хранения результатов мы можем использовать Map
    - WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet , то он будет удалён автоматически.
  - 
  - Методы:
    - `weakMap.get(key)`
    - `weakMap.set(key, value)`
    - `weakMap.delete(key)`
    - `weakMap.has(key)`
    - 
    - Не поддерживает перебор и методы `keys()` , `values()` , `entries(`) , так что нет способа взять все ключи или значения из неё.

  <br><p>
  </details>

[//]: # (Коллекции WeakSet)
- <details><summary><b>Коллекции WeakSet</b></summary><p>

  - можем добавлять в WeakSet только объекты (не примитивные значения). Set -подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.
  - WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.
  - Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
  - 
  - Поддерживает `add`, `has` и `delete`. Но не `size`, `keys()` и не является перебираемой.
  -
  - Зачем
    - служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет».Присутствие во множестве WeakSet может что-то сказать нам об объекте. Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт

  <br><p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Map и Set](https://learn.javascript.ru/map-set)
  - [learn.javascript.ru - WeakMap и WeakSet](https://learn.javascript.ru/weakmap-weakset)
  
  <br></p>
  </details>

<br><p>
</details>

[//]: # (Symbol)
<details id="symbol"><summary><b>Symbol</b></summary><p>

[//]: # (Определения)
- <details><summary><b>Определения</b></summary><p>

  - примитивный тип данных, экземпляры которого уникальны и неизменяемы. Для создания уникальных идентификаторов.
  - уникальное и неизменяемое примитивное значение, которое может быть использовано как ключ для свойства объекта.
  - представляет собой уникальный идентификатор

  <br></p>
  </details>

[//]: # (Применение)
- <details><summary><b>Применение</b></summary><p>

  - «Скрытые» свойства объектов
    - позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из
      других частей программы.
    - По спецификации, в качестве ключей для свойств объекта могут использоваться только String или Symbol.
    - Как: создать Symbol, а затем использовать сохранённое значение для создания свойства объекта.
      - ```js
        var myPrivateMethod = Symbol();
        this[myPrivateMethod] = function(){/**/};
        ```
    - Символьное свойство не появится в `for..in`, так что оно не будет нечаянно обработано вместе с другими.
    - Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе.
    - Таким образом, свойство будет защищено от случайной перезаписи или использования.
    - Используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.
    - Реальный кейс
      - Надо добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке — создаём символ и используем его в качестве ключа.
      - Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы. Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего, добавление поля к объекту не вызовет никаких проблем.
      - Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать собственный идентификатор в объект user. Этот скрипт может быть сторонней JS-библиотекой, абсолютно не связанной с нашим скриптом. Сторонний код может создать для этого свой символ Symbol("id"). Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, даже если их имена совпадают.
  - Есть 13 `системных символов`, используемых внутри JS, доступных как `Symbol.*.`
    - Используются, чтобы изменять встроенное поведение ряда объектов.
    - Например
      - `Symbol.iterator` для итераторов,
      - `Symbol.toPrimitive` для настройки преобразования объектов в примитивы и так далее.

  <br></p>
  </details>

[//]: # (Создание. Имя )
- <details><summary><b>Создание. Имя (описание)</b></summary><p>

  - Создаются вызовом функции `Symbol()`, в неё можно передать описание (имя) символа.
  - При создании символу можно дать описание (имя). Это просто метка, она ни на что не влияет. В основном используется для отладки кода:
  - ```js
    let id = Symbol("id"); // Создаём символ id с описанием (именем) "id"
    ```

  <br></p>
  </details>

[//]: # (Особенности)
- <details><summary><b>Особенности</b></summary><p>

  - Даже если символы имеют одно и то же имя, это – разные символы.
  - Описание – это просто метка, которая ни на что не влияет.

  <br></p>
  </details>

[//]: # (Глобальные символы)
- <details><summary><b>Глобальные символы</b></summary><p>

  - Есть глобальный реестр символов. Можем создавать в нём символы и обращаться к ним.
  - Такие символы называются глобальными
  - При каждом обращении нам гарантированно будет возвращаться один и тот же символ.
  - Используется если надо чтоб символы с одинаковыми именами были одной сущностью. Если нужен символ, доступный везде в коде.
  - Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.
  -
  - `Symbol.for(key)`
    - Для чтения/создания символа из реестра используется `Symbol.for(key)` — возвращает глобальный символ (или создаёт его) с `key` в качестве имени.
    - Многократные вызовы команды `Symbol.for` с одним и тем же аргументом возвращают один и тот же символ.
  -
  - `Symbol.keyFor(sym)`
    - Наоборот, принимает глобальный символ и возвращает его имя.

  <br></p>
  </details>

[//]: # (Системные символы)
- <details><summary><b>Системные символы</b></summary><p>

  - Существует 13 «системных» символов, использующихся внутри самого JS
  - Используются чтобы настраивать различные аспекты поведения объектов.
  - Перечислены в [спецификации JS](https://tc39.es/ecma262/#sec-well-known-symbols):
    - `Symbol.hasInstance`
    - `Symbol.isConcatSpreadable`
    - `Symbol.iterator`
    - `Symbol.toPrimitive` — позволяет описать правила для объекта, по которым он будет преобразовываться к примитиву
    - …

  <br></p>
  </details>

[//]: # (Сокрытие символов и доступ к ним)
- <details><summary><b>Сокрытие символов и доступ к ним</b></summary><p>

  - Технически символы скрыты не на 100%.
  - Есть встроенный метод `Object.getOwnPropertySymbols(obj)` – получить все свойства объекта с ключами-символами.
  - Есть метод `Reflect.ownKeys(obj)` — получить все ключи объекта, включая символьные.
  - Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.

  <br></p>
  </details>

[//]: # (Прочее)
- <details><summary><b>Прочее</b></summary><p>

  - Появились в ES6 (2015)
  - `Символьный объект` (symbol object) — это объект-обёртка для примитивного символьного типа.
  - Символы не преобразуются автоматически в строки
  - Символы игнорируются циклом `for…in`
  - `Object.assign`, в отличие от цикла `for..in`, копирует и строковые, и символьные свойства:
  - Чтобы использовать символ при литеральном объявлении объекта {...}, его надо заключить в квадратные скобки.
    - ```js
      let id = Symbol("id");
      let user = {
        name: "Вася",
        [id]: 123 // просто "id: 123" не сработает
      };
      ```
     - Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id»
  - Когда символ используется как идентификатор в присваивании свойства, свойство (например, символ) является анонимным; а
    также не исчислимым. Поскольку свойство не исчислимо, оно не будет отображаться в цикле «for (... in ...)», и поскольку
    свойство является анонимным, оно не будет отображаться в массиве результатов "Object.getOwnPropertyNames ()". Доступ к
    этому свойству можно получить с помощью исходного значения символа, создавшего его, или путём итерирования в массиве
    результатов «Object.getOwnPropertySymbols ()». В предыдущем примере кода доступ к свойству будет осуществляться через
    значение, которое было сохранено в переменной myPrivateMethod.

  -
  - Символические имена не являются объектами, это простые скалярные примитивы.
  - Они в основном создавались для специальных встроенных аспектов поведения конструкций ES6, но вы также можете определять собственные символические имена.
  - При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
    - ```js
      // Создаём символ id с описанием (именем) "id"
      let id = Symbol("id");
      ```
  - Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
  - Хотя символические имена не являются приватными (`Object. getOwпPropertySymbols( .. )` получает информацию об объекте и предоставляет символические имена вполне открыто), в первую очередь, они должны применяться для приватных или специальных свойств. Для большинства разработчиков они могут занять место имен свойств с префиксами_ (подчеркивание), что по соглашениям почти всегда означает: «Внимание! Приватное/ специальное/внутреннее свойство, не трогать!».
  - Встроенный «конструктор» Symbol ( .. ) уникален тем, что с ним нельзя использовать ключевое слово new, если вы попытаетесь это сделать, произойдет ошибка:
  - Символы не преобразуются автоматически в строки
    - `alert(mySymbol); // TypeError: Cannot convert a Symbol value to a string`
    - чтобы вывести в виде строки — используй `.toString()`
    - ```js
      let id = Symbol("id");
      alert(id.toString()); // Symbol(id), теперь работает
      ```

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Дока - Символ](https://doka.guide/js/symbol/)
  - [MDN - Symbol](https://developer.mozilla.org/ru/docs/conflicting/Web/JavaScript/Reference/Global_Objects/Symbol)
  - [MDN - Типы данных JavaScript и структуры данных](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)
  - [learn.javascript.ru](https://learn.javascript.ru/symbol)
  - [MDN - Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
  - [Habr - Особенности использования типа данных Symbol в JavaScript](https://habr.com/ru/company/ruvds/blog/444340/)

  <br></p>
  </details>

<br></p>
</details>


---


[//]: # (Циклы todo: дополнить)
<details id="cycles"><summary><b>Циклы *</b></summary><p>

- `Цикл` — конструкция языка для повторения операций, пока не будет вполнено некое условие

- `while` — многократное выполнение одних и тех же инструкций, пока истинно некоторое условие («под капотом» у него генератор)
  - Обычно циклы `while..true` крайне не рекомендуется использзовать, по крайней мере если они не содержат команды `break` или `return`. Такой цикл будет выполняться синхронно и полностью заблокирует пользовательский интерфейс браузера. 
  - Но такой цикл вполне допустим в генераторе, если он содержит `yield`. Генератор будет приостанавливаться при каждой итерации и возвращать управление основной программе и/или очереди цикла событий.
- `do... while` — вначале выполняется, потом проверяет условие. Точно выполнится один раз
- `for` — часто используется если известно точное количество повторений. «Цикл со счётчиком». («под капотом» у него `while`)
- `for ... in` — перебор свойств объекта
  - Лучше использовать только с объектами, а для перебора массивов — традиционные циклы `for` с числовыми индексами.
  - Применительно к массивам можеть дать неожиданные результаты — в перечисление массива включаются не только все числовые индексы, но и все перечисляемые свойства.
  - Ну и он заметно медленне альтернатив
  - Если перебирать содержимое объекта в цикле `for..in` — в перечисление будут включены все свойства, достижимые по цепочке `[[Prototype]]` (для которых разрешено перечисление).
  - Если проверять существование свойства объекта оператором `in` — он проверит всю цепочку объекта (независимо от перечисляемости).
- `for ... of` — перебор по массиву. Итерируемые объекты
- `for await of` — получение данных с помощью асинхронных итераторов. Перебор в цикле данных, поступающих асинхронно.
  Например: загружаем что-то по частям из сети.

- **Ссылки:**
  - [learn.javascript.ru - Циклы while и for](https://learn.javascript.ru/while-for)
  - [Дока - Циклы](https://doka.guide/js/loop/)
  - [MDN - Циклы и итерации](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Loops_and_iteration)
  - [Metanit - Циклы](https://metanit.com/web/javascript/2.7.php)
  - [Metanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
  - [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
  - [itchief.ru - Циклы в JavaScript](https://itchief.ru/javascript/loops)

<br><p>
</details>

[//]: # (Switch ... case todo: дополнить)
<details id="cycles"><summary><b>Switch ... case *</b></summary><p>

  - Конструкция `switch` заменяет собой сразу несколько `if`.
  - Более наглядный способ сравнить выражение сразу с несколькими вариантами.
    - ```js
      switch(x) {
        case 'value1':  // if (x === 'value1')
        ...
        [break]
      
        case 'value2':  // if (x === 'value2')
          ...
          [break]
      
        default:
        ...
        [break]
      }
      ```
  - Проверка совпадения выражения `а` с каждым выражением в `case` выполняется по правилам алгоритма `===`
    - ```js
      var а = "42";
        
      switch (a) {
        case 10:
          console.log( "10 or '10'" );
          break;
        case 42:
          console.log( "42 or '42'" );
          break;
        default:
          // для остальных случаев
      }
      // 42 или '42'
      ```
  - Если нужно равенство с преобразованием типов
    - ```js
        var а = "42";
  
        switch (true) {
          case а == 10:
            console.log( "10 or '10'" );
            break;
          case а == 42:
            console.log( "42 or '42'" );
            break;
          default:
            // сюда управление никогда не передается
        }
        // 42 или '42'
        ```
    - Такое решение работает, т.к. секция `case` может содержать любое выражение (а не только простые значения); 
      - результат этого выражения будет строго сравниваться с проверяемым условием (`true`). 
      - Так как `а == 42` дает `true`, совпадение будет успешно обнаружено.
    - **ОСТОРОЖНО!** Несмотря на `==`, сама проверка совпадения выполняется строго между `true` и `true` в данном случае. Если выражение `case` дает другое значение (истинное, но отличное от `true`), совпадения не будет. 
    - Этот факт может преподнести неприятный сюрприз, если в выражении, например, используется «логический оператор» `||` или `&&`:
        - ```js
            var а = "hello world";
            var b = 10;
            switch (true) {
                case (а || b == 10):
                    // сюда управление никогда не передается
                    break;
                default:
                    console. log( "Oops" ) ;
            }
            // Не работает
            ```
    - Так как выражение `(а || b == 10)` дает результат "hello world", а не `true`, строгая проверка завершается неудачей. 
    - Проблема решается явным приведением выражения к `true` или `false`. Например: `case !!(а || Ь == 10)`
  - 
  - **Ссылки**
    - [learn.javascript.ru - Конструкция "switch"](https://learn.javascript.ru/switch)

<br><p>
</details>

[//]: # (Логические операторы. Логические выражения. Truthy/Falsy)
<details id="logicalAssignment"><summary><b>Логические операторы. Логические выражения (truthy/falsy)</b></summary><p>

[//]: # (Логические операторы)
- <details><summary><b>Логические операторы</b></summary><p>

  - `&&` — и (and)
  - `||` — или (or)
  - `!` — не (not)
  - `??` — оператор нулевого слияния

  <br></p>
  </details>

[//]: # (Операторы «||» и «&&»)
- <details><summary><b>Операторы «||» и «&&»</b></summary><p>

  - Не обязательно дают boolean!
  - Они выдают значение одного (и только одного) из двух операндов. При этом он может быть не boolean.
  - ```js
    var а = 42;
    var b = "аЬс";
    var с = null;
    а || b; //  42
    а && b; // "аЬс"
    с || b; // "аЬс"
    с && b; // null
    ``` 
  - Операторы выполняют логическую проверку первого операнда (а или с). Если операнд не относится к типу `boolean` (как в данном случае), происходит нормальное преобразование к `ToBoolean` для выполнения проверки.
  - Оператор `||`
    - если условие истинно — результатом выражения `||` становится значение первого операнда (`а` или `с`).
    - если условие ложно — результатом выражения `||` становится значение второго операнда (`b`).
  - Оператор `&&` наоборот
    - если условие истинно, то результатом выражения `&&` становится значение второго операнда (`b`).
    - если же условие ложно, то результатом выражения `&&` становится значение первого операнда (`а` или `с`).
  -
  - На эти операторы можно взглянуть иначе:
    `а || b;` // приблизительно эквивалентно `а ? а : b;`
    `а && b;` // приблизительно эквивалентно `а ? b : а;`
  -
  - Популярное применение
    - ```js
      function foo(a,b) {
        а = а || "hello";
        b = b || "world";
        console.log( а + " " + b );
      }
      foo(); // "hello world"
      foo( "yeah", "yeah!" ); // "yeah yeah!"
    
      Но будьте внимательны!
      foo( "That's it!", "" ); // "That's it! world" <--Ой!
      ```
    - Видите проблему? `""` как второй аргумент является ложным значением (см. «ToBoolean»), поэтому проверка `b = b || "world"` не проходит, и    используется значение по умолчанию `"world"` - хотя, наверное, разработчик хотел, чтобы `b` было присвоено явно переданное значение `""`.
    -
  - Идиома `||` встречается очень часто, она очень полезна. Но ее следует использовать только в тех случаях, когда все ложные значения должны пропускаться! Т.е. если вместо первого операнда придёт `0`, `null`, `undefined`, `NaN` или `""`  — мы считаем их неверными и выбираем второй операнд (то что стоит справа от `||`)
  - Иначе проверку условия в данном случае нужно сформулировать более явно — например использовать тернарный оператор `? :` .

  <br></p>
  </details>

[//]: # (Оператор «??»)
- <details><summary><b>Оператор «??»</b></summary><p>
  
  - `??` — оператор нулевого слияния. Проверка на `null`/`undefined`.
  - если первый аргумент !=== `null`/`undefined` вернёт его, иначе второй.
  - `result = a ?? b,`
  - `result = (a !== null && a !== undefined) ? a : b;`
  - быстрый способ выбрать первое «определённое» значение из списка. Используется для присвоения переменным значений по умолчанию.

  <br></p>
  </details>

[//]: # (Логические выражения. Truthy/Falsy)
- <details><summary><b>Логические выражения. Truthy/Falsy</b></summary><p>

  - Выражения, в которых происходит неявное преобразование к логическому типу.
  - 
  - Примеры
    - проверка значения оператора `if` — `if (myVar) {}`
    - после логического оператора `!` — `!0`
    - с конструктором объектов логических значений — `new Boolean(0)`
    - в трёхкомпонентном сравнении — `myVar ? "truthy" : "falsy"`
    - 
    - Условие (вторая часть) в заголовке `for ( .. ; .. )`.
    - Условие в циклах `while ( .. )` и `do .. while( .. )`.
    - Левый операнд для операторов `||` или `&&` .

  - 
  - Значению присваивается `false`, если оно равно:
    - `false`;
    - `0`;
    - `" "` (пустая строка);
    - `null`;
    - `undefined`;
    - `NaN`.
  - 
  - Быть аккуратным при сравнении с объектами и массивами.
    - Значения объекта (которые должны стать истинными) не считаются логическими, но конвертируются в примитивный тип данных. 
    - При сравнении объекта с логическим значением, например [] == true, он преобразуется в [].toString() == true:
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>
  
  - [learn.javascript.ru - Логические операторы](https://learn.javascript.ru/logical-operators)
  - [learn.javascript.ru - Оператор нулевого слияния](https://learn.javascript.ru/nullish-coalescing-operator)
  - [Дока - Логические операторы](https://doka.guide/js/logic-operators/)
  - [tproger.ru - Шпаргалка по современному JavaScript. Truthy/Falsy](https://tproger.ru/translations/javascript-cheatsheet/#trthfls)
  - [Приведение типов](#objectReference)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Логические операторы присваивания «&&=», «||=», «??=»)
<details id="logicalAssignment"><summary><b>Логические операторы присваивания «&&=», «||=», «??=»</b></summary><p>

- `&&=`
  - Логическое «и»
  - `x &&= y` выполняет присваивание, только если `x` истинно
  - эквивалентно `x && (x = 2)`
  - ```js
    let a = 1;
    let b = 0;

    a &&= 2;
    console.log(a); // output: 2

    b &&= 2;
    console.log(b); // output: 0, т.к. Boolean(0) -> false, поэтому присваивания не происходит
    ```
  -  
- `||=`
  - Логическое «или»
  - `x &&= y` выполняет присваивание, только если `x` ложно
  - 
- `??=`
  - Логическое нулевое присвоение
  - `x ??= y` переназначает x, только x является `null` или `undefined`.
  - ```js
    const a = { limit: 50 };
    a.limit ??= 10;
    console.log(a.limit); // output: 50. Не выполняется, т.к. (a.limit = 50), что не является null или undefined.
    a.speed ??= 25;
    console.log(a.speed); // output: 25. Выполняется, т.к. a.speed первоначально имеет значение undefined
    ```
-
- Ссылки:
  - [Логические операторы присваивания (`&&=`, `||=`, `??=`)](https://techrocks.ru/2021/01/22/logical-assignment-operators-in-javascript/)

<br></p>
</details>

[//]: # (Побитовые операции)
<details id="typesTransformation"><summary><b>Побитовые операции</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.
  - 
  - Побитовое И (AND, `a & b`)
    - Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
    - Результат a & b равен единице только когда оба бита a и b равны единице.
  - Побитовое ИЛИ (OR, `a | b`)
    - Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
    - Результат a | b равен 1, если хотя бы один бит из a,b равен 1.
  - Побитовое исключающее ИЛИ (XOR, `a ^ b`)
    - Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
    - a Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно a=b=1.
    - Исключающее или можно использовать для шифрования, так как эта операция полностью обратима.
  - Побитовое НЕ (NOT, `~a`)
    - Заменяет каждый бит операнда на противоположный.
    - Производит операцию НЕ над каждым битом, заменяя его на обратный ему.
  - Левый сдвиг (`a << b`)
    - Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
    - Левый сдвиг почти равен умножению на 2
  - Правый сдвиг, переносящий знак (`a >> b`)
    - Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
    - Правый сдвиг почти равен целочисленному делению на 2
  - Правый сдвиг с заполнением нулями (`a >>> b`)
    - Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.
    - Для неотрицательных чисел правый сдвиг с заполнением нулями >>> и правый сдвиг с переносом знака >> дадут одинаковый результат, т.к. в обоих случаях слева добавятся нули. Для отрицательных чисел – результат работы разный.
  
  <br></p>
  </details>

[//]: # (У побитовых операторов низкий приоритет)
- <details><summary><b>У побитовых операторов низкий приоритет</b></summary><p>

  - Даже ниже, чем у присваивания - нужно ставить скобки.
  - Здесь `a == b^0` будет сначала выполнено сравнение `a == b`, а потом уже операция `^0`, как будто стоят скобки `(a == b)^0`.
  - Обычно это не то, чего мы хотим.
  - Чтобы гарантировать желаемый порядок, нужно ставить скобки: `a == (b^0)`.
  
  <br></p>
  </details>

[//]: # (Основные случаи применения)
- <details><summary><b>Основные случаи применения</b></summary><p>

  - Шифрование — XOR
  - Маска
  - Округление
    - Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления.
    - Достаточно взять любую операцию, которая не меняет значение числа.
    - Чаще всего `^0`
    - `alert( 12.345 ^ 0 ); // 12`
  - Проверка на −1. 
    - Применяя `побитовое НЕ (~)` можно легко проверить равенство n == -1
    - Проверка на -1 пригождается, например, при поиске символа в строке. Вызов str.indexOf("подстрока") возвращает позицию подстроки в str, или -1 если не нашёл.
  - Умножение и деление на степени 2
  - Упаковки нескольких битовых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором &.
  - Работа с микроконтроллерами, управлением памятью и другие ситуации, где уже реализовано использования двоичных представлений чисел.
  
  <br></p>
  </details>

[//]: # (Вспомогательные функции «parseInt» и «toString»)
- <details><summary><b>Вспомогательные функции «parseInt» и «toString»</b></summary><p>

  - `parseInt("11000", 2)` – переводит строку с двоичной записью числа в десятичное число.
  - `n.toString(2)` – получает для числа n запись в 2-ной системе в виде строки.
  
  <br></p>
  </details>

[//]: # (Отличие от логических операторов)
- <details><summary><b>Отличие от логических операторов</b></summary><p>

  - Не путать с логическими операциями
    - При использовании && происходит логическое сравнение, двух результатов,
      - например: `false && true = false`
    - При использовании & происходит побитовое сравнение, двух результатов,
      - например: `001 & 101 = 001`

  - При использовании `&&`, в случае, если результат равен `false`, дальнейшая проверка не выполняется.
    - Пример: 
      - `(false && a() && b())`. 
      - Методы `a()` и `b()` не будут вызваны, т.к. на первом месте стоит `false` и это означает что все выражение будет `false`.

  - При использовании `&`, в любом случае будут выполнены все проверки, т.к. побитовый сдвиг "надо делать с цифрами", а на этапе выполнения выражения, мы не можем предсказать результат.
    - Пример: 
      - `(false & a() & b())`
      - Методы `a()` и `b()` будут вызваны.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru — Побитовые операторы](https://learn.javascript.ru/bitwise-operators)
  - [Логическое и побитовое "И" (Java?)](https://it-rem.phpdev.one/logicheskoe-i-pobitovoe-i.html)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Опциональная цепочка «?.»)
<details id="optionalChaining"><summary><b>Опциональная цепочка «?.»</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Не оператор, а синтаксическая конструкция
  - Безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.
  - Позволяет без возникновения ошибок обратиться к вложенным свойствам.
  - Проверяет левую часть выражения на равенство `null`/`undefined`, и продолжает дальнейшее вычисление, только если это не так.
  - Переменная перед ?. должна быть объявлена. Если переменной `user` вообще нет, то `user?.anything` приведёт к ошибке
  -
  - Кроме этого, `?.` можно совместно использовать с `delete`:  `delete user?.name; // Удалить user.name, если пользователь существует`
  - 
  Три формы синтаксиса:
    - `obj?.prop` – возвращает `obj.prop`, если существует `obj`, и `undefined` в противном случае.
    - `obj?.[prop]` – возвращает `obj[prop]`, если существует `obj`, и `undefined` в противном случае.
    - `obj.method?.()` – вызывает `obj.method()`, если существует `obj.method`, в противном случае возвращает `undefined`
    
  <br></p>
  </details>

[//]: # (Использование в сокращённых вычислениях)
- <details><summary><b>Использование в сокращённых вычислениях</b></summary><p>

  - немедленно останавливает вычисление, если левой части не существует.
  - таким образом, последующие вызовы функций или операции не будут выполнены.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Вызовы «?.()» и «?.[]»</b></summary><p>

  - Используется для вызова потенциально несуществующей функции.
  - В следующем примере не у всех пользователей есть метод `admin`
  - ```js
    let userAdmin = {
      admin() {
        alert("Я админ");
      }
    };
    
    let userGuest = {};
    userAdmin.admin?.(); // Я админ
    userGuest.admin?.(); // ничего не произойдет (такого метода нет)
    ```
  
  <br></p>
  </details>

[//]: # (Не злоупотребляйте опциональной цепочкой)
- <details><summary><b>Не злоупотребляйте опциональной цепочкой</b></summary><p>

  - Следует использовать `?.` только там, где нормально, что чего-то не существует.
  - Например, если, в соответствии с логикой нашего кода, объект `user` должен существовать, но `address` является необязательным, то нам следует писать `user.address?.street`, но не `user?.address?.street`.
  - В этом случае, если вдруг `user` окажется `undefined`, мы увидим программную ошибку по этому поводу и исправим её. В противном случае, если слишком часто использовать `?.`, ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru — Опциональная цепочка '?.'](https://learn.javascript.ru/optional-chaining)
  
  <br></p>
  </details>


<br><p>
</details>

[//]: # (Оператор нулевого слияния «??»)
<details id="nullishCoalescing"><summary><b>Оператор нулевого слияния «??»</b></summary><p>

  - Быстрый способ выбрать первое «определённое» значение из списка.
  - Эквивалентно `result = (a !== null && a !== undefined) ? a : b;`
  -
  - Используется для присвоения переменным значений по умолчанию: 
    - `height = height ?? 100;`
    - height=100, только если переменная height равна null или undefined
  - 
  - Приоритет. Скобки
    - Оператор `??` имеет очень низкий приоритет (чуть выше чем `?` и `=`). Пори его использовании в выражении обычно нужны скобки.
    - Запрещено использовать вместе с `||` или `&&` без без скобок (т.е. явно указанного приоритета)
    - ```js
      let x = 1 && 2 ?? 3; // Синтаксическая ошибка
      let x = (1 && 2) ?? 3; // Работает без ошибок
      ```
  - 
  - **Ссылки**
    - [learn.javascript.ru - Оператор нулевого слияния (`??`)](https://learn.javascript.ru/nullish-operators)

<br></p>
</details>

[//]: # (Деструктуризация)
<details id="destruct"><summary><b>Деструктуризация</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - `Деструктурирование` — создание новых переменных путём извлечения данных из объектов и массивов.
  - Специальный синтаксис, который позволяет «распаковать» массивы или объекты в кучу переменных,
  -
  - Зачем
    - иногда удобнее работать не с элементами объекта/массива, а с отдельными переменными.
    - передаём объекты/массивы в функцию — ей может понадобиться не объект/массив целиком, а элементы по  
      отдельности
  - Также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
  -
  - Ничего не делает с исходным массивом/объектом, только копирует. Просто более короткий вариант записи
  - Пропускайте элементы, используя запятые
  - Работает с любым перебираемым объектом с правой стороны - Set и т.д.
  - Присваивайте чему угодно с левой стороны - например свойствам объекта
  
  <br></p>
  </details>

[//]: # (Пример для объекта)
- <details><summary><b>Пример для объекта</b></summary><p>


  ```js
  const person = {
    age: 35,
    firstName: "Nick",
    lastName: "Anderson",
    sex: "M"
  }

  const { age, firstName: first, city = "Paris" } = person; // деструктурирование

  console.log(age) // 35 — создана переменная age, которая равна person.age
  console.log(first) // "Nick" — создана переменная first, значение которой соответствует person.firstName
  console.log(firstName) // ReferenceError — person.firstName существует, но новая переменная называется first
  console.log(city) // Paris — создана переменная city, а поскольку person.city не определена, city равна заданному по умолчанию значению "Paris".
  ```
  
  <br></p>
  </details>

[//]: # (Пример для функций)
- <details><summary><b>Пример для функций</b></summary><p>

  ```js
    const person = {
      age: 35,
      firstName: "Nick",
      lastName: "Anderson",
      sex: "M"
    }
  
    //Без деструктуризации
    function joinFirstLastName(person) {
      const firstName = person.firstName;
      const lastName = person.lastName;
      return firstName + '-' + lastName;
    }
  
    //С деструктуризацией
    function joinFirstLastName({ firstName, lastName }) { // Создаём переменные, деструктурируя параметр person
      return firstName + '-' + lastName;
    }
  
    joinFirstLastName(person); // Nick-Anderson
  ```
  
  <br></p>
  </details>

[//]: # (Пример для массива)
- <details><summary><b>Пример для массива</b></summary><p>

  ```js
    const myArray = ["a", "b", "c"];
    const [x, y] = myArray; // деструктуризация
  
    console.log(x) // "a"
    console.log(y) // "b"
  ```
  
  <br></p>
  </details>


[//]: # (Пример для хука React)
- <details><summary><b>Пример для хука React</b></summary><p>

  - ```js
      const [fruit, setFruit] = useState('банан');
    ```
  - 
  - Такой синтаксис в JS называется «деструктуризацией массивов» (array destructuring).
  - Он означает, что мы создаём две новые переменные, fruit и setFruit.
  - Во fruit будет записано первое значение, вернувшееся из useState, а в setFruit — второе.
  - 
  - Это равносильно такому коду:
    - ```js
        var fruitStateVariable = useState('банан'); // Возвращает пару значений
        var fruit = fruitStateVariable[0]; // Извлекаем первое значение
        var setFruit = fruitStateVariable[1]; // Извлекаем второе значение
      ```
  - 
  - Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть массив из двух элементов. Первый элемент обозначает текущее значение, а второй является функцией, позволяющей менять это значение.
    
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Деструктуризация](https://learn.javascript.ru/destructuring)
  - [learn.javascript.ru - Деструктурирующее присваивание](https://learn.javascript.ru/destructuring-assignment)
  - [Деструктуризация в ES6. Полное руководство](https://medium.com/@stasonmars/%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%  8F-%D0%B2-es6-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-b865bb71f376)
  - [Habr - Вы не знаете деструктуризацию, пока](https://habr.com/ru/company/otus/blog/530248/)
  - [Medium - Learn the basics of destructuring props in React](https://www.freecodecamp.org/news/the-basics-of-destructuring-props-in-react-a196696f5477/)
  - [IT-Kamasutra #90 - Про деструктуризацию props в функциональных компонентах](https://youtu.be/JtbSOJKRJAI?t=1785)
  - [IT-Kamasutra #90 - Про деструктуризацию props в классовых компонентах](https://youtu.be/JtbSOJKRJAI?t=3352)
  - [Дэн Абрамов - Чем функциональные компоненты React отличаются от компонентов, основанных на классах? (см. про деструктуризацию props)](https://habr.com/ru/company/ruvds/  blog/444348/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Остаточные параметры и оператор расширения «...». Spread / Rest. Arguments)
<details id="spread"><summary><b>Остаточные параметры и оператор расширения («...»). Spread / Rest. Arguments</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - `Остаточные параметры` (Rest) — специальный синтаксис функции. Позволяет представлять неограниченное множество аргументов в виде массива.
  - Обозначается  `...`
  - Остаточные параметры должны располагаться в конце.
  - Были введены в ES6 для уменьшения количества шаблонного кода.
  
  - Если последний именованный аргумент функции имеет префикс `...`, он автоматически становится массивом с элементами от 0 до theArgs.length-1 в соответствии с актуальным количеством аргументов, переданных в функцию.
  
  - Если `...` располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
  - Иначе — это «оператор расширения»
  
  - ```js
      function showName(firstName, lastName, ...titles) {} //собери оставшиеся параметры функции и положи их в массив titles
    ```
    
  <br></p>
  </details>

[//]: # (Псевдомассив «arguments»)
- <details><summary><b>Псевдомассив «arguments»</b></summary><p>

  - Раньше вместо этого использовался псевдомассив `arguments`.
  - Считается устаревшим, и использовать его не   рекомендуется (особенно с параметрами `...` из ES6).
  -
  - Отличия остаточных параметров от объекта `arguments`:
    - остаточные параметры включают только те, которым не задано отдельное имя, в то время как объект arguments содержит все аргументы, передаваемые в функцию;
    - "arguments" не поддерживал методы массивов, например `map`. Остаточные параметры являются экземпляром Array — поддерживают методы sort, map, forEach или pop...
    - стрелочные функции не имеют "arguments". Но поддерживают остаточные параметры
    - объект arguments имеет дополнительную функциональность, специфичную только для него (например, свойство callee).
    
  <br></p>
  </details>

[//]: # (Деструктуризация остаточных параметров)
- <details><summary><b>Деструктуризация остаточных параметров</b></summary><p>

  - Остаточные параметры могут быть деструктурированы (только массивы). <br>
  - Т.е. их данные могут быть заданы как отдельные значения
  - ```js
      function f(...[a, b, c]) {
        return a + b + c;
      }
    ```
    
  <br></p>
  </details>

[//]: # (Оператор расширения. Spread)
- <details><summary><b>Оператор расширения. Spread</b></summary><p>

  - Извлекает элементы из массива (итерируемого объекта).
  - 
  - Если `...` располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
  - Иначе — это «оператор расширения»
  - 
  - Зачем используется:
    - «разобрать» массив на отдельные переменные `func(...arr)`
    - объединить несколько массивов или «влить» данные одного массива в другой `let newArray = [...arr1, ...arr2, 1]`
    - «влить» данные итерируемого объекта (массив и т .д.) в объект `let objClone = { ...obj };`
      - копирует собственные перечисляемые свойства данного объекта в новый объект. [Подробнее](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/    Spread_syntax#spread_%D0%B2_%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D0%B0%D1%85_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0)
    - превратить строку в массив символов `let symbArray = [...'Привет']; // П,р,и,в,е,т`
    
  <br></p>
  </details>

[//]: # (Итерируемый/перебираемый объект)
- <details><summary><b>Итерируемый/перебираемый объект</b></summary><p>

  - Все, что можно перебрать с помощью цикла `for..of`.<br>
    - массив
    - строка
    - Map
    - Set
    - TypedArray
    - Generator
    - объект, у которого есть метод `Symbol.iterator` — специальный встроенный Symbol, созданный как раз для этого.
  - 
  - Не путать с `псевдомассивом` — это объект, у которого есть индексы и свойство length (т.е. он выглядит как массив)
  - 
  - Ссылки
    - [Подробнее](#iterable)
    - [learn.javascript.ru — Перебираемые объекты](https://learn.javascript.ru/iterable)
    
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Остаточные параметры и оператор расширения / spread (...)](https://learn.javascript.ru/rest-parameters-spread-operator)
  - [MDN - Остаточные параметры (rest parameters)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Rest_parameters)
  - [Doka - Объект arguments](https://doka.guide/js/function-arguments-object/)
  - [Объект arguments](#funcArguments)
    
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Параметры функции по умолчанию todo:доработать)
<details id="funcDefParam"><summary><b>Параметры функции по умолчанию **</b></summary><p>

  ```js
    function myFunc(x = 10) {
      return x;
    }
    console.log(myFunc()) // 10 — не задано значение, поэтому значение x по умолчанию присвоено x в функции myFunc
    console.log(myFunc(5)) // 5 — значение задано, поэтому x=5 в функции myFunc
    console.log(myFunc(undefined)) // 10 — задано значение undefined, поэтому по умолчанию равно x
    console.log(myFunc(null)) // null — величина задана
  ```
  
  - **Ссылки**
    - [tproger.ru - Параметры функции по умолчанию](https://tproger.ru/translations/javascript-cheatsheet/#fnctdefparam)

<br></p>
</details>

[//]: # (Шаблонные строки/литералы. Теговые шаблоны)
<details id="tmpLiterals"><summary><b>Шаблонные строки / литералы. Теговые шаблоны</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Синтаксис для работы со строками.
  - Позволяет использовать выражения JS внутри строк (тип данных `string`).
  - Обозначается так: ```js `текст строки ${выражение JS, например переменная} ещё текст строки` ```
  - 
  - Может быть многострочной, все переносы строк в ней будут сохранены.
  - Будут сохранены все пробелы и табуляции в начале строк.
  - 
  - Внутри шаблонной строки любой нестроковый результат в js-выражении (объект, переменная и т.д) будет приведён к строке.

  <br></p>
  </details>


[//]: # (Зачем)
- <details><summary><b>Зачем</b></summary><p>
  
  - меньше возни с экранированием кавычек в строках (хотя символ `\`` всё равно надо экранировать, конечно)
  - можно делать переносы строк без спецсимвола `\n`
  - будут сохранены все пробелы и табуляции в начале строк
  - `строковая интерполяция` — можно выводить значения JS-выражений прямо в строку (при помощи конструкции ` ${}`). Раньше нужно было использовать конкатенацию через оператор `+` (`'строка 1' + someVariable + 'строка 2'`)
  - 
  - Пример
    - ```js
        `однострочная строка`
        
        `строка на
        несколько строчек,
        можно сколько угодно`
        
        `Дважды два равно ${2 * 2}`
        // Дважды два равно 4
        
        const name = 'Федя'
        `Привет ${name}!`
        // Привет Федя!
      ```

  <br></p>
  </details>


[//]: # (Вложенные шаблоны)
- <details><summary><b>Вложенные шаблоны</b></summary><p>

  - Когда внутрь шаблонной строки помещаем ещё одну, обернув ей в `${ }`.
  - ```js
      const classes = `header 
        ${ isLargeScreen()  ? ''  : `icon-${item.isCollapsed ? 'expander' : 'collapser'}` 
      }`;
    ````

  <br></p>
  </details>


[//]: # (Теговые шаблоны)
- <details><summary><b>Теговые шаблоны</b></summary><p>

  - Функция, которая позволяет разбирать шаблонную строку..
  - 
  - Первый аргумент этой функции — массив из кусочков строк, которые разделены выражениями `${}`.
  - Остальные параметры — значения выражений, которые подставляются в шаблонную строку.
  - Вызов функции производится не с использованием круглых скобок `funcName(data)`, а с помощью слитного написания шаблонной строки ```js funcName`data` ```.
  - 
  - В массиве из строк в конце находится кусочек в виде пустой строки.
  - Это нужно, чтобы количество элементов в массиве строк всегда было на один больше, чем количество подставляемых значений. 
  - Если бы в конце была бы ещё строка, то последним элементом была бы именно она.
  - 
  - Теговому шаблону необязательно возвращать строку — это обычная функция (вернуть можно что угодно, либо вообще ничего).
  - 
  - Можно создавать вспомогательные функции, например оборачивать параметры в html.
  - 
  - ```js
      var person = 'Mike';
      var age = 28;
      
      //Теговый шаблон
      function myTag(strings, personExp, ageExp) {
        var str0 = strings[0]; // "That "
        var str1 = strings[1]; // " is a "
        // Технически, в конце итогового выражения (в нашем примере) есть ещё одна строка, но она пустая (""), так что пропустим её.
        // var str2 = strings[2];
        var ageStr;
        
        if (ageExp > 99){
          ageStr = 'centenarian';
        } else {
          ageStr = 'youngster';
        }
        
        return `${str0}${personExp}${str1}${ageStr}`; // Мы даже можем вернуть строку, построенную другим шаблонным литералом
      }
      
      var output = myTag`That ${ person } is a ${ age }`;
      console.log(output); // That Mike is a youngster
    ```

  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [MDN - Шаблонные строки](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals)
  - [Doka - Шаблонные строки](https://doka.guide/js/template-strings/)
  - [tproger.ru - Шаблонные строки (шаблонные литералы). Теговые шаблоны](https://tproger.ru/translations/javascript-cheatsheet/#tmpltltrls)

  <br></p>
  </details>



<br></p>
</details>


---


[//]: # (Функции в JS. Процедуры.)
<details id="functions"><summary><b>Функции в JS. Процедуры.</b></summary><p>

- `Процедура` — набор команд, который может вызываться один или несколько раз, может получать входные данные и может возвращать одно или несколько значений.
- `Функции` — всегда возвращает значение. А процедура может возвращать, а может не возвращать.
- В JS понятия «функция» и «процедура» близки.
- 
- Функции JS = особая разновидность типов объектных значений
- независимо от того, как создаётся функция – она является значением!
  - Пример: `alert( sayHi )`
  - Здесь я не вызываю функцию `sayHi` (это выглядело бы как `sayHi()`). Я передал её, как обычное значение, в alert. 
  - Здесь alert не вызовет функцию, а выведет на экран её исходный код.
- 
- Из функции можно вернуть только одно значение (через `return`). Если надо вернуть N значений, их можно упаковать в объект/массив.
- Хорошим тоном в программировании является правило: одна функция – одно действие.
-
- В других языках программирования (например, тех, что придерживаются «функциональной» парадигмы) определение функции может быть намного строже. По сути — математическим. Подразумевает жесткий набор правил, которые должны соблюдаться.

- **Ссылки**
  - [MDN — Функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions)
  - [Hexlet — Функции и их вызов](https://ru.hexlet.io/courses/js-basics/lessons/calling-functions/theory_unit)
  - [learn.javascript.ru — Функции](https://learn.javascript.ru/function-basics)
  - [Flagman.top — Функции в JavaScript](https://flagman.top/js/funkcii-v-javascript)
  - [IT-шеф — Функции в JavaScript и классический способ их создания](https://itchief.ru/javascript/functions)
  - [IT-шеф — Функциональные выражения и стрелочные функции в JavaScript](https://itchief.ru/javascript/function-expression?ysclid=lnd1deqmpd110748509)
  - [Wiki — Функция в программировании](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
  - [Wiki — Функция в математике](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))

<br></p>
</details>

[//]: # (Функции и свойства объектов)
<details id="funcDeclaration"><summary><b>Функции и свойства объектов</b></summary><p>

- Тот факт, что функции в действительности являются объектами, имеет ряд важных следствий. Самое важное - то, что они могут обладать свойствами.
  - Пример:
    ```js
      function а(Ь,с) {/* ... */}

      a.length; // 2  
    ```
- У объекта функции есть свойство length, в котором хранится количество формальных параметров в объявлении этой функции: `a.length; // 2`

<br></p>
</details>

[//]: # (Объект arguments)
<details id="funcArguments"><summary><b>Объект arguments</b></summary><p>

- Получить доступ к аргументам в JavaScript можно не только с помощью параметров, но также посредством специального массивоподобного объекта `arguments`, доступ к которому у нас имеется внутри функции.
- Он также позволяет получить количество переданных аргументов.
- Доступ к аргументам через arguments выполняется точно также как к элементам обычного массива, т.е. по порядковому номеру: `arguments[0]`
- Получение аргументов через arguments в основном используется, когда мы заранее не знаем их точное количество. Например, создадим функцию, которая будет подсчитывать сумму всех числовых аргументов

  ```js
    function sum() {
      const num1 = arguments[0]; // получаем значение 1 аргумента
      const num2 = arguments[1]; // получаем значение 2 аргумента
      console.log(num1 + num2);
    }
  
    sum(7, 4); // 11
  ```

- **Ссылки**
  - [itchief.ru — Функции. Работа с аргументами через arguments](https://itchief.ru/javascript/functions#arguments)
  - [Остаточные параметры и оператор расширения «...». Spread / Rest. Arguments](#spread)

<br></p>
</details>

[//]: # (Function Declaration, Function Expression)
<details id="funcDeclaration"><summary><b>Function Declaration, Function Expression</b></summary><p>
  
[//]: # (Function Declaration)
- <details><summary><b>Function Declaration</b></summary><p>

  - Функция, объявленная в основном потоке кода.
  - `function sayHi() {...}`
  - «Объявления функции» создаются интерпретатором до выполнения кода. Поэтому их можно вызвать в коде до объявления. Т.е. вверху вызов функции, а ниже - её код
  - В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
  
  <br></p>
  </details>

[//]: # (Function Expression)
- <details><summary><b>Function Expression</b></summary><p>

  - Функции, объявленная в контексте какого-то выражения (например присваивания).
  - `var f = function() {...}`
  - `var f = function sayHi() {...}` //именованное функциональное выражение
  - «Функциональные выражения» создаются интерпретатором в процессе выполнения выражения, в котором созданы. В данном случае – функция будет создана при операции присваивания `var f = function...`
  - анонимные функции - частный случай Function Expression
  - 
  - В результате инициализации, к началу выполнения кода:
    - Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.
    - Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них.
  
  <br></p>
  </details>

[//]: # (Стрелочные функции)
- <details><summary><b>Стрелочные функции</b></summary><p>

  - особый случай анонимных Function Expression
  - ```js
    let func = (arg1, arg2, ...argN) => expression;
    
    //Это то же самое что
    let func = function(arg1, arg2, ...argN) {
      return expression;
    };
    ```
  - Помимо анонимности (и отсутствия декларативной формы), стрелочные функции => подчиняются тем же правилам лексической области видимости, что и функции function. Стрелочная функция (с фигурными скобками {..} вокруг ее тела или без них)все равно создает отдельную, внутреннюю вложенную область видимости. Объявления переменной в этой вложенной области видимости подчиняются тем же правилам, что и в функциональной области видимости.
  
  <br></p>
  </details>

[//]: # (Область видимости имени функции)
- <details><summary><b>Область видимости имени функции</b></summary><p>

  - При определении функции (declaration или expression) создается новая область видимости.
  - `function askQuestion() {...}` — такое объявление функции создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор с именем askQuestion.
  - `var askQuestion = function() {...}` — такое объявление создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор ПЕРМЕННОЙ с именем askQuestion.
    - Сама функция при этом не «поднимается» (см. Симпсон К - Вы не занете JavaScript. Книга 2. Область видимости и замыкания (2 изд) Глава 5).
    - у анонимных функциональных выражений нет идентификатора, влияющего на какую-либо из областей видимости.
  - `var askQuestion = function someName() {...}` — такое объявление создает во внешней области видимости (в данном случае это глобальная область видимости) идентификатор ПЕРМЕННОЙ с именем askQuestion. Пи этом someName объявляется как идентификатор в области видимости функции (условно), не поднимается наверх. Плюс к тому переменная someName определяется как доступная только для чтения.
  - Стрелочные функции являются лексически анонимными — в программе не существует напрямую связанного с ними идентификатора, который ссылается на функцию.
  
  <br></p>
  </details>

[//]: # (Анонимные и именованные функции)
- <details><summary><b>Анонимные и именованные функции</b></summary><p>

  - Если это технически возможно — всегда именуй функции. И IIFE (Immediately-invoked function expressions) тоже —
    - IIFE — способ эмулировать блочную видимость для `var`. Был популярен до появления `let` и `const`. Например, когда функция берётся в скобки и сразу вызывается)
  - Какие плюсы у именования:
    - проще работать со стэком отладки (будет выводиться доп. информация — имя функции)
    - лексические имена допускают ссылки на самих себя — важно для рекурсии и обработка событий (например удалить eventListener)
    - имена являются полезными описаниями;
  - Имена должны присваиваться даже однострочным функциям в командах `map(..)` и `then(..)`.
  
  <br></p>
  </details>

[//]: # (Когда использовать «Function Declaration», а когда «Function Expression»?)
- <details><summary><b>Когда использовать «Function Declaration», а когда «Function Expression»?</b></summary><p>

  - Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.
  - Также функции вида function f(…) {…} чуть более заметны в коде, чем let f = function(…) {…}. Function Declaration легче «ловятся глазами».
  - Но если Function Declaration нам не подходит по какой-то причине, или нам нужно условное объявление (мы рассмотрели это в примере выше), то следует использовать Function Expression.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [itchief.ru — Функции в JavaScript и классический способ их создания](https://itchief.ru/javascript/functions)
  - [itchief.ru — Функциональные выражения и стрелочные функции в JavaScrip](https://itchief.ru/javascript/function-expression)
  - [learn.javascript.ru - Function Declaration / Function Expression](https://learn.javascript.ru/function-expressions)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Стрелочные функции)
<details id="arrowFunc"><summary><b>Стрелочные функции</b></summary><p>

- Специальный синтаксис создания функций. Появились в ES6.

[//]: # (Особенности)
- <details><summary><b>Особенности</b></summary><p>

  - Не имеют своего `this`. Внутри стрелочных функций тот же `this`, что и снаружи. Удобно в обработчиках событий и коллбэках.
  - Не имеют своего `arguments`. Используются аргументы внешней «обычной» функции.
  - Не могут использоваться в качестве конструкторов, а также не могут иметь собственных свойств и методов, так как у них отсутствует свойство prototype, которое существует у обычных функций. При их вызове с оператором new система выдаст подобную ошибку.
  -
  - Не имеют лексических имен => лучше использовать стрелочные функции только по назначению: когда нужна функция с поведением лексического this.
  - Стрелочные функции вообще не определяют идентификатор `this` как ключевое слово.
  - Если вы используете `this` внутри стрелочной функции, это имя ведет себя точно так же, как любая другая ссылка на переменную — происходит поиск по цепочке областей видимости для нахождения области видимости функции (нестрелочной функции), где оно определяется, и использование найденной ссылки.
  - Т.е. стрелочные функции рассматривают `this` как любую другую лексическую переменную.
  - Если вы привыкли к трюкам типа var self = this или предпочитаете вызывать .bind(this) для внутренних функциональных выражений просто для того, чтобы унаследовать this от внешней функции, словно это лексическая переменная, то стрелочные функции => однозначно будут лучшим вариантом. Они проектировались специально для решения этой проблемы.
  -
  - Таким образом, в редких случаях, когда вам требуется поведение лексического this, используйте стрелочную функцию. Это лучший инструмент для решения вашей задачи. Но помните, что при этом вы соглашаетесь на все недостатки анонимных функций. Вам придется потратить дополнительные усилия, чтобы компенсировать снижение удобочитаемости — например, добавить в код содержательные имена переменных и комментарии.
  
  <br></p>
  </details>

[//]: # (Отличия от «.bind»)
- <details><summary><b>Отличия от «.bind(this)»</b></summary><p>

  - `.bind(this)` создаёт «связанную версию» функции.
  - Стрелка => ничего не привязывает. У функции просто нет this. При получении значения this – оно, как обычная переменная, берётся из внешнего лексического окружения.
  
  <br></p>
  </details>

[//]: # (Можно ли сделать «.bind» стрелочной функции?)
- <details><summary><b>Можно ли сделать «.bind()» стрелочной функции?</b></summary><p>

  - нет. У стрелочных функций нет `this`, он всегда будет определяться как контекст, в котором был определен.
  - Если требуется привязка this — надо использовать обычную функцию.
  - Ошибки не будет, просто не сработает (скорее всего)
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Стрелочные функции, основы](https://learn.javascript.ru/arrow-functions-basics)
  - [learn.javascript.ru - Повторяем стрелочные функции](https://learn.javascript.ru/arrow-functions)
  - [learn.javascript.ru](https://learn.javascript.ru/es-function)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (This. Контекст выполнения)
<details id="this"><summary><b>This. Контекст выполнения</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Ключевое слово `this` — текущий контекст исполнения функции.
  - Это ссылка на какой-то внешний объект, у которого я беру свойства или методы.
    - Ссылка на некий объект, к свойствам которого можно получить доступ внутри вызова функции.
  - На какой объект указывает эта ссылка — зависит от того как я вызываю функцию. Вызывая одну и ту же функцию разными способами я могу получать разные значения `this`
  - Значение `this` определяется во время исполнения кода.
  - При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
  -
  - Одна из главных причин, по которым this поддерживает динамический контекст, основанный на том, как была вызвана функция — в том, что вызовы методов для объектов, делегируемые по цепочке прототипов, продолжают поддерживать ожидаемое значение this.
    - Создали некий корневой объект A, в нём определили метод, который использует this. Например `study() { console.log(`Please study ${ this.topic}`) }`
    - От объекта A создали два разных объекта B1 и В2, которые имеют своим прототипом объект А
    - В объектах B1 и B2 создали собственные свойства .topic с разными значениями: `B1.topic = 'Alfa'; B2.topic = 'Omega'`
    - Теперь вызываем `B1.study()` — получаем `Please study Alfa`
    - Теперь вызываем `B2.study()` — получаем `Please study Omega`
    - Т.е. метод B1.study() берётся из A.study(), но его ссылка this (this.topic) для этого выполнения преобразуется в B1, так что this.topic преобразуется в "Alfa". И так же с B2.
    - ```js
      var A = {
        study() {
          console.log(`Please study ${ this.topic }`);
        }
      };

      var B1 = Object.create(A);
      B1.topic = "Alfa";
      B1.study();
      // Please study Alfa
      
      var B2 = Object.create(A);
      B2.topic = "Omega";
      B2.study();
      // Please study Omega
      ```
  - Приведенный фрагмент кода был бы намного менее полезным, если бы ссылка this преобразовывалась в A. Впрочем, во многих других языках это будет именно A, потому что метод study() определяется для A.
  - В отличие от многих других языков, динамическая природа this в JS является критическим фактором, благодаря которому делегирование прототипам — и даже class — работает так, как ожидалось!
  -
  - this - специальный идентификатор, который автоматически определяется в области видимости каждой функции.
  - Позволяет повторно использовать одни и те же функции для разных контекстов?
  - this не является ссылкой на саму функцию и не является ссылкой на лексическую область видимости функции.
  - Связывание this осуществляется не во время написания программы, а во время выполнения. Связывание является контекстным, то есть базируется на   условиях вызова функции. Связывание this не имеет никакого отношения к тому, где была объявлена функция, но полностью определяется способом вызова   этой функции.
  - Связывание this происходит в момент вызова функции, и то, на что ссылается this, определяется исключительно местом вызова, из которого была   вызвана функция.
  - При вызове функции создается запись активации, также называемая контекстом выполнения. Запись содержит информацию о том, откуда была вызвана   функция (стек вызовов), как она была вызвана, какие параметры были переданы при вызове и т. д. Одним из свойств этой записи является ссылка this,   которая используется на протяжении выполнения этой функции.
  - Связывание this осуществляется для каждого вызова функции на основании исключительно места вызова (то есть способа вызова функции).
  - Чтобы понять на что указывает this надо найти `место вызова` (call-site) - позицию кода, в которой **вызывается** функция (а не та, где она была   **объявлена**).
    - Место вызова - единственное, что влияет на связывание this.
      - При этом важно учитывать стек вызовов (то есть стек функций, которые были вызваны для того, чтобы выполнение дошло до своего текущего состояния). Место вызова, которое нас интересует, — вызов непосредственно перед текущей выполняемой функцией
    - для получения стэка вызова используй отладчик кода - debuger или breakpoint в функции, стэк которой я хочу получить.

  <br></p>
  </details>

[//]: # (Контекст выполнения)
- <details><summary><b>Контекст выполнения</b></summary><p>

  - У каждого вызова функции есть свой `контекст выполнения` (execution context).
  - Это служебная информация (реальный объект), которая соответствует текущему запуску функции. Определеяет «к чему может обращаться функция». Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
  - Одну и ту же функцию можно вызвать в разных контекстах => можем настроить разное поведение функции, в зависимости от того как её вызвали. (независимо от того, где она определена и даже откуда вызывается). Добавляет гибкости языку.
    - Функция, которая замыкается по области видимости, не может ссылаться на другую область видимости или набор переменных. Но функция с динамической контекстной зависимостью this может быть достаточно полезной для некоторых задач.
  - При любом вложенном вызове JS запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов»
  - `this-зависимая функция` — функция, которая зависит от своего `контекста выполнения` (т.е. использует `this`).

  <br></p>
  </details>

[//]: # (4 правила связывания «this»)
- <details><summary><b>4 правила связывания «this»</b></summary><p>

  1. Связывание «по умолчанию» — автономный вызовов функции.
  - Используется по умолчанию, если не применяется ни одно из других правил.
  - this указывает на глобальный объект
  - Имей ввиду — все переменные, объявленные в глобальной области видимости имеют синонимы в виде одноименных свойств глобального объекта (например windows).
  - Пример (non strict)
    ```js
  function foo() {
  console.log( this.a );
  }
  var a = 2;
  foo(); // 2
  ```
  - Если действует режим strict, глобальный объект не может использоваться для связывания по умолчанию - `this` вместо этого присваивается `undefined`:
  - Пример (strict)
    ```js
  function foo() {
  console.log( this.a );
  }
  var a = 2;
  foo(); // TypeError: `this` is `undefined`
  ```
  2. «Неявное связывание» — у места вызова имеется контекстный объект (или владелец/owner, или «содержащий объект»).
  - Место вызова использует контекст некоего объекта для создания ссылки на функцию
  - Чёткий признак: в точке вызова функции, ей имени будет предшествовать ссылка на некий объект.
  - Когда при обращении к функции указывается контекстный объект, правило неявного связывания требует, чтобы этот объект использовался для связывания this данного вызова функции.
  - Если у нас имеется цепочка объектов «через точку» — связывание осуществится с последним в цепочке (`obj1.obj2.foo();` — связывание будет с  obj2)
  -
  - Пример
    ```js
  function foo() {
  console.log( this.a );
  }
  var obj = {
  a: 2,
  foo: foo
  };
  obj.foo(); // 2
  ```
  - Неявная потеря this
    - когда функция с неявным связыванием теряет это связывание => обычно возвращает к связыванию «по умолчанию» (глобальный объект или undefined, в зависимости от режима strict).
    - Пример 1
      ```js
      function foo() {
        console.log( this.a );
      }
      var obj = {
        a: 2,
        foo: foo
      };
      var bar = obj.foo; // Ссылка на функцию/синоним! Не на obj.foo!
      var a = "oops, global"; // `a` также является свойством глобального объекта
      bar(); // "oops, global"
      ```
      - `bar` кажется ссылкой на `obj.foo`, в действительности это всего лишь еще одна ссылка на саму функцию `foo`.
      - Кроме того, важно только место вызова, а здесь оно имеет вид `bar() `— простой вызов без префикса, а следовательно, здесь применяется связывание по умолчанию.
    - Пример 2 — при передаче функции обратного вызова
      ```js
      function foo() {
        console.log( this.a );
      }
      function doFoo(fn) {
        // `fn` - просто еще одна ссылка на `foo`
        fn(); // <-- место вызова!
      }
      var obj = {
        a: 2,
        foo: foo
      };
      var a = "oops, global"; // `a` также является свойством глобального объекта
      doFoo( obj.foo ); // "oops, global"
      ```
      - Передача параметров — всего лишь неявное присваивание, а поскольку мы передаем функцию, происходит неявное присваивание ссылки. Поэтому конечный результат будет таким же, как в Примере 1.
      - Eсли передаваемая функция не написана вами, а встроена в язык? Ничего не меняется, результат будет тем же:
      ```js
      function foo() {
        console.log( this.a );
      }
      var obj = {
        a: 2,
        foo: foo
      };
      var a = "oops, global"; // `a` также является свойством глобального объекта
      setTimeout( obj.foo, 100 ); // "oops, global"
      ```
      - Потеря связывания this обратными вызовами — распространенное явление.
      - Возможны и другие сюрпризы — когда функция, которой передается обратный вызов, намеренно изменяет this для вызова.
        - Обработчики событий в популярных JavaScript нередко заставляют обратные вызовы иметь значение this, указывающее, например, на элемент DOM, инициировавший событие.
      - .
  3. Явное связывание — использовать методы `call` или `apply`. `bind`
  - Эти методы получают в первом параметре объект, который должен использоваться для this, а затем вызывают функцию с заданным значением this.  Мы напрямую указываем, какое значение должно быть присвоено this.
  - Этих методов может не быть у очень специфических встроенных функций в некоторых средах JS. Очень редкий случай.
  - Вызов foo с явным связыванием `foo.call(..) `позволяет принудительно задать его `this` значение `obj`. Пример: `foo.call(obj)`
  - В отношении связывания this поведение call(..) и apply(..) идентично. Они отличаются по дополнительным параметрам, но в настоящий момент этот вопрос для нас интереса не представляет.
  - Если передать простое примитивное значение (типа string, boolean или number) для связывания this, это примитивное значение будет преобразовано в объектную форму (new String(..), new Boolean(..) или new Number(..) соответственно). Часто это преобразование называется упаковкой (boxing).
  - К сожалению, явное связывание также не решает проблему, упоминавшуюся ранее — «потерю» функцией ее предполагаемого связывания this, замену его фреймворками и т. д.
  - Жесткое связывание — `bind`
    - приём на основе «явного связывания» — не даёт «потерять» связывание
    ```js
    function foo() {
      console.log( this.a );
    }
    var obj = {
      a: 2
    };
    var bar = function() {
      foo.call( obj );
    };
    
    // У жестко связанной функции `bar` значение `this` не может заменяться
    bar(); // 2
    setTimeout( bar, 100 ); // 2
    bar.call( window ); // 2
    ```
    - Мы создаем функцию `bar(),` которая во внутренней реализации вручную вызывает `foo.call(obj)`, принудительно вызывая foo со связыванием obj `для` `this`. Неважно, как позднее будет вызываться функция `bar` — она всегда вручную будет вызывать `foo` c `obj`.
    - Жесткое связывание является чрезвычайно распространенным паттерном, в ES5 для него была определена встроенная реализация `Function.prototype.bind`. Пример: `foo.bind(obj)`
    - `bind(..)` возвращает новую функцию, жестко запрограмированную для вызова исходной функции с заданным вами контекстом this.
    - Это связвание может быть переопределено через new
  - «Контексты» вызовов API
    - Функции многих библиотек, а также многие новые встроенные функции языка JavaScript и управляющей среды поддерживают необязательный параметр (обычно с именем context), который избавляет вас от необходимости использовать bind(), чтобы ваша функция обратного вызова гарантированно использовала конкретное значение this.
    ```js
    function foo(el) {
      console.log( el, this.id );
    }
    var obj = {
      id: "awesome"
    };
    // Использовать `obj` как `this` для вызовов `foo(..)`
    [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome
    ```
  4. Связывание через `new` — использование вызова-конструктора new
  - «Конструкторы»
    - В JS это обычные функции, которые вызываются с указанием оператора `new` перед ними.
    - Они не присоединяются к классам и не создают их экземпляры. Они даже не являются особой разновидностью функций. Это самые обычные функции, которые наделяются новым смыслом из-за использования `new` при их вызове.
    - Если вызывать любую функцию после оператора  `new` — этот вызов функции становится вызовом конструктора.
    - Понятия «функция-конструктор», не существует. Существуют «вызовы-конструкторы» функций.
    - При вызове-конструкторе функции происходит следующее
      - Создается (конструируется) новый объект.
      - Производится связывание сконструированного объекта с `[[Prototype]]`
      - Сконструированный объект назначается в качестве связывания `this` для этого вызова функции.
      - Если функция не возвращает свой альтернативный объект, вызов функции автоматически возвращает сконструированный объект.
    - Пример
      ```js
      function foo(a) {
        this.a = a;
      }
      var bar = new foo( 2 );
      console.log( bar.a ); // 2
      ```
    - Вызывая foo(..) после new, мы конструируем новый объект и назначаем его в качестве значения this для вызова foo(..).
  -
  -
  - **Приоритет правил**
    - сверху самое важное
    - Явное
    - New
    - Неявное
    - По умолчанию

  <br></p>
  </details>

[//]: # (4 варианта вызова функции в JS)
- <details><summary><b>4 варианта вызова функции в JS</b></summary><p>

  - 4 варианта вызова функции в JS
    - Обычный вызов функции:
      - `say('Hello!')`
      - в **use strict** — значение `this` ===  `undefined`.
      - без **use strict** — значение `this` === `глобальный объект`
      - даже если функция вложена в другую функцию - ничего не меняется. Undefined или глобальный объект.
        - Контекст внутренней функции зависит только от вызова, а не от контекста внешней функции. Пример вызвал метод
          объекта, в нём this === объект, всё ок. Вызвал в этом методе функцию, а в ней обратился к this - и тут уже this ===
          undefined/глобальный объект.
        - Чтобы получить ожидаемый this, модифицируйте контекст внутренней функции при помощи непрямого вызова (`.call()` /
          `.apply()`) или создайте связанную функцию через `.bind()`
    - Функция является методом объекта
      - `user.say('Hello!'),`
      - this === объект
      - this определяется в момент вызова функции. Если записать метод объекта в переменную и вызвать её без указания
        объекта — теряем привязку к объекту. Нужен `bind`
      -
      - Методы могут ссылаться на объект (в котором они вызваны) через `this`.
      - Функция может быть скопирована между объектами (из одного объекта в другой).
      - Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object. Т.е. `this` = слово слева от точки :)
    - Вызов функциии-конструктора
      - `new User()`
      - `this` === свежесозданному объекту, созданному конструктором.
      - конструктор — это функция для создания однотипных объектов.
      - конструкторы вызывают с помощью ключевого слова `new`
      - начиная с ECMAScript 6, JS позволяет определять конструкторы ключевым словом `class`
    - Непрямой вызов функции (через `call()` или `apply()`)
      - `say.call(undefined, 'Hello!')`, `say.apply(undefined, 'Hello!')`
      - Оба позволяют настроить контекст снаружи явным образом — первым аргументом принимают `this`.
    - Ещё есть метод `bind`
      - `say('Hello!').bind(admin)`,
      - позволяет связывать контекст выполнения с функцией — «заранее и точно» определить, каким будет значение `this`

  <br></p>
  </details>

[//]: # (Алгоритм — как узнать связывание «this» для конкретной функции)
- <details><summary><b>Алгоритм — как узнать связывание «this» для конкретной функции</b></summary><p>

  - Находим место вызова функции (не объявления, а вызова)
  - К этому месту применяем вопросы:
  1. Функция вызвана с `new`?
  - Связывание new
  - Если да, — `this` содержит новый сконструированный объект.
  2. Функция вызвана с `call`, `apply` или `bind`?
  - Явное связывание
  - Если да — `this` содержит явно заданный объект.
  3. Функция вызвана с контекстом  (объектом-владельцем / содержащим объектом)?
  - Неявное связывание
  - Если да — `this` содержит контекстный объект.
  4. В остальных случаях используется this по умолчанию.
  - Привязка по умолчанию
  - Если действует режим strict — выбирается undefined
  - Если нет режима strict — выбирается глобальный объект

  <br></p>
  </details>

[//]: # (Стрелочные функции и `this`)
- <details><summary><b>Стрелочные функции и «this»</b></summary><p>

  - Принимают связывание `this` от внешней области видимости (функциональной или глобальной). Вместо четырех стандартных правил `this`.
  - Лексическое связывание стрелочной функции не может быть переопределено (даже с new).
  - Вероятно, самый распространенный сценарий использования стрелочных функций — это обратные вызовы (например, при использовании обработчиков событий или таймеров)
  -
  - У стрелочных функций нет `this`.
  - Когда внутри стрелочной функции обращаются к `this`, то его значение берётся извне. Функция связывается с ближайшим по иерархии контекстом, в котором она определена.
  - Удобно, когда нужно передать в стрелочную функцию, например, родительский контекст без использования `bind()`
  - При использовании обычной функции внутри контекст бы потерялся, и чтобы добиться того же результата, нам бы пришлось использовать `call()`, `apply()` или `bind()`
  -
  - Паттерн с использованием `var self = this;` — очень близкий аналог стрелочных функций. Bз времён «до ES6»
  -
  - Хотя стрелочные функции предоставляют альтернативу для использования bind(..) с функциями для обеспечения нужного значения this, что кажется привлекательным, важно заметить, что по сути они блокируют традиционный механизм this в пользу более понятной лексической области видимости.
  - Хотя и self = this, и стрелочные функции могут показаться хорошими «решениями» для тех, кто не хочет использовать bind(..), на самом деле это попытки сбежать от конструкции this, вместо того чтобы попытаться понять и принять ее.
  - Если вы пишете код «в стиле this», но в большинстве случаев подавляете этот механизм лексическим self = this или «трюками» со стрелочными функциями, возможно, вам стоит выбрать один из следующих вариантов:
    1. Использовать только лексическую область видимости и забыть о пустых претензиях на код «в стиле this».
    2. Полностью принять механизмы this, включая использование bind() там, где это необходимо, и по возможности избегать self = this и трюков со стрелочными функциями.

  <br></p>
  </details>

[//]: # (Отличия «bind», «call» и «apply»)
- <details><summary><b>Отличия «bind()», «call()» и «apply()»</b></summary><p>

  - `bind` - создаёт "обёртку" над функцией, которая подменяет контекст этой функции. Поведение похоже на `call` и `apply`, но, в отличие от них,   `bind` не вызывает функцию, а лишь возвращает "обёртку", которую можно вызвать позже.
  - `call` - вызов функции с подменой контекста (`this`) внутри функции.
  - `apply` - вызов функции с переменным количеством аргументов и с подменой контекста.

  <br></p>
  </details>

[//]: # (Также смотри темы)
- <details><summary><b>Также смотри темы</b></summary><p>

  - [Замыкания, Lexical Environment и [[Environment]]](#closures)
  - [Стрелочные функции](#arrowFunc)
  - [Call, apply](#callApply)
  - [Bind](#bind)
  - [Глобальный объект](#gloablObject)
  - [Use strict](#useStrict)
  - [Прототипы объектов](#prototype)
  - [Модули](#modules)
  - [Callback](#callback)

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Методы объекта, "this"](https://learn.javascript.ru/object-methods)
  - [learn.javascript.ru - Стрелочные функции](https://learn.javascript.ru/arrow-functions)
  - [О ключевом слове «this» языка JavaScript: особенности использования с пояснениями](https://tproger.ru/translations/javascript-this-keyword/)
  - [MDN - this](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)
  - [Дока - this: контекст выполнения функций](https://doka.guide/js/function-context/)
  - [Habr - Что записано в this? Закулисье JavaScript-объектов](https://habr.com/ru/company/ruvds/blog/455527/)
  - [Habr - Ключевое слово this в JavaScript для начинающих](https://habr.com/ru/company/ruvds/blog/419371/)
  - [Habr - Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/company/ruvds/blog/422089/)

  <br></p>
  </details>


<br></p>
</details>

[//]: # (Bind)
<details id="bind"><summary><b>Bind</b></summary><p> 

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Метод. Позволяет привязать контекст к функции. Важно при callback
  - 
  - Создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this
  - предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в
  - привязанную функцию аргументами при её вызове.
  - 
  - При вызове callback может нарушиться контекст вызова this.
  - Т.е. отвалиться привязка this к родительскому объекту.
  - 
  - ```js
      <App
        addQuote={store.addQuote} //нет скобок после addQuote - функция не выполянется здесь, а передаётся на выполение
      />
    ```
  -
  - Не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо, от своего имени.
  - В таком случае, при создании `callback` надо сделать привязку контекста - `bind`
  - ```js 
      <App
          addQuote={store.addQuote.bind(store)}
      />
    ```
  
  <br></p>
  </details>

[//]: # (Отличия «bind», «call» и «apply»)
- <details><summary><b>Отличия «.bind()», «call()» и «apply()»</b></summary><p>

  - `bind` - создаёт "обёртку" над функцией, которая подменяет контекст этой функции. Поведение похоже на `call` и `apply`, но, в отличие от них, `bind` не вызывает функцию, а лишь возвращает "обёртку", которую можно вызвать позже.
  - `call` - вызов функции с подменой контекста (`this`) внутри функции.
  - `apply` - вызов функции с переменным количеством аргументов и с подменой контекста.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - bind](https://learn.javascript.ru/bind)
  - [code.mu - dind](http://code.mu/javascript/context/bind.html)
  - [Habr - Bind, Call и Apply в JavaScript (2013)](https://habr.com/ru/post/199456/)
  - [MDN - Function.prototype.bind()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # («Call» & «apply» todo: доработать)
<details id="callApply"><summary><b>«Call» & «apply» *</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>
  
  - Методы для явного указания `this` функций
  - 
  - Мы сами устанавливаем контекст, в котором выполняется функция. <br>
  - Когда мы используем ключевое слово `this` внутри нашей callback-функции, оно ссылается на то, что мы передаём первым
  - аргументом в `call()/apply`
  -
  - `call` — позволяет вызывать функцию, явно устанавливая `this`. Вызывает func с данным контекстом и аргументами. Можно
    заимствовать методы.
  - `apply` — более мощный метод. Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию.
    Вызывает func, передавая context как this и псевдомассив args как список аргументов.
  
  <br></p>
  </details>

[//]: # (Отличия «bind», «call» и «apply»)
- <details><summary><b>Отличия «bind()», «call()» и «apply()»</b></summary><p>

  - `bind` - создаёт "обёртку" над функцией, которая подменяет контекст этой функции. Поведение похоже на `call` и `apply`, но, в отличие от них, `bind` не вызывает функцию, а лишь возвращает "обёртку", которую можно вызвать позже.
  - `call` - вызов функции с подменой контекста (`this`) внутри функции.
  - `apply` - вызов функции с переменным количеством аргументов и с подменой контекста.
  
  <br></p>
  </details>

[//]: # (Про колбек todo: уточнить)
- <details><summary><b>Про колбек (уточнить)</b></summary><p>

  - Функции `call()` и `apply()` - один из способов вызова callback-функции.<br>
  - Здесь мы сами устанавливаем контекст, в котором выполняется функция. <br>
  - Т.е. когда мы используем ключевое слово `this` внутри нашей callback-функции, оно ссылается на то, что мы передаём первым аргументом в `call()`/`apply()`.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru](https://learn.javascript.ru/call-apply-decorators)
  - [Habr - Bind, Call и Apply в JavaScript (2013)](https://habr.com/ru/post/199456/)
    
  <br></p>
  </details>

<br></p>
</details>   

[//]: # (Модули todo: упростить)
<details id="modules"><summary><b>Модули</b></summary><p>

[//]: # (Определения)
- <details><summary><b>Определения</b></summary><p>

  - `Модуль`— набор взаимосвязанных данных и функций (здесь их можно назвать `методами`).
    - Эти данные и методы четко разделены на `приватные` и `открытые`.
    - Модуль обладает `состоянием` — поддерживает некую информацию во времени + функциональность для чтения/обновления этой информации.
    - 
    - Модуль подразумевает
      - группировка данных вместе с функциями
      - функции обладают состоянием (в модуле есть не только функции, но и некоторые данные, с которыми они работают)
      - есть управление доступом через видимость (приватные/открытые части).
    - 
    - Это эффективный способ структурирования и организации функциональности и данных программы.
    - В широком смысле паттерн «Модуль» обеспечивает модуляризацию на системном уровне за счет слабых связей и других средств программной архитектуры. Большая тема.
  - 
  - переиспользуемая часть кода, содержащая в себе детали реализации и предоставляющая открытое API (позволяет легко
    загрузить её и использовать в другом коде).
  - Модуль – это просто файл. Один скрипт – один модуль. Модули могут загружать друг друга и использовать
    директивы `export` и `import`, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого.
  - 
  - `Инкапсуляция` — совместное размещение информации (данных) и поведения (функций), служащих общей цели.
  - `Принцип наименьшего раскрытия` — переменные (и функции), зарегистрированные в каждой области видимости, должны раскрываться наименьшим необходимым образом (см раздел «Область видимости»)

  <br></p>
  </details>

[//]: # (Почему потребовались модули)
- <details><summary><b>Почему потребовались модули</b></summary><p>

  - Коллизия имён - два разных скрипта могут объявлять одинаковые названия функций и переменных. И затирать друг-друга
  - Поддержка большой кодовой базы - в приложении сотни скриптов. Если каждый подключать вручную с помощью тэга `<script>` — управлять этим трудно.
  - 

  <br></p>
  </details>

[//]: # (Паттерны «модуль» и «класс»)
- <details><summary><b>Паттерны «модуль» и «класс»</b></summary><p>

  - Это паттерн для группировки данных и поведения в логических единицах. Для организации кода. Так же как и паттерн «класс»
  - Синтаксис модулей введён в ES6 (ECMAScript 2015), одновременно с классами.
  - Но паттерн «модуль» использовался в ES с первых дней существования. Просто в другом синтаксисе.
  - Паттерны «модуль» и «класс» не являются взаимоисключающими: во многих программах можно и нужно использовать оба.

  <br></p>
  </details>

[//]: # (Модульность решает задачи)
- <details><summary><b>Модульность решает задачи</b></summary><p>

  - обеспечение поддержки изоляции кода
  - определение зависимостей между модулями и легкое управление ими
  - доставка кода в среду выполнения.

  <br></p>
  </details>

[//]: # (Модули — классический синтаксис)
- <details><summary><b>Модули — классический синтаксис</b></summary><p>


  - Определение `классического модуля`
    - Должна существовать внешняя область видимости — обычно от функции-фабрики модулей, выполняемой хотя бы один раз.
    - Внутренняя область видимости модуля должна содержать хотя бы один блок скрытой информации, представляющей состояние модуля.
    - Модуль должен возвращать через свой открытый API ссылку на хотя бы одну функцию, которая содержит замыкание на скрытое состояние модуля (чтобы это состояние сохранялось после вызова).
  - Главные признаки «классического модуля»:
    - внешняя функция (выполняется один раз или более), 
    - она возвращает экземпляр модуля 
    - в экземпляре модуля есть одной или более функций, способных работать с внутренними (скрытыми) данными экземпляра модуля.

  <br></p>
  </details>

[//]: # (Модули — старые реализации)
- <details><summary><b>Модули — старые реализации</b></summary><p>

  - ДО ES6 были реализации модулей сторонними библиотеками:
    - AMD – одна из самых старых модульных систем, изначально реализована библиотекой require.js.
    - CommonJS – модульная система, созданная для сервера Node.js.
    - UMD – ещё одна модульная система, предлагается как универсальная, совместима с AMD и CommonJS.

  <br></p>
  </details>

[//]: # (Модули — синтаксис ES/ESM)
- <details><summary><b>Модули — синтаксис ES (ESM)</b></summary><p>

  - решают те же вопросы что и «классические модули»
  - Отличия от «классического модуля»
    - нет функции-обертки для определения модуля. Вместо обертки —  весь файл.
      - Модули ESM всегда базируются на файлах: один файл — один модуль.
    - Не обязательно явно взаимодействовать с API модуля
      - достаточно воспользоваться ключевым словом `export`, чтобы добавить переменную или метод в его определение открытого API.
      - Если нечто определяется в модуле, но не экспортируется, то оно остается скрытым (как и с классическими модулями).
        - мы не создаем экземпляр модуля ES, а просто импортируете его для использования его единственного экземпляра
          - Это самое заметное отличие от паттернов, упоминавшихся ранее.
          - Модули ESM являются Singleton (порождающий паттерн проектирования) — в программе они существуют только в единственном экземпляре, который создается при первом импортировании. Все последующие команды импортирования просто получают ссылку на тот же экземпляр.
          - Если ваш модуль должен существовать в нескольких экземплярах, то придется предоставить фабричную функцию в стиле классических модулей для вашего определения ESM.

  - Призанки и особенности
    - базируется на файлах
    - экземпляры модулей являются одиночными
      - Сколько бы раз вы ни вызывали `import(..)` для одного модуля, вы будете просто получать дополнительные ссылки на один общий экземпляр модуля.
    - по умолчанию все части считаются приватными
      - Хочешь что-то сделать видимым за передами модуля — экспортируй это из модуля
    - модули ESM всегда работают в строгом режиме и не требуют включения директивы "use strict" в начало файла.
  - 
  - Пример
  - ```js
      export getName;

      var records = [
        { id: 14, name: "Kyle", grade: 86 },
        { id: 73, name: "Suzy", grade: 87 },
        { id: 112, name: "Frank", grade: 75 },
        { id: 6, name: "Sarah", grade: 91 }
      ];
    
      function getName(studentID) {
        var student = records.find(
          student => student.id == studentID
        );
        return student.name;
      }
    ```

  <br></p>
  </details>

[//]: # (Модули ESM — основные возможности)
- <details><summary><b>Модули ESM — основные возможности</b></summary><p>

  - Всегда «use strict»
  - Своя область видимости переменных - переменные и функции, объявленные в модуле, не видны в других скриптах.
  - Код в модуле выполняется только один раз при импорте - если один и тот же модуль используется в нескольких местах, то
  его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.

  <br></p>
  </details>

[//]: # (Модуль это не)
- <details><summary><b>Модуль это не</b></summary><p>

  - Не `пространство имён` — группировка N связанных функций без данных.
    - Полезный набор вспомогательных функций, но все эти функции не зависят от состояния.
    - Группировка функциональности обычно является полезной практикой, но от этого она не становится модулем.
    - Пример:
      - ```js
        var Utils = {
    
          cancelEvt(evt) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
          },
    
          wait(ms) {
            return new Promise(function c(res){
              setTimeout(res,ms);
            });
          },
    
          isValidEmail(email) {
            return /[^@]+@[^@.]+\.[^@.]+/.test(email);
          }
        };
      ```
  - Не `структуры данных` — группировка данные вместе с функциями, обладающими состоянием. Но без ограничения их видимости.
    - Не достигается инкапсуляция, определяемого принципом наименьшего раскрытия.
    - Пример
      - ```js
        var Student = {
          records: [
            { id: 14, name: "Kyle", grade: 86 },
            { id: 73, name: "Suzy", grade: 87 },
            { id: 112, name: "Frank", grade: 75 },
            { id: 6, name: "Sarah", grade: 91 }
          ],
          getName(studentID) {
            var student = this.records.find(
              student => student.id == studentID
            );
            return student.name;
          }
        };
  
        Student.getName(73); // Suzy
        ```
      - `records` содержит общедоступные данные, не скрытые ни за каким открытым API => `Student` не является модулем.
      - `Student` обладает аспектом данные + функциональность, присущим инкапсуляции, но не обладает аспектом управления видимостью. Это «структура данных», а не «модуль».

  <br></p>
  </details>

[//]: # (Пример модуля)
- <details><summary><b>Пример модуля</b></summary><p>
  
  - ```js
    var Student = (
      function defineStudent(){
        var records = [
          { id: 14, name: "Kyle", grade: 86 },
          { id: 73, name: "Suzy", grade: 87 },
          { id: 112, name: "Frank", grade: 75 },
          { id: 6, name: "Sarah", grade: 91 }
        ];
        var publicAPI = {
          getName
        };

        return publicAPI;

        function getName(studentID) {
          var student = records.find(
            student => student.id == studentID
          );
          return student.name;
        }
      }
    )();

    Student.getName(73); // Suzy
    ```
	- Все признаки присутствуют
		- есть группировка данных и функций
		- есть «состояние» — информация поддерживается во времени + есть функциональность для её чтения/обновления.
 		- взаимодействовать можно только через API (с единственным методом `getName(..)`, который обращается к приватным скрытым данным `records`)
 	-
 	- В этом примере экземпляр модуля создается выполняемым `IIFE defineStudent()`. `IIFE` возвращает объект `publicAPI`, который содержит свойство со ссылкой на внутреннюю функцию `getName(..)`.
 	- Вы не обязаны возвращать объект, одним из свойств которого является функция. Также функцию можно вернуть напрямую, вместо объекта — все основные составляющие классического модуля при этом сохраняются.
 	- Использование IIFE подразумевает, что программе понадобится только один центральный экземпляр модуля — такой экземпляр обычно называется одиночкой (singleton). Сколько бы раз вы ни вызывали модуль, вы будете просто получать дополнительные ссылки на один общий экземпляр модуля.

  <br></p>
  </details>

[//]: # (Фабрика модулей)
- <details><summary><b>Фабрика модулей</b></summary><p>

  - Если нужно определить модуль, который может существовать в программе в n экземплярах?
  - Нужна фабричная функция, не IIFE. Определяем обычную автономную функцию — в этом контексте она обычно называется «фабрикой модулей».
  - ```js
    function defineStudent(){
      var records = [
        { id: 14, name: "Kyle", grade: 86 },
        { id: 73, name: "Suzy", grade: 87 },
        { id: 112, name: "Frank", grade: 75 },
        { id: 6, name: "Sarah", grade: 91 }
      ];
      var publicAPI = {
        getName
      };

      return publicAPI;

      // ************************
      function getName(studentID) {
        var student = records.find(
          student => student.id == studentID
        );
        return student.name;
      }
    }

    var fullTime = defineStudent();
    fullTime.getName(73); // Suzy
    ```
  - Программа вызывает «фабрику модулей» для создания экземпляра модуля, которому присваивается имя `fullTime`.
  - Этот экземпляр модуля подразумевает создание нового экземпляра внутренней области видимости, а следовательно, нового замыкания, в котором `getName(..)` удерживает `records`. Теперь `fullTime.getName(..)` вызывает метод для этого конкретного экземпляра.

  - Модуль в этой форме — всего лишь функция, вызов которой создает экземпляр модуля,
  - Такие функции также называют «фабрики модулей».
  - Пример
    - ```js
      function Publication(title,author,pubDate) {
        var publicAPI = {
          print() {
              console.log(`
                Title: ${ title }
                By: ${ author }
                ${ pubDate }
              `);
          }
        };
        return publicAPI;
      }
        
      function Book(bookDetails) {
        var pub = Publication(
          bookDetails.title,
          bookDetails.author,
          bookDetails.publishedOn
        );
        var publicAPI = {
          print() {
              pub.print();
              console.log(`
                Publisher: ${ bookDetails.publisher }
                ISBN: ${ bookDetails.ISBN }
              `);
          }
        };
        return publicAPI;
      }
      
      function BlogPost(title,author,pubDate,URL) {
        var pub = Publication(title,author,pubDate);
        var publicAPI = {
          print() {
              pub.print();
              console.log(URL);
          }
        };
        return publicAPI;
      }
      
      var YDKJS = Book({
        title: "You Don't Know JS",
        author: "Kyle Simpson",
        publishedOn: "June 2014",
        publisher: "O'Reilly",
        ISBN: "123456-789"
      });
  
      YDKJS.print();
      // Title: You Don't Know JS
      // By: Kyle Simpson
      // June 2014
      // Publisher: O'Reilly
      ```

  <br></p>
  </details>

[//]: # (script type="module")
- <details><summary><b>script type="module"</b></summary><p>

  - Надо явно сказать браузеру, что скрипт является модулем - атрибутом `<script type="module">`.<br>
  - Модули не работают локально — только через HTTP(s).

  <br></p>
  </details>

[//]: # (Особенности в браузере)
- <details><summary><b>Особенности в браузере</b></summary><p>

  - Отложенное (deferred) выполнение по умолчанию.
    - загрузка внешних модулей (например `<script type="module" src="...">`) не блокирует обработку HTML.
    - модули ожидают полной загрузки HTML документа, и только затем выполняются
      - Поэтому модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.
      - Поэтому вначале выполнятся обычные скрипты, потом модули. Даже если модули объявлены выше по коду
    - сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.
  - Для модулей атрибут `async` работает во встроенных скриптах (а не только на внешних). Скрипты с ним запускаются сразу
    по готовности, не ждут других скриптов или HTML-документа. Полезно, когда модуль ни с чем не связан, например для
    счётчиков, рекламы, обработчиков событий.
  - Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
  - Дублирующиеся внешние скрипты игнорируются - внешние скрипты с одинаковым атрибутом src запускаются только один раз

  <br></p>
  </details>

[//]: # (Глобальные переменные)
- <details><summary><b>Глобальные переменные</b></summary><p>

  - Переменные объявленные в модулях - видны только в них (надо экспортировать/импортировать).
  - Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда
  - получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.

  <br></p>
  </details>

[//]: # (Циклические зависимости)
- <details><summary><b>Циклические зависимости</b></summary><p> 

  - При вложенности модулей друг в друга может возникнуть циклическая зависимость:
  - ```
    ModuleA -> ModuleB -> ModuleC -> ModuleD -> ModuleA
    //если упростить
    ModuleA <-> ModuleD
    ```
  - ES-модули нативно умеют работать с циклическими зависимостями и корректно их обрабатывать.<br>
  - Циклические зависимости не всегда могут быть источником явных ошибок и исключений, но могут стать причиной некорректного
  - поведения кода, которое трудно будет отловить.<br>
  - Есть несколько хаков, как можно обходить циклические зависимости для некоторые ситуаций, но лучше просто не допускать их
  - возниковения.

  <br></p>
  </details>

[//]: # (Import / export)
- <details><summary><b>Import / export</b></summary><p>

  - `export let user = 'Ivan';` — экспорт до объявления
  - `export {user, sayHi};` — экспорт отдельно от объявления
  - `import {user, sayHi} from './say.js'`
  - `import * as say from './say.js`
  - `import {sayHi as hi} from './say.js'`
  - `export {sayHi as hi};`
  - Default
    - `export default class User {}` — экспорт по-умолчанию
    - `export {sayHi as default}` — тоже экспорт по-умолчанию
    - `import User from './user.js'` — импорт по-умолчанию
    - `import {default as User, sayHi} from './user.js'`  - импорт по-умолчанию + обычный в одной строке
    - `import * as user from './user.js'` `let User = user.default;` — импортировали всё (и default, и обычное), потом
      обратились к default-экспорту (User)
  - Реэкспорт
    - `export {default as User} from './user.js'` — реэкспорт
    - `export {default as User}` — реэкспорт default-экспорта (`export User from './user.js'` не сработает).
    - `export * from './user.js'` — реэкспортирует только именованные экспорты, исключая default-экспорт

  <br></p>
  </details>

[//]: # (Динамический импорт)
- <details><summary><b>Динамический импорт</b></summary><p>

  - Выражение `import(module)` загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.
  - 
  - ```
      let modulePath = prompt("Какой модуль загружать?");
  
      import(modulePath)
        .then(obj => <объект модуля>)
        .catch(err => <ошибка загрузки, например если нет такого модуля>)
    ```

  - Использовать его мы можем динамически в любом месте кода.<br>
  - Или если внутри асинхронной функции, то можно `let module = await import(modulePath)`.
  - 
  - В "статическом" импорте нельзя:
    - Задавать путь к модулю чем-то кроме строки. Вызов функции нельзя<br>
    - 
    - ```
        import ... from getModuleName(); // Ошибка, должна быть строка
      ```
    - 
    - делать импорт в зависимости от условий или в процессе выполнения
    -
    - ```
      if(...) {
        import ...; // Ошибка, запрещено
      }
      {
        import ...; // Ошибка, мы не можем ставить импорт в блок
      }
    ```

  <br></p>
  </details>

[//]: # (Прочее — this, import.meta, «голые» модули)
- <details><summary><b>Прочее — this, import.meta, «голые» модули</b></summary><p>

  - `this` на верхнем уровне модуля = undefined. В не-модульных скриптах `this` – глобальный объект (window, например)
  - 
  - Объект `import.meta` содержит информацию о текущем модуле.
    - ```js
      <script type="module">
        alert(import.meta.url); // ссылка на html страницу для встроенного скрипта. Содержимое зависит от окружения. В
        браузере содержит ссылку на скрипт или ссылку на текущую веб-страницу, если модуль встроен в HTML
      </script>
      ```
  - 
  - В браузере import должен содержать относительный или абсолютный путь к модулю. Модули без пути называются «голыми» (`bare`). Они не разрешены в import.
    - ```js
        import {sayHi} from 'sayHi'; // Ошибка, "голый" модуль
        // путь должен быть, например './sayHi.js' или абсолютный
      ```

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Модули](https://learn.javascript.ru/modules)
  - [Mentanit - Модули в JS](https://metanit.com/web/javascript/19.1.php)
  - [Habr - Модули](https://habr.com/ru/company/domclick/blog/532084/)
  - [WebDev - Модули в JS](https://youtu.be/q_tHi37EMic)
  - [learn.javascript.ru - Модули через замыкания](https://learn.javascript.ru/closures-module)
  - [Habr - Эволюция модульного JavaScript (2017)](https://habr.com/ru/company/yandex/blog/192874/)
  - [Habr - Путь JavaScript модуля (2013)](https://habr.com/ru/post/181536/)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Анонимные функции. Самовыполняющиеся функции. Модули через замыкания todo: доработать)
<details id="modules"><summary><b>Анонимные функции. Самовыполняющиеся функции. Модули через замыкания</b> ( function(){} )()*</summary><p>

[//]: # (Анонимные функции и функциональные выражения)
- <details><summary><b>Анонимные функции и функциональные выражения</b></summary><p>

  - Анонимная функция — функция, которая объявляются в месте использования и не получает уникального имени.
  -
  - Есть «Function Expression» (функциональное выражение) - синтаксис объявления функций:
  - ```  js
    var f = function(параметры) {
      // тело функции
    };
    ```  
  -
  - Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.
  - ``` js
    function ask(question, yes, no) {
      if (confirm(question)) yes()
      else no();
    }
    
    ask(
      "Вы согласны?",
      function() { alert("Вы согласились."); },
      function() { alert("Вы отменили выполнение."); }
    );
    ```
  -
  - Важное отличие Function Expression (и анонимных функций, в частности) - они должны объявляться до их вызова.
  - Такая функция создается в момент ее запуска в скрипте, а не во время парсинга. Поэтому в коде её надо прописать до её вызова.
  - ``` js
    //Плохо:
    sayHi("Вася");
    var sayHi = function(name) {
      alert( "Привет, " + name );
    }
    
    //Хорошо:
    var sayHi = function(name) {
      alert( "Привет, " + name );
    }
    sayHi("Вася");
    ```
  -
  - Анонимные функции короче, их легче писать. Это удобно (если не надо ссылаться на них в коде). Например в обработчиках.
  - См. также Function Expression

  <br></p>
  </details>

[//]: # (Самовыполняющиеся функции — модуль через замыкания)
- <details><summary><b>Самовыполняющиеся функции — модуль через замыкания</b></summary><p>

  - В определенной записи анонимные функции могут вызывать сами себя.
  - Эффект создается пустыми скобками в конце функции.
  - ``` js
    (function() {
      // код выполняется автоматически
    })();
    ```
  - 
  - Этот приём — реализация паттерна «модуль» через замыкания.
  - Главная фишка этого приёма – изоляция области видимости функции.
  - Переменная, объявленная внутри такой функции, может быть вызвана только внутри этой функции. В остальном коде данная переменная не видна. Поэтому переменная внутри самовыполняющейся функции замыкается внутри этой функции. Такую переменную нельзя случайно вызвать из внешнего кода или переписать.
  - Эта техника аккуратно инкапсулирует переменные и код, пряча их от глобального пространства имен, чтобы они не вступили в конфликт с другим кодом. Поэтому полифилы и плагины часто пишутся в виде самовыполняющихся функций.

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Анонимные и самовыполняющиеся функции в JavaScript](https://webformyself.com/anonimnye-i-samovypolnyayushhiesya-funkcii-v-javascript/)
  - [learn.javascript.ru - Модули через замыкания](https://learn.javascript.ru/closures-module)
  - [learn.javascript.ru - Функциональные выражения](https://learn.javascript.ru/function-declaration-expression)
  - [Wikipedia - Анонимная функция](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
  - [code.mu - Продвинутая работа с функциями](http://code.mu/books/javascript/advanced/prodvinutaya-rabota-s-funkciyami-javascript.html)
  - [WebDev - Модули в JS](https://youtu.be/q_tHi37EMic)
  - [learn.javascript.ru - Модули](https://learn.javascript.ru/modules)

  <br></p>
  </details>

<br></p>
</details>


---


[//]: # (Движок. Окружение. Асинхронность todo: упростить)
<details id="engine"><summary><b>Движок. Окружение. Асинхронность *</b></summary><p>

[//]: # (Кратко)
- <details><summary><b>Кратко</b></summary><p>

    - есть `движок` и `окружение`
    - в разных окружениях может использоваться один движок: `V8` работает и в браузере `Chrome/Chromium` и в платформе `node.js`
    - в движке конвейер:
        - `парсер` -> `абст. синтакс. дерево` -> `интерпретатор` -> `компилятор`  -> `машинный код`
    - код попадает в `очередь`. Упомянуть `микро/макро задачи`, `web workers`
    - задачи из очереди по одной уходят в `стэк`
        - стр-ра данных в движке. Стопка тарелок, LIFO
    - стек работает синхронно, окружение асинхронно.
    - асинхронные операции выполняются в окружении.
        - ждёт нужный момент и ставит задачу в очередь стэка. Дальше всё как обычно.
    - всё работает в бесконечном «событийном цикле» `event loop`:
        - `макрозадача 1` -> все `микрозадачи` -> `отрисовка страницы` (рендер) -> `макрозадача 2`

  \*\*\*

    - `Инструкции` — синтаксические конструкции и команды, которые выполняют действия. «Строки программы». Отделяются точкой с запятой.

  <br></p>
  </details>

[//]: # (Движок. Окружение / Среда)
- <details><summary><b>Движок. Окружение (Среда)</b></summary><p>

    - `Движок` (JS Engine) — программа для обработки JS кода и конвертирования его в конкретные команды для выполнения.
        - v8 (Chrome, Edge, node.js)
        - SpiderMonkey (Mozilla)
        - JavaScriptCore (фреймворк WebKit, на нём работает Safari)
        - Hermes (для React Native, от Facebook)
        - JerryScript (суперлегкий движок, используемый для интернета вещей, весит менее 200 КБ - нужно мало памяти на уст-ве).
        - Chakra (IE)
        - Nitro (старые Safari)

    - `Окружение / Среда / Управляющая среда` (JS Run-time Enviroment) — надстройка над движком.
        - Примеры
            - Chrome
            - Firefox
            - node.js
        -
        - Окружение отвечает за создание экосистемы с возможностями, сервисами и поддержкой.
        - Поддержка DOM, CSSOM, Browser Object Model, ключевых библиотек и т.п.
        - Окружения определяют различия между браузером и node.js, например.
        - Используя один и тот же движок v8:
            - на `node.js` мы пишем сетевые приложения или обращаемся напрямую к жесткому диску,
            - а из `Chrome` перехватываем клики по кнопкам
        -
        - Все браузеры выполняют JS по-разному, но под капотом, они все работают по одной модели: стэк вызова, куча, event loop, Web API...

  -`Окружение` и `JS движок` работают независимо.
    - Асинхронные операции выполняются не в движке, а в `окружении`.
    - Окружение (environment) - это область памяти, где записываются идентификаторы и значения из областей видимости. Не путайте с окружением, как средой исполнения.
    - Есть компилятор и есть движок
    - после того, как будут откомпилированы все файлы — активизируется исполнительная среда приложения.
    -
    -
    - Если JS выполняется исключительно внутри движка, его поведение полностью предсказуемо и определяется исключительно спецификацией и ничем иначе. Однако JS почти всегда работает в контексте среды внешнего размещения, которая создает некоторую степень неопределенности.
    - JS среда, используемая для размещения вашего кода (браузер и т. д.),

  <br></p>
  </details>

[//]: # (API среды)
- <details><summary><b>API среды</b></summary><p>

    - Большой пласт привычной функциональности используется в JS, но не является частью JS — это API среды.
    - Например `alert`, `fetch(...)` или `console.log`.
    - В спецификации JS они не указаны. Но благодаря своей универсальной полезности они определяются практически во всех средах JS в соответствии с приблизительно достигнутым консенсусом.
    -
    - Есть такая вещь как «управляющие объекты» (см. ниже) — переменные, которые определяются автоматически или иным образом создаются и передаются JS средой (браузер и т.д.)
    - Пример управляющего объекта — объект `console` и его различные функции (`log()`, `error()` и т. д.).
    - Объект `console` предоставляется средой размещения специально для того, чтобы ваш код мог взаимодействовать с ним для выполнения различных операций вывода, связанных с разработкой.

  <br></p>
  </details>

[//]: # (Консоль средств разработчика в браузере)
- <details><summary><b>Консоль средств разработчика в браузере</b></summary><p>

    - Не пытается точно и однозначно отразить все нюансы поведения JS, строго соответствующие спецификации JS. Поведение, которое мы наблюдаем в консоли разработчика, не воспроизводит семантику JS в точности. Подробности в спецификацию.
    - Лучше рассматривать консоль как особую JS-совместимую среду.

  <br></p>
  </details>

[//]: # (Интерпретация и компиляция в JS)
- <details><summary><b>Интерпретация и компиляция в JS</b></summary><p>

    - Формально JS считается «интерпретируемым» языком — программа-интерпретатор идёт по JS коду и тут же го выполняет. В «компилируемых» языках базовый код прогоняется через программу-компилятор, она формирует «разбирает» код, формирует Abstract Syntax Tree, из него собирает двоичный код в виде исполняемого файла, пользователь запускает этот код — он исполняется.
    - У «компилируемых» языков есть ряд преимуществ:
        - лучше оптимизация
        - лучше типизация (статическая, а не динамическая)
        - ошибки вылавливаются на этапе компиляции, а не при запуске программы

    - Но по факту C JS всё не так просто:
        - JS-код преобразует транспилятором (например Babel), потом упаковывается Webpack (и/или другими процессами), после чего в совершенно новой форме передается ядру JS.
        - Ядро JS разбирает код в форму Abstract Syntax Tree. Потому что по спецификации «ранние ошибки» (например совпадающие имена параметров) должны выявляться до начала выполнения кода.
        - Ядро преобразует AST в оптимизированную форму двоичного байт-кода (двоичное промежуточное представление — Intermediate Representation).
        - IR-код обычно исполняется ядром (передается виртуальной машине JS для выполнения). Ядро редко возвращается в режим «построчной чтения исходного кода».
        - Также надо учесть что ядра JS могут применять к генерируемому коду многопроходную JIT-обработку/оптимизацию (Just-In-Time), которую также можно не без оснований назвать компиляцией или интерпретацией в зависимости от перспективы.
        - Т.е. по духу, если не в практическом смысле, JS является компилируемым языком.
        - Почему это важно: так как JS является компилируемым языком, мы получаем информацию о статических ошибках (например, некорректном синтаксисе) перед выполнением кода. Эта модель взаимодействий принципиально отличается от модели традиционных сценарных программ, и, пожалуй, она более эффективна.

  <br></p>
  </details>

[//]: # (Общая схема работы JS)
- <details><summary><b>Общая схема работы JS</b></summary><p>

    - код
    - `транспиляция` (Babel...)
    - `упаковывается` Webpack (и/или ещё чем-то)
    - попадает в ядро JS
        - `парсер` разбирает код в форму Abstract Syntax Tree
        - вероятно здесь работает `интерпритатор` (или несколько) — построчно выполняет код программы.
        - ядро преобразует AST отдельных функций в оптимизированную форму двоичного байт-кода (`Intermediate Representation`)
            - двоичное промежуточное представление.
            - При этом копится статистика использования JS-функций. Если какая-то вызывается часто, её передают `компилятору` для оптимизации.
        - IR-код передается `виртуальной машине JS` для выполнения. Ядро редко возвращается в режим «построчного чтения исходного кода».
        - ядро также может применять к генерируемому коду многопроходную JIT-обработку/оптимизацию (Just-In-Time)
        -

  <br></p>
  </details>

[//]: # (Парсер, интерпретатор, компилятор)
- <details><summary><b>Парсер, интерпретатор, компилятор</b></summary><p>

  <img src="/Assets/Img/js-schema-1.png" title="Схема 1" alt="Схема 1" />

    - Внутри движок устроен как конвейер: `парсер` -> `интерпретатор` -> `компилятор` -> `машинный код`
    - В разных движках это конвейер устроен по-разному — количество компиляторов, различные оптимизации и т.д.
    - Но общая схема примерно одна.
    -
    - Исходный код проходит через `парсер`.
    - В результате возникает внутреннее представление кода — `абстрактное синтаксическое дерево` (AST).
    -
    - Дальше работает `интерпретатор`. Их может быть несколько
    - Он построчно выполняет код программы.
    - Отдельные функции при исполнении преобразуются в `байт-код` — спец. код для вирутальной машины.
    - При этом копится статистика использования JS-функций. Если какая-то вызывается часто, её передают `компилятору` для оптимизации.
    -
    - `Компилятор` генерирует `машинный код` — 0 и 1, язык самого процессора (очень быстрый).
    - Машинный код сильно завязан на типы входных значений.
    -
    - Допустим, есть функция `foo(a, b)` и мы вызываем её много раз с числовыми параметрами `a` и `b`.
    - В какой-то момент функция будет передана компилятору и станет выполняться быстрее.
    - Потом вызовем её со строковым аргументом — движок выполнит «деоптимизацию»: вернёт функцию от компилятора интерпретатору, а готовый машинный код - будет выброшен.
    -
    - `Интерпретатор` просматривает код построчно и выполняет его.
    - `Компилятор` сначала готовит весь код, потом выполняет.
    - `Компилятор Just-In-Time` (JIT) — промежуточное положение. Разновидность динамической компиляции. Быстрый и гибкий

  <br></p>
  </details>

[//]: # (Event loop. Микро- и макро-задачи)
- <details><summary><b>Event loop. Микро- и макро-задачи</b></summary><p>

    - `Event Loop` (Cобытийный цикл) — бесконечный цикл, в котором движок JS ожидает задачи, исполняет их и снова ожидает появления новых.
    - `Event Loop` — специальный механизм на уровне движка js, который координирует работу трёх сущностей:
        - Call Stack (стэк вызовов),
        - Web API (API, предоставляемый браузером),
        - Callback Queue (очередь колбэков).
    - С помощью механизма Event Loop становится возможным выполнять асинхронный код в JavaScript.
    - 
    - Примеры задач для Event Loop:
        - Когда загружается внешний скрипт <script src="...">, задача — это выполнение этого скрипта.
        - Когда пользователь двигает мышь, задача — сгенерировать событие mousemove и выполнить его обработчики.
        - Когда истечёт таймер, установленный с помощью setTimeout(func, ...), задача — это выполнение функции func
    - 
    - Задачи поступают на выполнение – движок выполняет их – затем ожидает новые задачи.
    - Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.
    - 
    - **Микрозадачи**
        - Приходят только из кода (не от движений мышкой и т.д.)
        - Обычно создаются промисами
            - выполнение обработчика `then`/`catch`/`finally`,
            - используются «под капотом» `await` (форма обработки промиса).
        - После каждой макрозадачи движок исполняет все задачи из очереди микрозадач.
            - Перед тем, как выполнять следующую макрозадачу, отобразить изменения на странице, или сделать что-то ещё.
            - Это важно — гарантирует, что общее окружение остаётся одним и тем же между микрозадачами. Не изменены координаты
              мыши, не получены новые данные по сети и т.п.
        - Исполняются непрерывно одна за другой
            - События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются
            - Их можно вызывать если надо запустить функцию асинхронно (после текущего кода), но до отображения изменений и до
              новых событий.
            - Т.е. для асинхронного выполнения функции в том же состоянии окружения
        - Длобавление в очередь новой микрозадачи:
            - обработчики промисов — `then`, `cath`, `finally`.
            - `queueMicrotask(f)` — спец. функция для постановки задач в очередь микро-таск ([Подробнее](https://doka.guide/js/queuemicrotask/))
            - `process.nextTick` — кажется это функциональность чисто NodeJS. ([Подробнее](https://stackoverflow.com/questions/40629456/why-and-when-to-use-process-nexttick))
            - `MutationObserver` — объект, наблюдает за DOM-узлом Х и запускает колбэк при изменении этого узла.
    - 
    - **Макрозадачи**
        - Все остальные
        - Работают в нормальной очереди (см. выше)
        - Добавление в очередь новой макрозадачи
            - `setTimeout(f)` с нулевой задержкой.
                - Этот способ можно использовать для разбиения больших вычислительных задач на части — чтобы браузер мог реагировать
                  на пользовательские события и показывать прогресс выполнения этих частей.
                - Также используется в обработчиках событий — для отложенного выполнения действия после того, как событие полностью
                  обработано (всплытие завершено).
            - `setTimeout`
            - `setInterval`
            - `setImmediate` — поставить функцию в очередь на выполнение без задержки, реализован на платформе Node.JS.
            - ...
    - 
    - **Алгоритм Event loop**
        1. Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
        2. Исполнить все микрозадачи:
        1. Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
        3. Отрисовать изменения страницы, если они есть.
        4. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
        5. Перейти к шагу 1.
    - 
    - **Описание работы Event loop**
        - движок js анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в Call Stack.
        - Если эта функция синхронная (например, console.log()), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция.
        - Если же эта функция асинхронная, например, setTimeout(), обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим Web API (мы же помним, что JavaScript - это однопоточный язык, и сам работать в многопоточном режиме он не может).
        - Event Loop перемещает колбэк асинхронной функции в Web API, а сама асинхронная функция уходит из стэка вызовов.
        - То есть, пока колбэк асинхронной функции находится под управлением Web API, движок js продолжает выполнять другие операции!
        - Что же происходит с колбэком? В случае, например, setTimeout(), Web API ожидает истечения указанного времени, затем Event Loop перемещает этот колбэк в Callback Queue (очередь колбэков).
        - Когда стэк вызовов освобождается, Event Loop перемещает в него наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов.
        - Этот процесс повторяется до тех пор, пока весь js код не будет выполнен.
    - 
    - 
    - **Описание работы Event loop 2**
      - Движок JS работает внутри управляющей среды (в нашем случае - браузер).
      - У всех этих сред есть одна характерная особенность: у них существует механизм, который обеспечивает выполнение нескольких фрагментов вашей программы, обращаясь с вызовами к движку JS в разные моменты времени. Этот механизм называется «циклом событий» (event loop).
      -
      - Движок JS сам по себе не обладает внутренним чувством времени, но он становится средой исполнения для любого произвольного фрагмента JS. Планирование «событий» (выполнений фрагментов кода JS) всегда осуществляется окружающей средой.
      - Например, когда программа JS выдает запрос Ajax для получения данных с сервера, вы определяете код реакции в функции (callback, функция обратного вызова), а движок JS говорит управляющей среде:
          - «Так, я собираюсь ненадолго приостановить выполнение, но когда ты завершишь обработку этого сетевого запроса и получишь данные, пожалуйста, вызови вот эту функцию».
          - Браузер настраивается для прослушивания ответа от сети, и когда у него появятся данные, чтобы передать их программе, планирует выполнение функции обратного вызова, вставляя ее в цикл событий.
      -
      - Так что же такое «цикл событий»?
          - Имеется непрерывно работающий цикл
          - Каждая итерация цикла называется тиком.
          - В каждом тике, если в очереди ожидает событие, оно, событие, извлекается и выполняется. Этими событиями становятся ваши функции обратного вызова.
          - Каждый раз, когда в системе имеются события для обработки, цикл событий выполняется до тех пор, пока очередь не опустеет. Каждая итерация цикла событий называется тиком. Действия пользователя, операции ввода/вывода и таймеры помещают события в очередь событий.
          - В любой момент времени может обрабатываться только одно событие из очереди. В то время, пока событие выполняется, оно может прямо или косвенно породить одно или несколько последующих событий.
          - Под параллельным выполнением понимается чередование двух и более цепочек событий во времени, так что с высокоуровневой точки зрения они вроде бы выполняются одновременно (хотя в любой момент времени обрабатывается только одно событие).
          -
      -
      - Часто бывает необходимо в той или иной форме координировать выполнение параллельных «процессов» в коде (не путать с процессами операционной системы!), например, чтобы гарантировать упорядочение или предотвратить состояние гонки. Эти «процессы» также могут выполняться в кооперативном режиме, для чего они разбиваются на меньшие блоки и дают возможность выполняться другим чередующимся «процессам».
      -
      - Важно заметить, что функция setTimeout(..) не ставит обратный вызов в очередь цикла событий. Вместо этого она запускает таймер; по истечении таймера среда помещает ваш обратный вызов в цикл событий, чтобы некий тик в будущем подобрал его для выполнения.
      - А если в очереди в данный момент уже находятся 20 элементов? Вашему обратному вызову придется подождать. Он ставится в очередь после всех остальных — обычно не существует способа выйти вперед и обогнать других в очереди. Это объясняет, почему таймеры setTimeout(..) не гарантируют идеальной точности.
      - Функция гарантирует (упрощенно говоря), что обратный вызов не сработает до истечения заданного вами интервала, но это может произойти в заданный момент или после него в зависимости от состояния очереди событий.
      - Другими словами, ваша программа обычно разбивается на множество мелких блоков, которые выполняются друг за другом в очереди цикла событий. И с технической точки зрения в эту очередь также могут попасть другие события, не имеющие прямого отношения к вашей программе.

    - 
    - **Детали**
        - Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Изменения в DOM
          отрисовываются только после того, как задача выполнена.
        - Блокировка браузера — если задача выполняется долго, браузер предлагает «убить» её. <br>
          Браузер не может выполнять другие задачи, обрабатывать пользовательские события - заблокирован. <br>
          Например в скрипте много сложных вычислений или ошибка «бесконечный цикл».
        - `Web workers` — способ исполнить код в другом, параллельном потоке. <br>
          Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.<br>
          Web Workers могут обмениваться сообщениями с основным процессом, но имеют свои переменные и свой событийный цикл.<br>
          Web Workers не имеют доступа к DOM. Основное применение – вычисления. Позволяют задействовать N ядер процессора.
    - 
    - **Ссылки**
        - [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
        - [learn.javascript.ru -Микрозадачи](https://learn.javascript.ru/microtask-queue)
        - [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
        - [YouTube - Филипп Робертс: Что за чертовщина такая event loop? (26 мин) Он же?](https://youtu.be/8aGhZQkoFbQ) - Очень
          просто и понятно.
          Рекомендую
        - [Habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
        - [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
        - [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
        - [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
        - https://habr.com/ru/post/439620/
        - https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing

  <br></p>
  </details>

[//]: # (Микро и макро-задачи. Microtask и macrotask)
[//]: # (todo: дополнить. Постоянно спрашивают на собеседованиях!)
- <details><summary><b>Микро и макро-задачи (microtask и macrotask)</b></summary><p>

  - На самом деле, очередь задач устроена несколько сложнее, чем написано выше:

  - Начиная с ES6 очередь разбита на
    - `макрозадачи` — очередь коллбеков (callback queue)
    - `микрозадачи` — очередью заданий (job queue, PromiseJobs)

  - В одной итерации Event loop обрабатывается
    - **макрозадача** (т.е. классическая задача) из очереди коллбеков. <br>
      Т.е. всё что стояло в очереди обычных задач к этому моменту, например все «обычные», синхронные `console.log()` в
      скрипте.<br>
      Выполнение скрипта - это задача. А если пользователь в это время двинул мышкой - это вторая. Будет поставлена в
      очередь как отдельная макрозадача.
    - **все микрозадачи** из очереди микрозадач - обрабатываются в том же цикле, после макрозадачи. <br>
      Они как-бы «пристраиваются хвостом» к первой макрозадаче. <br>
      «Очередь заданий» (микрозадачи) присоединена к концу каждого «тика» в очереди цикла событий. <br>
      Эти микрозадачи могут добавлять в очередь другие микрозадачи. Процесс будет продолжаться, пока очередь микрозадач не
      опустеет. Т.е. до запуска следующей макрозадачи может пройти довольно много времени. Может привести к зависанию
      интерфейса.<br>
      В ECMAScript микрозадачи называют «заданиями» («jobs»).<br>
      Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.
    - *ререндер* экрана браузера. Эти события происходят около 60 раз в секунду.<br>
      Именно для того, чтоб их пропустить, рекомендуется не занимать стек большой синхронной задачей, а разбить её на
      асинхронные (например через `setInterval(callback,0)`).

  - **Очередность**

    - вначале в стеке выполнятся текущие макрозадачи (например, все console.log). Пока стек не очистится.
    - если в коде макрозадачи попалось что-то асинхронное (setTimeout, например) - эта асинхронная часть «выбрасывается» в среду, там ждёт момента выполнения (пока таймер истечёт, или придёт ответ с сервера), когда момент настал - опять встаёт в очередь, как обычная макрозадача
    - потом из очереди микрозадач выполнятся все микрозадачи (например, обработчики промисов + те микрозадачи, которые они вызывают внутри себя)
    - потом выполнится задача рендера (это макрозадача, по приоритету она ниже микрозадач)
    - потом из очереди макрозадач выполнятся следущие макрозадачи

  - **Промисы**

    - Код в промисе выполняется по общим правилам.
    - Если там синхронный код, то синхронно. Если асинхронный (timeout, например) — асинхронно.

    - А вот обработчики промисов (`.then`, `.catch`, `.finally`) всегда асинхронны!
    - Даже если промис выполняется сразу (не содержит в себе асинхронной задачи), вначале выполнится код расположенный ниже чем блоки `.then`, `.catch` `.finally`.
    - Когда промис выполнен, его обработчики (`.then`, `catch`, `finally`) попадают в очередь микрозадач. Они пока не выполняются. Движок JS берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода (макрозадачи).

    ```js
      console.log('Start');
    
      setTimeout(function timeout() {
        console.log('Timeout');
      }, 0);
    
      const promise = new Promise(function (resolve, reject) {
        console.log('Promise'); // Выполянется как обычный синхронный код
        resolve(true);
      });
    
      promise.then(function () {
        console.log('Then'); // Очередь микрозадач
      });
    
      console.log('End');
    
      // Вывод:
      // - Start
      // - Promise
      // - End
      // - Then
      // - Timeout
    ```

    - Второй пример, Promise выполняется позже console.log:

    ```js
      console.log('Start');
    
      setTimeout(function timeout() {
        console.log('Timeout');
      }, 0);
    
      //В стэке отрабатывает resolve, и отправляет .then в очередь микрозадач
      Promise.resolve().then(function () {
        console.log('Then');
      })
    
      console.log('End');
    
      // Вывод:
      // - Start
      // - End
      // - Then
      // - Timeout
    ```

  - Макрозадачи планируются с помощью

    - setTimeout
      - часто используют с нулевой задержкой, для разбиения больших вычислительных задач на части, чтобы браузер мог
        реагировать на пользовательские события и показывать прогресс выполнения этих частей.
      - Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью
        обработано (всплытие завершено).
    - setInterval
    - setImmediate
    - ...

  - **Микрозадачи**

    - выполнение обработчика промиса - `.then`,`catch`, `finally`
    - используется в `await` (форма обработки промиса)
    - функция `queueMicrotask(func)` — помещает func в очередь микрозадач. <br>
      Если хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений на экране (ререндер) и до
      новых событий (клик мыши и т.д.) — можно запланировать выполение через `queueMicrotask()`.
    - process.nextTick,
    - MutationObserver.

    При исполнении любого файла JS-движок конвертирует содержимое в функцию и ассоциирует её с событием start или launch.
    Движок инициализирует стартовое событие и добавляет события в очередь как макрозадачи.

    Начиная обработку, движок JS выбирает первую макрозадачу из очереди и выполняет обработчик обратного вызова:

    Микрозадачи обычно планируются для вещей, который должны исполняться моментально после текущего исполняемого сценария.
    Например, реагирование на пачку действий или для того, чтобы сделать что-то асинхронно без необходимости терять
    производительность на пустом месте из-за полностью новой задачи. Очередь микрозадач развёртывается в конце каждой полной
    задачи, а также после колбеков в случае если никакой другой JavaScript не находится на стадии исполнения. Любые
    дополнительные микрозадачи, поставленные в очередь во время развёртывания очереди микрозадач, добавляются в конец
    очереди и тоже обрабатываются. Микрозадачи включают в себя колбеки Mutation observer и промисов, как в примере выше.

    Как только промис решается или если он уже был решён, он ставит в очередь микрозадачу на исполнение колбека. Это даёт
    уверенность, что колбеки промисов исполняются асинхронно даже если они уже решены.

  - **Async/await**

    Сама по себе async-функция обработается по обычным правилам.<br>
    А вот ключевое слово `await` в ней — поставит код «на паузу».<br>
    Интерпретатор JS будет ждать, пока промис справа от `await` не выполнится.<br>
    После чего оно вернёт его результат, и выполнение кода продолжится.

    Ключевое слово `await` говорит движку JS приостановить код в этой строке, не блокируя остальной код скрипта за пределами
    асинхронной функции.

    Вроде это должно работать как обычный `.then`

    - Это просто «синтаксический сахар» для получения результата промиса, аналог `promise.then`.
    - Хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора.
    - Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события
      и т.п.

    `Await` ставит код «на паузу» — все останавливается, пока не отработает асинхронный код (промис) в `await`.
    Слово `await` сообщает что:

    - мы должны дождаться выполнения асинхронной функции
    - не помещать ее в event loop, а выполнить прямо здесь.

    Это значит, что при вызове функции перед которой стоит async - эта функция попадет в очередь контекстов и будет
    исполнена.<br>
    Но следующий контекст будет ждать, пока текущий завершится. <br>
    Все пользовательские события, таймеры и прочие помещаемые в очередь контексты будут ждать, пока не закончатся
    асинхронные await-задачи внутри async-функции.

    Вроде так.

  - **Очередь заданий (job queue)**
    - связана с промисами
    - очередь заданий присоединяется к концу каждого тика в очереди цикла событий. Некоторые операции, подразумевающие асинхронный характер выполнения, которые могут происходить во время тика цикла событий, не приводят к добавлению в очередь цикла событий нового события, вместо этого в конец очереди заданий текущего тика добавляется новый элемент (то есть задание).
    - Означает следующее: «Да, и вот еще одна штука, которую нужно выполнить потом, — но только это должно произойти до того, как произойдет *что-нибудь еще*».
    - Задание может привести к добавлению новых заданий в конец той же очереди (того же тика). Т.е. теоретически возможно, что цикл заданий (задание, которое добавляет новое задание и т. д.) будет работать бесконечно долго, не позволяя вашей программе перейти к следующему тику цикла событий. На концептуальном уровне это будет почти эквивалентно включению очень долгого или бесконечного цикла (например, while (true) ..) в ваш код.
    - Задания отдаленно напоминают трюк с setTimeout(..0), но реализуются так, чтобы обеспечивать гораздо более четко определенное и гарантированное упорядочение: потом, но как можно скорее.

  - **Ссылки**
    - [Habr - Задачи, микрозадачи, очереди и планы](https://habr.com/ru/post/264993/)
    - [stackoverflow.com - Разница между микрозадачей и макрозадачей в контексте цикла событий (En)](https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event%20-loop-context)
    - [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
    - [learn.javascript.ru - Микрозадачи](https://learn.javascript.ru/microtask-queue)

  <br></p>
  </details>

[//]: # (Стэк вызовов)
- <details><summary><b>Стэк вызовов</b></summary><p>

  <img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
  <br>

  <img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />
  <br>

    - `Стек вызовов` — структура данных, хранит информацию о том, какой участок кода сейчас выполняется. Часть движка.
    - Движок JS линейно и последовательно обрабатывает операции, которые берёт из стека вызовов (1).
    - Последним пришёл первый вышел. LIFO (last in — first out). Как стопка тарелок.
    - Удалить операцию из стека нельзя, можно только прервать поток выполнения.
    - Поток выполнения прерывается, если вызвать что-то типа alert или «исключение».
    -
    - Стэк используется для хранения контекстов выполнения, создаваемых в ходе работы кода (какой участок кода сейчас обрабатываем).
    - Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения (особая стр-ра в памяти) и помещает его в текущий стек.
    - При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.
    -
    - Движок выполняет функцию, контекст выполнения которой находится в верхней части стека.
    - Когда работа функции завершается, её контекст извлекается из стека.
    - Управление передаётся контексту, который находится в предыдущем элементе стека.

  <br></p>
  </details>

[//]: # (Асинхронность. Очередь вызовов)
- <details><summary><b>Асинхронность. Очередь вызовов</b></summary><p>

  <img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
  <br>

  <img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />
  <br>

    - *Cтек вызовов работает синхронно, а web API/Окружение асинхронно!*
    - *Это очень важно!*
    -
  -`Окружение` и `JS движок` работают независимо.
    - Асинхронные операции выполняются не в движке, а в `окружении` (5,6).
    - **Есть вариант**: *можно из стека вызовов сразу же положить функцию в очередь вызовов. Таким образом чистый движок тоже будет работать асинхронно.*
    -
    - Чтобы создать асинхронный вызов, в `окружение` передается ссылка на функцию, которая выполнится позже (или не выполнится вовсе).
    -
    - Окружение получает код и само решает, в какой момент передать функцию в `очередь вызовов` (2, queue, «кью»).
    - По сути, очередь - это часть `стэка`
    - В очереди вызовов нельзя отменять отдельные операции. Это делается в окружении (removeEventListener — в качестве примера).
    -
    - Функции из очереди вызовов попадают в JS-движок, где выполняются по одной.
    - Выполнение происходит в том же порядке, в котором функции попали в очередь.
    - Функции из очереди добавляются в стек выполнения (выполняются) не раньше, чем стек вызовов закончит работу над текущей функцией.

  <br></p>
  </details>

[//]: # (Функции и контекст)
- <details><summary><b>Функции и контекст</b></summary><p>

  <img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />
  <br>

    - Каждая операция содержит `контекст` — область памяти, из которой доступны данные.
    - Контексты расположены в памяти в виде «дерева».
    - Каждому дочернему контексту («листу» в дереве) доступны области видимости, которые определены в родительских ветках и в корне (глобальной области видимости). Это достигается за счёт того что в дочернем контексте есть специально свойство-ссылка на родительский. Поэтому мы можем от любого дочернего контекста найти всех родителей вплоть до корня.
    - Функции в JavaScript — это данные.
    - Они хранятся в памяти именно как данные и поэтому могут передаваться как переменные или возвращаться из других функций.
    - У функции есть свой контекст (область памяти), в котором она определена.
    - Функция имеет доступ к этой области памяти и ко всем родителям этой области памяти. Такие функции называются замыканиями. С этой точки зрения, все функции в JavaScript — замыкания, так как все они имеют контекст.

  <br></p>
  </details>

[//]: # (Альтернативные методы реализации асинхронности)
- <details><summary><b>Альтернативные методы реализации асинхронности</b></summary><p>

    - SIMD
        - параллельные математические операции уровня процессора на JavaScript API
        - разновидность параллелизма уровня данных (в отличие от параллелизма уровня задач с web-workers). основное внимание уделяется не параллелизму блоков программной логики, а параллельной обработке нескольких битов данных.
        - C SIMD параллелизм обеспечивается не потоками. Вместо этого современные процессоры предоставляют функциональность SIMD в виде «векторов» чисел (считайте, что это специализированные массивы) и команд, которые могут работать параллельно с этими числами; по сути, это низкоуровневые операции, использующие параллелизм уровня команд.
        - SIMD JavaScript предлагает открыть доступ коду JS к коротким векторным типам и API, которые в системах с поддержкой SIMD отображают операции прямо на эквивалентные средства процессора; в системах без поддержки SIMD используются непараллельные «прокладки совместимости» (shims).
        - Выигрыш по быстродействию в приложениях, интенсивно работающих с данными (анализ сигналов, матричные операции с графикой и т. д.), при параллельной обработке математических операций

    - Web-workers
        - В настоящее время в JavaScript нет никаких средств поддержки многопоточного выполнения.
        - Однако такая среда, как браузер, легко может предоставить несколько экземпляров движка JavaScript, каждое из которых выполняется в отдельном потоке, и дать вам возможность запустить разные программы в разных потоках. Каждая из этих отдельных потоковых частей программы называется веб-работником. Данная разновидность параллелизма называется параллелизмом на уровне задач, так как основное внимание в ней уделяется разбиению программы на части для параллельного выполнения.
        - См подробнее [Web-workers](#webWorkers)

  <br></p>
  </details>

[//]: # (Картинки)
- <details><summary><b>Картинки</b></summary><p>

  <img src="/Assets/Img/js-schema-1.png" title="Схема 1" alt="Схема 1" />
  <br>

  <img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
  <br>

  <img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 1" alt="Схема 1" />

  <br></p>
  </details>

[//]: # (Ссылки про движок)
- <details><summary><b>Ссылки</b></summary><p>

    - [Medium - Движки JavaScript. Часть 1: парсинг](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-%D0%BF%D0%B0%D1%80%D1%81%D0%B8%D0%BD%D0%B3-754a8d60df23)
    - [Medium - Движки JavaScript. Часть 2: генерация кода и базовые оптимизации](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-fb66fd238769)
    - [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
    - [learn.javascript.ru - Микрозадачи](https://learn.javascript.ru/microtask-queue)
    - [learn.javascript.ru - Браузерное окружение, спецификации](https://learn.javascript.ru/browser-environment)
    - [Habr - Как работает JS (19 статей)](https://habr.com/ru/company/ruvds/blog/337042/)
    - [Habr - Знакомство с WebAssembly](https://habr.com/ru/post/342180/)
    - [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
    - [MDN - EventLoop](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
    - [Habr - Устройство движка JavaScript](https://habr.com/ru/sandbox/135800/)
    - [YouTube - Филипп Робертс: Что за чертовщина такая event loop?](https://youtu.be/8aGhZQkoFbQ) - Очень
      просто и понятно. Рекомендую
    - [Habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
    - [tproger.ru - Как эмулировать многопоточность в JavaScript](https://tproger.ru/translations/js-engine-macrotasks-microtasks/)
    - [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
    - [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
    - [Hexlet — Event loop](https://ru.hexlet.io/courses/js_async/lessons/event_loop/theory_unit)
    - [Hexlet — Окружение](https://ru.hexlet.io/courses/introduction_to_programming/lessons/env/theory_unit)
    - [alishoff - Как работает JS](https://alishoff.com/blog/184)
    - [Habr - Разбираемся с асинхронностью в JavaScript [Перевод статьи Sukhjinder Arora]](https://habr.com/ru/post/439620/)
    - [MDN - Введение в асинхронный JavaScript](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing)
    - [Doka - Асинхронность в JS](https://doka.guide/js/async-in-js/)
    - [dev-gang.ru - Как работает JavaScript: под капотом движка V8](https://dev-gang.ru/article/kak-rabotaet-javascript-pod-kapotom-dvizhka-v-5ew7muxdnq/)

  <br></p>
  </details>


***

[//]: # (Unsorted)
- <details><summary><b>Unsorted</b></summary><p>

    - Движок браузера выполняет JavaScript в одном потоке. Он не может поставить обработку события на паузу, переключиться на другое событие, а после — возобновить выполнение первого. Все события обрабатываются последовательно и каждое — до победного конца.
    - Для вышеописанного потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.
    - Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.

  ***

    - Любые данные от сервера запрашиваются асинхронно: отправляется запрос (XMLHttpRequest или XHR), и код не ждет его возвращения, продолжая выполняться. Когда же сервер, наконец, отвечает, объект XHR получает уведомление об этом и запускает функцию обратного вызова — callback, который передали в него перед отправкой запроса.

  ***
    - В любой момент времени выполняется только один контекст функции (тело функции). Вот почему JavaScript является однопотоковым, так как единовременно может выполняться только одна команда. Обычно браузеры поддерживают этот контекст с помощью стека — stack. Стек — структура данных, выполняемая в обратном порядке: LIFO — «последним пришёл — первым вышел». Последнее, что вы добавили в стек, будет удалено первым из него. Это происходит из-за того, что мы можем только добавить или удалить элементы из верхушки стека. Текущий или «выполняющийся» контекст исполнения — всегда верхний элемент стека. Он выскакивает из стека, когда код в текущем контексте полностью разобран, позволяя следующему верхнему элементу стека взять на себя контекст выполнения.
    - Кроме того, если контекст уже выполняется, это не означает, что ему нужно завершить своё выполнение, прежде чем другой контекст выполнения сможет начать работу. Бывают случаи, когда контекст приостанавливается и другой контекст начинает работу. Прерванный контекст может быть позже забран обратно наверх в том месте, где он был приостановлен. В любое время один контекст может быть заменён другим, и этот новый контекст поместится в стек, став текущим контекстом выполнения.

  ***
    - У динамических языков программирования существует стековая архитектура — stack-based implementations, локальные переменные и функции хранятся в стеке. Поэтому, во время выполнения стека, программа определяет какую переменную вы имеете в виду. С другой стороны, статическая область видимости — это когда переменные ссылаются на контекст и фиксируются на момент создания. Другими словами, структура исходного кода программы определяет к каким переменным вы обращаетесь.

  ***
    - Для лучшего понимания асинхронности неплохо разобраться с тем, как устроен рантайм (браузер или Node.js) JavaScript. JavaScript изначально появился в браузерах, и к нему предъявлялись особые требования, из-за которых он кардинально отличается от остальных языков программирования. Браузер работает по так называемой событийной модели. Он загружает страницу и ждёт действий от пользователя: клики, набор текста или движение мышкой. А код, загруженный на страницу, реагирует на эти события.
    - Такая организация взаимодействия невозможна в синхронном коде, у которого есть понятия "запуск" и "завершение" работы. Код в браузере не может завершиться совсем, он проходит стадию инициализации, а затем ждёт событий для реакции на них. Технически это выглядит, как колбек, который соединён с определённым типом события. Когда событие срабатывает, то колбек вызывается.

  <br></p>
  </details>

[//]: # (Однопоточность)
- <details><summary><b>Однопоточность</b></summary><p>

    - **JS - однопоточный язык.
    - Только один блок кода может запускаться за раз. Делает одну задачу в один момент времени.
    - С DOM-деревом работают в одном потоке, чтобы гарантировать целостность и непротиворечивость данных. Представьте себе -
      дв**а параллельных потока пытаются наперегонки поменять один и тот же узел в DOM... Плохая идея.

  <br></p>
  </details>

[//]: # (Синхронность)
- <details><summary><b>Синхронность</b></summary><p>

    - Что означает синхронность?
    - Например: есть 2 строки кода. Первая идет за второй.
    - Синхронность означает то, что строка 2 не может запуститься до тех пор, пока строка 1 не закончит своё выполнение.

    - Схема такая:

        - функция из очереди попадает в стэк
            - выполняется
            - стек очищается
            - в стек попадает следующая функция из очереди

    - Вариант немного сложнее:

        - функция 1 из очереди попадает в стек
            - внутри этой функции 1 находится вызов функции 2.
            - в стек попадает функция 2
            - она выполняется и удаляется
            - результат её выполнения записывается в функцию 1
            - функция 1 выполняется
            - стек очищается
            - в стек попадает следующая функция из очереди

  <br></p>
  </details>

[//]: # (Асинхронность)
- <details id="asynchrony"><summary><b>Асинхронность</b></summary><p>

    - `Асинхронность` — модель поведения
    - Есть две строчки кода, первая за второй. Первая строка это инструкция, для которой нужно время.
    - Первая строка начинает запуск этой инструкции в фоновом режиме.
    - Второй строка запускается без ожидания завершения первой.
    - 
    - В JS есть возможности асинхронного выполнения кода.
    - JS однопоточный (выполняет один блок за раз), но мы можем делать несколько действий через асинхронное исполнение
    - задач.
    - Для этого и придуманы `асинхронные функции` — выполняются не сразу, а после наступления события.
    - 
    - Асинхронное поведение нужно когда что-то тормозит.
    - Синхронность может быть медленной. Задачи вроде обработки изображений, операций с файлами, создание сетевых запросов и ожидание ответа — всё это может тормозить и быть долгим. Такие задачи в стеке запросов превращаются в «задержку» (blocking).
    - Когда стек запросов заблокирован, браузер препятствует вмешательству пользователя и выполнению другого кода до тех пор, пока “задержка” не выполнится и не освободит стек запросов.
    - В таких ситуациях используют `асинхронные колбэки` (callback).
    - Асинхронность позволяет пользовательскому интерфейсу веб-приложений нормально функционировать, реагировать на команды пользователя.
    - Каждый раз, когда вы упаковываете фрагмент кода в функцию и указываете, что она должна быть выполнена по некоторому событию (таймер, щелчок мышью, ответ Ajax и т. д.), вы создаете в своем коде блок «потом», а следовательно, вводите асинхронность в свою программу.

    - **Асинхронность с иcпользованием коллбэков**

        - Есть функция `A()`, которая делает долгую операцию (запрос по сети)
        - Есть функция `B()`, которой надо работать с результатом `A()`.
        - Просто написать в коде подряд `A(); B();` мы не можем - `B()` начнёт выполняться до того как `A()` получит данные.
        - Вариант решения: в `A()` вторым параметром передадим `B()`, чтоб `A()` запустила его когда будет готова.

      ```js
        function A(B) {
          /*Some long work*/
           B();
        }
      ```
    - В функцию, которая выполняет какие-либо асинхронные операции, передаём аргумент callback — функцию, которая будет
      вызвана по завершению асинхронного действия.

    - **Примеры асинхронности**<br>

        - функция `setTimeout()`
            - выполнение AJAX-запросов.
                - т.к. ожидание ответа может занять много времени, запросы можно делать асинхронно. Пока клиент ожидает ответа, может
                  выполняться код, не относящийся к запросу.

    - **Разное**
        - Система «планирует» нагрузку на цикл событий таким образом, чтобы в первую очередь выполнялись операции, связанные с
          пользовательским интерфейсом.
        - Ещё можно использовать `вебворкеры`, но из них нельзя менять DOM или вызывать методы объекта window. <br>
          Полезно, но не для всех случаев. Больше для вычислений

    - **Ссылки**
        - https://habr.com/ru/post/439620/
        - https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Introducing
        - https://doka.guide/js/async-in-js/
        - [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
        - [learn.javascript.ru - Микрозадачи](https://learn.javascript.ru/microtask-queue)

  <br></p>
  </details>

[//]: # (Последовательное и параллельное выполнение)
- <details><summary><b>Последовательное и параллельное выполнение</b></summary><p>

    - Асинхронность — управление промежутком между «сейчас» и «потом».
    - Параллелизм — возможность одновременного выполнения операций.
    - «Асинхронный» не равно «Параллельный».
    -
    - Самые распространенные средства организации параллельных вычислений
        - процессы
        - потоки (threads)
    - Процессы и потоки выполняются независимо и могут выполняться одновременно на разных процессорах и даже на разных компьютерах.
    - Но несколько потоков могут совместно использовать общую память одного процесса.
    -
    - Цикл событий разбивает свою работу на задачи и выполняет их последовательно. Это делает невозможным параллельный доступ и изменения в общей памяти. Параллелизм и последовательность не могут совместно существовать в форме взаимодействующих циклов событий в разных потоках.

  <br></p>
  </details>

[//]: # (Выполнение до завершения run-to-completion)
- <details><summary><b>Выполнение до завершения (run-to-completion)</b></summary><p>

    - Из-за однопоточного характера JavaScript код внутри функций foo() (и bar()) выполняется атомарно; это означает, что после того, как функция foo() начнет выполняться, весь ее код будет завершен до того, как будет выполнен какой-либо код bar(), и на-оборот. Это поведение называется выполнением до завершения (run-to-completion).

  <br></p>
  </details>

[//]: # (Контекст выполнения функции)
- <details id="asynchronyContext"><summary><b>Контекст выполнения функции</b></summary><p>

    - У каждого вызова функции есть свой «контекст выполнения» (execution context).

    - Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Структура в памяти.
    - Включает в себя локальные переменные функции, значение this и конкретное место в коде, на котором находится интерпретатор.

    - При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных –
      «стеке контекстов».

    - Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

    - **Ссылки**
        - [Habr - Контекст выполнения и стек вызовов в JavaScript](https://habr.com/ru/company/ruvds/blog/422089/)

  <br></p>
  </details>

[//]: # (Очередь - queue)
- <details><summary><b>Очередь (queue)</b></summary><p>

    - Очередь — структура данных. Доступа к элементам организован по принципу FIFO (First In — First Out) «первый пришёл —
      первый вышел» .

    - Добавление элемента (обозначают словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из
      начала очереди (называют словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется.

  <br></p>
  </details>

[//]: # (Стэк - stack)
- <details><summary><b>Стэк (stack)</b></summary><p>

    - Стек (анг. стопка) — структура данных (кусок памяти + опр правила работы с ним), представляющая из себя список
      элементов. Подобен стопке тарелок - последняя поступившая кладётся сверху, и должна быть обработана, прежде чем начнётся
      обработка "тарелки" под ней. LIFO (last in — first out) «последним пришёл — первым вышел»).

    - Вызов любой функции создает контекст выполнения.<br>
      При вызове вложенной функции создается новый контекст, а старый сохраняется в специальной структуре. Так формируется
      стек контекстов.

    - Максимальный размер стэка в в движке V8 16 000 (чего?). По достижению этого размера движок просто очищает стэк, чтоб всё
      не зависло.

    - Максимальное количество вызовов (рекурсивных или нет, не имеет значения) определяется:
        1. размером доступного `пространства стека`,
        2. деленным на размер каждого `кадра стека` активной функции (функций).

    - `1` имеет верхний предел, установленный операционной системой;
        - в системах, о которых я знаю, обычно это от 1 МБ до 8 МБ.
        - Ниже этого предела движок JavaScript может установить свой собственный предел.
        - V8 устанавливает ограничение чуть меньше одного мегабайта на всех платформах, чтобы разные платформы вели себя как можно более похоже друг на друга. Я не знаю, что делает Safari/JavaScriptCore.
    - `2` зависит от
        - деталей реализации движка JavaScript (в частности, сколько слотов в каждом кадре стека он использует для внутренних данных),
        - а также от количества локальных переменных в каждой из задействованных функций.

    - Обычно стек ограничивается только в случае случайной бесконечной рекурсии. Таким образом, для большинства реальных приложений конкретное значение ограничения не имеет значения, и больший стек не дает никаких преимуществ.

    - Обратите внимание, что пространство стека не связано с максимальным потреблением памяти (так называемое пространство `кучи`).<br>
      Вы можете иметь гигабайты `кучи` только с мегабайтом стека.
    -
    - Стек — это область оперативной памяти, которая создаётся для каждого потока.  Это очень быстрое хранилище памяти. Упарвляется процессором. Стэк работает в порядке LIFO (Last In, First Out),  то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.
    - Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит к высокой скорости, в особенности потому, что время цикла обновления байта стека очень мало, т.е. этот байт скорее всего привязан к кэшу процессора.
    - Тем не менее, у такой строгой формы управления есть и недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме того, переменные, расположенные на стеке, всегда являются локальными.
    - В итоге стек позволяет управлять памятью наиболее эффективным образом — но если вам нужно использовать динамические структуры данных или глобальные переменные, то стоит обратить внимание на кучу.
    -
    -
    - **Ссылки**
        - [tproger.ru — Основные принципы программирования: стек и куча](https://tproger.ru/translations/programming-concepts-stack-and-heap?ysclid=loo43hl5rb135912066)

  <br></p>
  </details>

[//]: # (Куча - heap)
- <details><summary><b>Куча (heap)</b></summary><p>

    - Динамически распределяемая память. Часть JS-движка? (также как и стэк)
    -
    - `Куча` (heap) — зарезервированная область памяти, также расположенная в ОЗУ. Допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных.
    - Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.
    - Вы взаимодействуете с кучей посредством ссылок, обычно называемых указателями — это переменные, чьи значения являются адресами других переменных. Создавая указатель, вы указываете на местоположение памяти в куче, что задаёт начальное значение переменной и говорит программе, где получить доступ к этому значению. Из-за динамической природы кучи ЦП не принимает участия в контроле над ней; в языках без сборщика мусора (C, C++) разработчику нужно вручную освобождать участки памяти, которые больше не нужны. Если этого не делать, могут возникнуть утечки и фрагментация памяти, что существенно замедлит работу кучи.
    - Управлять памятью кучи должен либо сборщик мусора, либо сам программист, да и работает куча медленнее.
    - В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает её важности — если вам нужно работать с динамическими или глобальными переменными, пользуйтесь кучей.
    -
    - **Ссылки**
        - [tproger.ru — Основные принципы программирования: стек и куча](https://tproger.ru/translations/programming-concepts-stack-and-heap?ysclid=loo43hl5rb135912066)

  <br></p>
  </details>

[//]: # (Event Loop. Web API)
- <details><summary><b>Event Loop. Web API</b></summary><p>


    - Асинхронные функции — не часть JavaScript-движков. Вызов setTimeout на чистом V8 приводит к ошибке, так как в V8 нет такой функции. Асинхронные операции выполняются не в движке, а в окружении. Например, в Web API браузера.
    -
    - В принципе, мы можем из стека вызовов сразу же положить функцию в очередь вызовов и таким образом чистый движок тоже будет работать асинхронно. Но это редкий фокус.
    -
    - Web API и JS движок работают независимо. Web API решает, в какой момент функция двигается дальше, в очередь вызовов JS движка. Т.е. окружение самостоятельно решает, когда добавить переданный ей код в очередь вызовов.
    -
    - Функции в очереди вызовов попадают в JavaScript-движок, где выполняются по одной. Выполнение происходит в том же порядке, в котором функции попадают в очередь. Функции из очереди добавляются в стек выполнения (выполняются) не раньше, чем стек вызовов закончит работу над текущей функцией.
    -
    - *Стек вызовов движка работает синхронно. Web API работает асинхронно.*
    -
    - В очереди вызовов нельзя отменять отдельные операции. Это делается в окружении (пример: removeEventListener).
    - 
    - 
    - Web API - часть браузера. Еслив стэк попадает какая-то асинхронная функция, например setTimeout - она передаётся в Web API. А стэк продолжает работать как обычно, как будто эта функция выполнилась.
    - Когда придёт время (таймер сработла, или пришёл ответ AJAX) - Web API выдаст функцию обратно. Но не в стэк (чтоб не нарушить то, над чем стэк работает сейчас) Web API поставит это в очередь выполнения задач.
    - Event Loop (цикл обработки событий) - смотрит состояние стэка и очереди колбэков. Как только стэк становится пуст - EventLopp берёт первый Элемент из очереди и передаёт его в стэк. Всё. Никакой магии
    - Цикл событий решает одну основную задачу: наблюдает за стеком вызовов и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие из очереди и помещает его в стек, что приводит к запуску этого события на выполнение.
    - Подобная итерация называется тиком (tick) цикла событий. Каждое событие — это просто коллбэк
    - 
    - Web API
      - Расширения браузера. Не входят в состав движка JS.
      - Но, в движке есть возможность взаимодействовать с этими API.
      - Примеры: setTimeout, DOM, AJAX (XMLHttpRequest), геолокация, аудио, видео...

  <br></p>
  </details>

[//]: # (setTimeout with callback 0 )
- <details><summary><b>setTimeout(callback(), 0)</b></summary><p>

  Позволяет запланировать что-то сразу после выполнения основного кода<br>
  Выполнить что-то как только стэк очистится. Т.е. в текущем потоке кода этот колбэк не запускается, и код идёт так, будто
  setTimeout и его содержимого просто нет (на самом деле он вылетает из стэка в WebAPI, И оттуда сразу же встаёт в
  очередь. А когда этот кусок кода закончится и стэк станет пустым - вот тогда выполнится колбэк из SetTimeout

  SetTimeout гарантирует минимальную задержку.<br>
  Код выполнится не раньше, чем через Х секунд. <br>
  По прошествии Х он встанет в очередь и будет ждать пока:

    - очистится стэк,
    - освободится очередь перед кодом из таймера.

  ```js
    console.log('1')
    setTimeout(function foo() {
      console.log('2')
    }, 0)
    console.log('3')
  
    //Выведет в консоль:
    1
    3
    2
    ```

  <br></p>
  </details>

[//]: # (setInterval)
- <details><summary><b>setInterval()</b></summary><p>

  Предположим, мы кликнули мышью и в процессе этого ещё запустили `setInterval`.

  Пока обработчик клика мышью выполняется, срабатывает первый interval-callback. Он будет поставлен в очередь. <br>
  Когда снова сработает interval, то он будет удален из очереди.<br>

  Если у нас выполняется большой кусок кода, и очередь заблокирована — новые interval-callback не ставятся в очередь. <br>
  Ждут пока она очистится. Кажется так.

  Если бы все interval-callback'и попадали в очередь пока исполняется большой кусок кода, это бы привело к тому, что образовалась бы куча функций, ожидающих вызова без периодов задержек между окончанием их выполнения. Вместо этого браузеры стремятся ждать пока не останется ни одной функции в
  очереди прежде чем добавить в очередь еще один setInterval.

  <br></p>
  </details>

[//]: # (Browser events)
- <details><summary><b>Browser events</b></summary><p>

    - Какие же события происходят в браузере?
    - Их великое множество: клики мышкой; скроллинг; ввод с клавиатуры; загрузка скриптов; CSS анимации; и тд.

    - Браузер может реагировать на эти события. Для этого событию нужно назначить обработчик, то есть функцию, которая сработает, когда событие произошло. Функция выполнится не сразу, она станет в конец очереди событий и выполнится, когда придёт её время.

  <br></p>
  </details>

[//]: # (Картинки)
- <details><summary><b>Картинки</b></summary><p>

  <img src="/Assets/Img/js-schema-1.png" title="Схема 1" alt="Схема 1" />
  <br>

  <img src="/Assets/Img/js-schema-2-min.jpg" title="Схема 2" alt="Схема 2" />
  <br>

  <img src="/Assets/Img/js-schema-3-min.jpg" title="Схема 3" alt="Схема 3" />

  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

    - [Legmo notes — Задачки для собеседования frontend. Console.log](../JobSearch/InterviewTasks.md#task-1)
    - [YouTube - Как на самом деле работает EventLoop (26 мин)](https://youtu.be/8cV4ZvHXQL4) - Очень просто и понятно.
    - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=_kw1Sn1xA91g2-Oh)
    - [YouTube - Филипп Робертс: Что за чертовщина такая event loop? (26 мин) Он же?](https://youtu.be/8aGhZQkoFbQ) - Очень
      просто и понятно.
      Рекомендую
    - [learn.javascript.ru - Событийный цикл (event-loop)](https://learn.javascript.ru/event-loop)
    - [Medium - Движки JavaScript. Часть 1: парсинг](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-%D0%BF%D0%B0%D1%80%D1%81%D0%B8%D0%BD%D0%B3-754a8d60df23)
    - [Medium - Движки JavaScript. Часть 2: генерация кода и базовые оптимизации](https://medium.com/nuances-of-programming/%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B8-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-fb66fd238769)
    - [Habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
    - [Habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
    - [Habr - Знай свой инструмент: Event Loop](https://habr.com/ru/post/336498/)
    - [learnjavascript - Управление памятью в JavaScript](https://learn.javascript.ru/memory-management)
    - [learn.javascript.ru (en)](https://javascript.info/async-await)
    - [JavaScript event loop в картинках . Часть 1](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-a19e4d99f242)
    - [JavaScript event loop в картинках . Часть 2](https://medium.com/@pavelbely/javascript-event-loop-%D0%B2-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D1%85-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-f98693f6a1d8)
    - [Стеки и очереди в JavaScript](http://shuvalov.info/2013/03/21/stack-and-queue/)
    - [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
    - [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)
    - [Hexlet](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/event-loop/theory_unit)
    - [Hexlet — Окружение](https://ru.hexlet.io/courses/introduction_to_programming/lessons/env/theory_unit)
    - [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
    - [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://habr.com/ru/company/ruvds/blog/340508/)
    - [Как эмулировать многопоточность в JavaScript](https://tproger.ru/translations/js-engine-macrotasks-microtasks/)
    - [pythontutor - как работает JS код](http://pythontutor.com/javascript.html#mode=display)
    - [learnjavascript - Про события и асинхронность](https://learn.javascript.ru/events-and-timing-depth)
    - [Замыкания в JavaScript](https://htmlacademy.ru/blog/useful/javascript/lets-learn-javascript-closures)
    - [Ад обратных вызовов](http://callbackhell.ru/)
    - [Асинхронное программирование: концепция, реализация, примеры](https://proglib.io/p/asynchrony/)
    - [Дока - Асинхронность в JS](https://doka.guide/js/async-in-js/)
    - [Kyle Simpson - Вы не знаете JS. Асинхронность и Производительность](https://github.com/azat-io/you-dont-know-js-ru/blob/master/async%20%26%20performance/README.md#you-dont-know-js-async--performance)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Сборщик мусора todo: допоплнить)
<details id="garbageCollection"><summary><b>Сборщик мусора *</b></summary><p>

- `Сборщик мусора` — фоновый процесс в движке JS. Отслеживает все объекты и удаляет те, которые стали недоступными.

- Кратко:
    - Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
    - Объекты сохраняются в памяти, пока они достижимы (т.е. доступны или используются).
    - Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.

- Есть базовое множество достижимых значений, которые не могут быть удалены.
    - Выполняемая в данный момент функция, её локальные переменные и параметры.
    - Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
    - Глобальные переменные.
    - (некоторые другие внутренние значения)
- Эти значения мы будем называть `корнями`.
- Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
    - Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.


- **Альтернативные методы управления памятью**
    - ручное управлением памятью
    - автоматическое
        - автоматический вызов деструктора при выходе объекта из области синтаксической видимости (C++, Ада, Delphi)
        - технология использования «умных ссылок» — ссылка на динамический объект сама отслеживает число пользователей и автоматически удаляет объект, когда это число становится нулевым.
        - управление памятью на основе регионов — технология, в которой память делится на относительно крупные фрагменты, называемые регионами, и уже внутри регионов память выделяется отдельным объектам.
        - концепция «владения», основанную на жёстком контроле со стороны компилятора соответствия времени жизни и области видимости объектов. Пример: Rust

- Ссылки:
    - [learn.javascript.ru - Сборщик мусора](https://learn.javascript.ru/garbage-collection)
    - [Wikipedia — Сборка муcора](https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0)

<br></p>
</details>

[//]: # (Утечки памяти в JS todo: доработать)
<details id="memoryLeak"><summary><b>Утечки памяти в JS *</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Фрагменты памяти, которые больше не нужны приложению, но почему-то не возвращённы операционной системе или в пул свободной памяти.

  - Разные языки по-разному управляют памятью. Проблема точного определения используется ли на самом деле некий участок памяти или нет, **неразрешима**. Только разработчик знает, можно или нет вернуть операционной системе некую область памяти.

  <br><p>
  </details>

[//]: # (1. Глобальные переменные - неявное объявление)
- <details><summary><b>1. Глобальные переменные - неявное объявление</b></summary><p>

  - Пример:
    - ```js
        function foo(arg) {
          bar = "скрытая глобальная переменная"; // это то же: window.bar = "явно объявленная глобальная переменная";
        }
      ```    
  - Решение: добавляйте 'use strict'; в начало JavaScript-файлов

  <br><p>
  </details>

[//]: # (2. Глобальные переменные - явно объявленные, не вычищенные)
- <details><summary><b>2. Глобальные переменные - явно объявленные, не вычищенные (кэши и т.д.)</b></summary><p>

  - Это касается глобальных переменных, использующихся для временного хранения и обработки больших блоков данных. Если вам нужна глобальная переменная, чтобы записать в неё большое количество информации, убедитесь, что в конце работы с данными её значение будет установлено в null или переопределено.
  - Примером увеличенного расхода памяти, связанным с глобальными переменными, являются кэши — объекты, которые сохраняют повторно используемые данные. Для эффективной работы их следует ограничивать по размеру. Если кэш увеличивается без ограничений, он может привести к высокому расходу памяти, поскольку его содержимое не может быть очищено сборщиком мусора.
  - 
  - В JS используется интересный подход к работе с необъявленными переменными. Обращение к такой переменной создаёт новую переменную в глобальном объекте. В случае с браузерами, глобальным объектом является window.
  - Рассмотрим такую конструкцию:
    - ```js
      function foo(arg) {
        bar = "some text";
      }

      //Она эквивалентна следующему коду:
      function foo(arg) {
        window.bar = "some text";
      }
      ```
  - 
  - Если переменную bar планируется использовать только внутри области видимости функции foo, и при её объявлении забыли о ключевом слове var, будет случайно создана глобальная переменная.
  - В этом примере утечка памяти, выделенной под простую строку, большого вреда не принесёт, но всё может быть гораздо хуже.
  - Другая ситуация, в которой может появиться случайно созданная глобальная переменная, может возникнуть при неправильной работе с ключевым словом this:
  - ```js
    function foo() {
      this.var1 = "potential accidental global";
    }

    // Функция вызывается сама по себе, при этом this указывает на глобальный объект (window),
    // this не равно undefined, или, как при вызове конструктора, не указывает на новый объект
    foo();
    ```
  - 
  - Для того, чтобы избежать подобных ошибок, можно добавить оператор "use strict"; в начало JS-файла. Это включит так называемый строгий режим, в котором запрещено создание глобальных переменных вышеописанными способами. Подробнее о строгом режиме можно почитать здесь.
  - Даже если говорить о вполне безобидных глобальных переменных, созданных осознанно, во многих программах их слишком много. Они, по определению, не подвергаются сборке мусора (если только в такую переменную не записать null или какое-то другое значение). В частности, стоит обратить пристальное внимание на глобальные переменные, которые используются для временного хранения и обработки больших объёмов данных. Если вы вынуждены использовать глобальную переменную для хранения большого объёма данных, не забудьте записать в неё null или что-то другое, нужное для дальнейшей работы, после того, как она сыграет свою роль в обработке большого объёма данных.

  <br><p>
  </details>

[//]: # (3. Таймеры или забытые коллбэки)
- <details><summary><b>3. Таймеры или забытые коллбэки</b></summary><p>

  - Пример:
    - ```js
        var someResource = getData();
        setInterval(function () {
          var node = document.getElementById('Node');
          if (node) {
            // Сделаем что-нибудь с node и someResource.
            node.innerHTML = JSON.stringify(someResource);
          }
          ;
        }, 1000);
      ```
  - 
  - В JS-программах использование функции setInterval — обычное явление.
  - 
  - Большинство библиотек, которые дают возможность работать с обозревателям и другими механизмами, принимающими коллбэки, заботятся о том, чтобы сделать недоступными ссылки на эти коллбэки после того, как экземпляры объектов, которым они переданы, становятся недоступными. Однако, в случае с setInterval весьма распространён следующий шаблон:
    - ```js
        var serverData = loadData();
        setInterval(function () {
          var renderer = document.getElementById('renderer');
          if (renderer) {
            renderer.innerHTML = JSON.stringify(serverData);
          }
        }, 5000); //Это будет вызываться примерно каждые 5 секунд.
      ```
  - 
  - В этом примере показано, что может происходить с таймерами, которые создают ссылки на узлы DOM или на данные, которые в
  определённый момент больше не нужны.
  Объект, представленный переменной renderer, может быть, в будущем, удалён, что сделает весь блок кода внутри обработчика события срабатывания таймера ненужным. Однако, обработчик нельзя уничтожить, освободив занимаемую им память, так как таймер всё ещё активен. Таймер, для очистки памяти, надо остановить. Если сам таймер не может быть подвергнут операции сборки мусора, это будет касаться и зависимых от него объектов. Это означает, что память, занятую переменной serverData, которая, надо полагать, хранит немалый объём данных, так же нельзя очистить.
  - В случае с обозревателями, важно использовать явные команды для их удаления после того, как они больше не нужны (или после того, как окажутся недоступными связанные объекты).
  - Раньше это было особенно важно, так как определённые браузеры (старый добрый IE6, например) были неспособны нормально обрабатывать циклические ссылки. В наши дни большинство браузеров уничтожают обработчики обозревателей после того, как объекты обозревателей оказываются недоступными, даже если прослушиватели событий не были явным образом удалены. Однако, рекомендуется явно удалять эти обозреватели до уничтожения объекта. Например:
    - ```js
        var element = document.getElementById('launch-button');
        var counter = 0;

        function onClick(event) {
          counter++;
          element.innerHtml = 'text ' + counter;
        }

        element.addEventListener('click', onClick);
        // Сделать что-нибудь
        element.removeEventListener('click', onClick);
        element.parentNode.removeChild(element);
        // Теперь, когда элемент выходит за пределы области видимости,
        // память, занятая обоими элементами и обработчиком onClick будет освобождена даже в старых браузерах,
        // которые не способны нормально обрабатывать ситуации с циклическими ссылками.
      ```
  - В наши дни браузеры (в том числе Internet Explorer и Microsoft Edge) используют современные алгоритмы сборки мусора, которые выявляют циклические ссылки и работают с соответствующими объектами правильно. Другими словами, сейчас нет острой необходимости в использовании метода removeEventListener перед тем, как узел будет сделан недоступным.
  - Фреймворки и библиотеки, такие, как jQuery, удаляют прослушиватели перед уничтожением узлов (при использовании для выполнения этой операции собственных API). Всё это поддерживается внутренними механизмами библиотек, которые, кроме того, контролируют отсутствие утечек памяти даже если код работает в не самых благополучных браузерах, таких как уже упомянутый выше IE 6.
  <br><p>
  </details>

[//]: # (4. Забытые обработчики событий)
- <details><summary><b>4. Забытые обработчики событий</b></summary><p>

  - Обработчики следует удалять, когда они становятся не нужны, или ассоциированные с ними объекты становятся недоступны.
  - В прошлом это было критично, так как некоторые браузеры (Internet Explorer 6) не умели грамотно обрабатывать циклические ссылки.
  - Большинство современных браузеров удаляет обработчики событий, как только объекты становятся недостижимы. <br>
  - Однако по-прежнему правилом хорошего тона остаётся явное удаление обработчиков событий перед удалением самого объекта.
  - Рекомендуется явно удалять обработчики событий (removeEventListener) до удаления DOM-узлов или обнулять ссылки внутри обработчиков.

  <br><p>
  </details>

[//]: # (5. Замыкания)
- <details><summary><b>5. Замыкания</b></summary><p>

  - Одна из важных и широко используемых возможностей JavaScript — замыкания. Это — внутренняя функция, у которой есть доступ к переменным, объявленным во внешней по отношению к ней функции. Особенности реализации среды выполнения JavaScript делают возможной утечку памяти в следующем сценарии:
    - ```js
        var theThing = null;
        var replaceThing = function () {
          var originalThing = theThing;
          var unused = function () {
            if (originalThing) // ссылка на originalThing
              console.log("hi");
          };
          theThing = {
            longStr: new Array(1000000).join('*'),
            someMethod: function () {
              console.log("message");
            }
          };
        };
        setInterval(replaceThing, 1000);
      ```
  - Самое важное в этом фрагменте кода то, что каждый раз при вызове replaceThing, в theThing записывается ссылка на новый объект, который содержит большой массив и новое замыкание (someMethod). В то же время, переменная unused хранит замыкание, которое имеет ссылку на originalThing (она ссылается на то, на что ссылалась переменная theThing из предыдущего вызова replaceThing). Во всём этом уже можно запутаться, не так ли? Самое важное тут то, что когда создаётся область видимости для замыканий, которые находятся в одной и той же родительской области видимости, эта область видимости используется ими совместно.
  - В данном случае в области видимости, созданной для замыкания someMethod, имеется также и переменная unused. Эта переменная ссылается на originalThing. Несмотря на то, что unused не используется, someMethod может быть вызван через theThing за пределами области видимости replaceThing (то есть — из глобальной области видимости). И, так как someMethod и unused находятся в одной и той же области видимости, ссылка на originalThing, записанная в unused, приводит к тому, что эта переменная оказывается активной (это — общая для двух замыканий область видимости). Это не даёт нормально работать сборщику мусора.
  - Если вышеприведённый фрагмент кода некоторое время поработает, можно заметить постоянное увеличение потребления им памяти. При запуске сборщика мусора память не освобождается. В целом оказывается, что создаётся связанный список замыканий (корень которого представлен переменной theThing), и каждая из областей видимости этих замыканий имеет непрямую ссылку на большой массив, что приводит к значительной утечке памяти.
  Эту проблему обнаружила команда Meteor, у них есть отличная статья, в которой всё это подробно описано.

  <br><p>
  </details>

[//]: # (6. Ссылки на элементы, удалённые из DOM)
- <details><summary><b>6. Ссылки на элементы, удалённые из DOM</b></summary><p>

  - Ссылки на объекты DOM за пределами дерева DOM
  - Иногда может оказаться полезным хранить ссылки на узлы DOM в неких структурах данных. Например, предположим, что нужно быстро обновить содержимое нескольких строк в таблице. В подобной ситуации имеет смысл сохранить ссылки на эти строки в словаре или в массиве. В подобных ситуациях система хранит две ссылки на элемент DOM: одну из них в дереве DOM, вторую — в словаре. Если настанет время, когда разработчик решит удалить эти строки, нужно позаботиться об обеих ссылках.
    - ```js
        var elements = {
          button: document.getElementById('button'),
          image: document.getElementById('image')
        };

        function doStuff() {
          image.src = 'http://example.com/image_name.png';
        }

        function removeImage() {
          // Изображение является прямым потомком элемента body.
          document.body.removeChild(document.getElementById('image'));
          // В данный момент у нас есть ссылка на #button в
          // глобальном объекте elements. Другими словами, элемент button
          // всё ещё хранится в памяти, она не может быть очищена сборщиком мусора.
        }
      ```
  -
  - Есть ещё одно соображение, которое нужно принимать во внимание при создании ссылок на внутренние элементы дерева DOM или на его концевые вершины.
  - Предположим, мы храним ссылку на конкретную ячейку таблицы (тег <td>) в JS-коде. Через некоторое время решено убрать таблицу из DOM, но сохранить ссылку на эту ячейку. Чисто интуитивно можно предположить, что сборщик мусора освободит всю память, выделенную под таблицу, за исключением памяти, выделенной под ячейку, на которую у нас есть ссылка В реальности же всё не так. Ячейка является узлом-потомком таблицы. Потомки хранят ссылки на родительские объекты. Таким образом, наличие ссылки на ячейку таблицы в коде приводит к тому, что в памяти остаётся вся таблица. Учитывайте эту особенность, храня ссылки на элементы DOM в программах.
  
  <br><p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Habr](https://habr.com/ru/post/309318/)
  - [Habr - Как работает JS: управление памятью, четыре вида утечек памяти и борьба с ними](https://habr.com/ru/company/ruvds/blog/338150/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Callback todo: упростить)
<details id="callback"><summary><b>Callback *</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback – функция обратного вызова).

  - Сами не вызываем функцию. Отдаём её как аругмент в другую функции, и та вызывает, когда сочтёт нужным.

  - Чуть сложнее: В JavaScript функции – это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. А любая функция, которая передается как аргумент, называется callback-функцией.
  - 
  - Пример: 
    - `<button onClik={function}>txt</button>`
    - Когда произойдёт событие onClick, кнопка вызовет эту функцию.
    - Нет скобок после function - мы не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо. От своего имени
  -
  - Неправильно: 
    - `<button onClik={function()}>txt</button>`
    - Здесь функция не передаётся, а сразу вызывается.
  - 
  - 
  - Коллбэки являются самым распространённым средством выражения и выполнения асинхронных действий в программах на JavaScript. Более того, коллбэк является наиболее фундаментальным асинхронным шаблоном языка. Бесчисленное множество JS-приложений, даже весьма хитроумных и сложных, основано исключительно на коллбэках.
  - 
  - Обратные вызовы — фундаментальная часть JavaScript (поскольку являются просто функциями), и вы должны научиться читать и писать их прежде, чем переходить к более продвинутым функциям языка, так как все они зависят от понимания обратных вызовов. Если вы пока не можете написать удобный для поддержки код обратных вызовов, то продолжайте работать над этим.
  -   
  - Некоторые функции называются «обратный вызов» т.к. через них цикл событий обращается с «обратным вызовом» к программе при обработке соответствующего элемента в очереди.
  - Паттерн «обратный вызов» является самым фундаментальным асинхронным паттерном в языке.
  -
  - Обратные вызовы — фундаментальная структурная единица асинхронного выполнения в JS. Тем не менее для развивающегося по мере становления JS ландшафта асинхронного программирования их становится недостаточно. 

  <br></p>
  </details>

[//]: # (Зачем)
- <details><summary><b>Зачем?</b></summary><p>

  - JS - событийно-ориентированный язык. Если функция не отвечает немедленно (например выполянет AJAX-запрос или Timeout) -
  - JS не будет останавливать работу, ожидая ответа. Он продолжит выполнение других функций, одновременно ожидая ответа от нашей функции. Вывод: нельзя просто вызывать функции в нужном порядке и надеяться, что они в обязательно выполнятся в том же порядке.<br>
  - Пример:
    - ```js
        function first(){
          // Как будто бы запрос к API
          setTimeout( function(){
            console.log(1);
          }, 500 );
        }
        function second(){
          console.log(2);
        }
        first();
        second();
        
        //Выдаст ответ:
        // 2
        // 1
      ```
  - 
  - Коллбэки позволяют нам быть уверенными в том, что определенный код не начнет исполнение до того момента, пока другой код не завершит исполнение.
  
  <br></p>
  </details>

[//]: # (Коллбэки и контекст)
- <details><summary><b>Коллбэки и контекст</b></summary><p>

  - При вызове callback может нарушиться контекст вызова `this`. Т.е. отвалиться привязка `this` к родительскому объекту.
    - ```
        <App
          addQuote={store.addQuote}
        />
      ```
  - В таком случае, при создании callback надо сделать привязку контекста - `.bind`
    - ```
        <App
          addQuote={store.addQuote.bind(store)} 
        />
      ```
  - 
  - Функции `call()` и `apply()` - ещё один способ вызова callback-функции.<br>
  - Здесь мы сами устанавливаем контекст, в котором выполняется функция.<br>
  - Т.е. когда мы используем ключевое слово `this` внутри нашей callback-функции, оно ссылается на то, что мы передаём первым аргументом в `call()`/`apply()`. (см. ниже)
  -
  - Пример:
    - ```js
        function showFullName(){alert(`что-нибудь`)}
        var user = {...}
        function_name.call(user); // вызываем колбек и в качестве контекста this передаём ему user
      ```

  <br></p>
  </details>

[//]: # (Проблемы асинхронного кода на колбэках)
- <details><summary><b>Проблемы асинхронного кода на колбэках</b></summary><p>

  - Код трудно понимать — надо постоянно переключать внимание между разными функциями, скакать по кодовой базе
    - Мозг все планирует последовательно, с блокировкой и с однопоточной семантикой, но обратные вызовы выражают асинхронную последовательность выполнения в нелинейном и непоследовательном виде, что сильно затрудняет правильный анализ такого кода. Код, который трудно анализировать, — это плохой код, который приводит к ошибкам. Нам необходим способ выражения асинхронности в более синхронном, последовательном, блокирующем виде, то есть так, как работает наш мозг.
  - При чтении кода часто непонятно — какая часть асинхронная, какая синхронная. Трудно анализировать
  - Проблема доверия — происходит инверсия управления. 
    - Я передаю свою функцию (в виде колбэка) куда-то ещё, часто в чужую функцию. И я не знаю, и не могу контролировать как она будет там выполняться, насколько правильно. Сколько раз и когда вызовется, какие в неё попадут параметры, как будут обработаны ошибки... обратные вызовы подвержены инверсии управления. Иначе говоря, они неявно передают управление другой стороне (часто стороннему коду, который вам неподконтролен), которая должна активизировать продолжение вашей программы. Передача управления открывает целый список проблем доверия: например, не будет ли функция обратного вызова вызываться чаще, чем вы ожидаете.
    -  Одна из проблем доверия — слишком ранний вы-зов (`проблема Залго`). В контексте приложения это может означать вызов до завершения некоторого критического условия.Но на более общем уровне проблема проявляется в утилитах, которые могут вызвать функцию обратного вызова переданную вами либо сейчас (синхронно), либо потом (асинхронно). Недетерминизм, окружающий поведение «синхронно/асинхронно», почти всегда порождает ошибки, которые бывает очень трудно найти. В определенных кругах для описания кошмара «синхронно/асинхронно» используется вымышленный монстр по имени Залго, наводящий безумие. Распространенный призыв «Не  выпускайте Залго!» ведет к очень разумному совету: всегда активизируйте обратные вызовы асинхронно, даже если они отработают прямо на следующей итерации цикла событий, чтобы все обратные вызовы были предсказуемо асинхронными.
    - Надо избежать инверсии управления + связанных с этим проблем доверия
  - 
  - 
  - Можно изобрести специализированную логику для решения подобных проблем, «костыли» для коллбэков. 
  - Но сделать сложнее, чем хотелось бы, а полученный код оказывается более неуклюжим, сложным в сопровождении и, скорее всего, недостаточно защищенным от этих рисков.
  - Ответ на эти вопросы — Promises (включая async/await) и генераторы. А также Web-workers и SIMD 

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Колбэки](https://learn.javascript.ru/callbacks)
  - [Habr - Понимание callback-функций (колбеков)](https://habr.com/ru/post/151716/)
  - [Habr - Коллбэк в JavaScript… Что за зверь?](https://habr.com/ru/company/ruvds/blog/330880/)
  - [Hexlet - Что такое callback-функция в JavaScript?](https://ru.hexlet.io/blog/posts/javascript-what-the-heck-is-a-callback)
  - [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://m.habr.com/ru/company/ruvds/blog/340508/)
  - [Ад обратных вызовов](http://callbackhell.ru/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Промисы — Promises )
<details id="promise"><summary><b>Промисы — Promises</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Способ организации асинхронного кода.
  - Объект, который содержит своё состояние — ожидание, выполнен успешно, ошибка.
  - Позволяет вызывать разные коллбеки в зависимости от результата — одни для успеха, другие для ошибок.
  - 
  - Промисы можно объединять в цепочки — замена «пирамиды вложенных колбэков».
  - Выполняем асинхронную операцию, с результатами её работы выполняем другую асинхронную операцию и т.д.

  <br></p>
  </details>

[//]: # (Способ использования. Описание 1)
- <details><summary><b>Способ использования. Описание 1</b></summary><p>

  - создаём специальный объект-промис (через конструктор `new Promise()`),
  - в этом объекте находится `функция-исполнитель` и у неё два коллбека — `resolve`/`rejected` (функция завершилась
    удачно/неудачно)
  - в эту функцию пишем свой код (например асинхронный запрос). Функция вызывается автоматически при создании промиса (т.е
    когда JS-парсер доходит до этого места кода).
  - внутри функции, по результатам работы, вызываем коллбеки resolve/rejected. Если второй вариант не интересует - можно
    вызвать только один, например на успех.
  - в коллбек resolve/rejected передаю результат работы функции-исполнителя или ошибку. Эти данные поступят в `обработчик`
    , и там с ними можно работать.
  - после промиса добавляем к нему `конструкции-обработчики` (then/catch/finally) - выполнят разные действия, в
    зависимости
    от результатов выполнения функции в промисе (resolve/rejected).
  - обработчики .then/.catch тоже возвращает объект-промис - можно строить длинные цепочки
  - в конце цепочки обработчиков (один или несколько .then) обязательно ставить catch/finally — обработать ошибки, чтоб
    вся система не упала.

  <br></p>
  </details>

[//]: # (Способ использования. Описание 2)
- <details><summary><b>Способ использования. Описание 2</b></summary><p>

  1. В основном коде пишем `new Promise()` и внутри запускаем асинхронную функцию
  2. Асинхронная функция создаёт объект `promise` и возвращает его.
  3. В основном коде мы принимаем объект `promise` и навешиваем на него обработчики (одни - на успех, другие - на ошибку).
  4. Когда код асинхронной функции завершается, он переводит promise в состояние `fulfilled(результат)`
     или `rejected(ошибка)`. При этом автоматически вызываются соответствующие обработчики в основном коде.

  <br></p>
  </details>

[//]: # (Свойства объекта "promise")
- <details><summary><b>Свойства объекта `promise`</b></summary><p>

  - возвращается конструктором `new Promise`
  - `state` («состояние»)
    - вначале `pending` («ожидание»),
    - затем либо `fulfilled` («выполнено успешно») gри вызове resolve
    - либо `rejected` («выполнено с ошибкой») при вызове reject
  - `result` («результат»)
    - вначале `undefined`,
    - при вызове `resolve(value)` меняется на `value`
    - при вызове `reject(error)` меняется на `error`

  <br></p>
  </details>

[//]: # (Обработчики промиса)
- <details><summary><b>Обработчики промиса</b></summary><p>

  - назначаются вызовом `then`/`catch`/`finally`
  - `.then` = универсальный метод для навешивания обработчиков-колбэков:
    - `promise.then(onFulfilled, onRejected)` //первый сработает если промис завершился удачно, второй сработает при
      неудаче
    - `promise.then(onFulfilled)` //сработает если промис завершился удачно, при неудаче ничего не произойдёт
    - `promise.then(null, onFulfilled)` //сработает если промис завершился неудачно, при удаче ничего не произойдёт
    - Внутри .then обязательно должна быть функция.
      - Всё кроме функции интерпретируется как then(null) и в следующий по цепочке обработчик «проваливается» результат
        предыдущего.
      - ```js
        //Вариант с ошибкой
        Promise.resolve('foo')
        .then(Promise.resolve('bar')) //нет функции => вернёт null
        .then(function (result) {
          console.log(result); //'foo' - «провалился» из первой строки
        });
        
        //То же самое
        Promise.resolve('foo')
        .then(null) 
        .then(function (result) {
          console.log(result); //'foo' - «провалился» из первой строки
        });
        
        //Вариант с другой ошибкой
        Promise.resolve('foo')
        .then(() => {Promise.resolve('bar');}) //в then функция, но она не делает return — вренёт undefined
        .then(result => {
          console.log(result); //'undefined'
        });
        
        //Вариант без ошибки 1
        Promise.resolve('foo')
        .then(() => {return Promise.resolve('bar');}) //функция + return результатов работы Promise
        .then(result => {
          console.log(result); //'bar'
        });
              
        //Вариант без ошибки 2
        Promise.resolve('foo')
        .then(someFunc()) //функция выполнится
        .then(result => {
          console.log(result); //Если в someFunc() есть return - выведутся отправленные ей данные. Иначе undefined.
        });
        ```
    - Если хочешь передать данные в следующий обработчик - должен быть `return`
      - Если в обработчике нет `return` — обработчик возвращает undefined
      - ```js
        //Вариант с ошибкой
        Promise.resolve('foo')
        .then(() => {Promise.resolve('bar');}) //Не делает return — вренёт undefined
        .then(result => {
          console.log(result); //'undefined'
        });
        
        //Вариант без ошибки
        Promise.resolve('foo')
        .then(() => {return Promise.resolve('bar');}) //Есть return результатов работы Promise
        .then(result => {
          console.log(result); //'bar'
        });
        ```
    - Можем сделать три вещи
      - Вернуть (return) другой промис
        - в `return` пишем другой промис, когда он выполнится - его результат попадёт в следующий обработчик
        - если я просто вызову другой промис (без return) - промис выполнится. Но в следующий обработчик придёт именно то,
          что объявлено в return (или `undefined`, если return нет). Т.е. промис выполнится и НЕ передаст свои результаты
          дальше по цепочке обработчиков.
        - ```js
          getUserByName('Ivan')
          .then(function (user) {
            // Функция getUserAccountById возвращает promise, результат которого попадет в следующий then
            return getUserAccountById(user.id);
          })
          .then(function (userAccount) {
            // Я знаю все о пользователе!
          });
          ```
      - Вернуть (return) обычное синхронное значение (или undefined)
        - ```js
          getUserByName('Ivan')
          .then(function (user) {
            if (inMemoryCache[user.id]) {
              // Данные этого пользователя уже есть в обычном синхронном коде, возвращаем сразу
              return inMemoryCache[user.id];
            }
            // Про этого пока не знаем, вернем промис запроса
            return getUserAccountById(user.id);
          })
          .then(function (userAccount) {
            // Я знаю все о пользователе!
          });
          ```
      - Выдать (throw) синхронную ошибку
        - ```js
          getUserByName('Ivan')
          .then(function (user) {
            if (user.isLoggedOut()) {
              // Пользователь вышел — выдаем ошибку!
              throw new Error('user logged out!');
            }
            if (inMemoryCache[user.id]) {
              // Данные этого пользователя уже есть в обычном синхронном коде, возвращаем сразу
              return inMemoryCache[user.id];
            }
            // Про этого пока не знаем, вернем промис запроса
            return getUserAccountById(user.id);
          })
          .then(function (userAccount) {
            // Я знаю все о пользователе!
          })
          .catch(function (err) {
            // Упс, ошибка, но мы к ней готовы!
          });
          ```
          - catch() получит синхронную ошибку, если пользователь не авторизован, или асинхронную, если любой из промисов
            выше перейдет в состояние rejected. Функции в catch без разницы, была ошибка синхронной или асинхронной.
  - `.catch` = чтобы поставить обработчик только на ошибку.
    - это синтаксический сахар для `.then(null, onFulfilled)`, просто более короткий способ записать его.
    - `.catch(onRejected)` – сработает только при неудачном завершении промиса
    - `.catch(onRejected)` = сокращённая запись `.then(null, onRejected).`
    - Если промис завершается с ошибкой, то управление переходит в ближайший `.catch` ниже по коду. `.catch` не
      обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких .then.
    - Если ошибка не перехвачена ни одним `.catch` (например добавить `.catch` в конец цепочки) — скрипт умирает с
      сообщением в консоли
    - Самый лёгкий путь перехватить все ошибки – это добавить `.catch` в конец цепочки. Тогда, если все в порядке, этот
      .catch вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная
      json-строка, или что угодно другое), то ошибка будет перехвачена. Финальный .catch перехватывает как промисы, в
      которых вызван reject, так и случайные ошибки в обработчиках.
    - Если мы бросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление
      перейдёт к ближайшему `.catch`. Это происходит для всех ошибок, не только для тех, которые вызваны
      оператором `throw`. Например, вызов несуществующей функции (программная ошибка).
    - В `.catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. Если мы
      пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок.
      А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный
      обработчик `.then`.
  - `.finally` = выполнится в любом случае: и при успехе, и при ошибке
    - обработчик для выполнения очистки/доведения после завершения предыдущих операций. Например остановить индикатор
      загрузки.
    - В finally мы не знаем, как был завершён промис - успешно ли нет
    - finally «пропускает» результат или ошибку дальше, к последующим обработчикам. Поэтому обычно ставится в коле выше
      чем `then` и `catch`
    - Обработчик finally также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.<br>
      - Единственное исключение — если обработчик finally выдает ошибку. Эта ошибка передается следующему обработчику
        вместо любого предыдущего результата.
  - Вызов обработчика тоже возвращает промис => мы можем вызвать на нём следующий обработчик.
    - когда обработчик (then, catch, finally) возвращает значение — оно становится результатом выполнения соответствующего
      промиса и передаётся в следующий обработчик.
      - ```js
        promise
        .then(result => {return result * 2})
        .then(result => {alert(result)});
        ```
    - если обработчик `handler`, переданный в `.then(handler)` возвращает промис (`return new Promise()`) — следующие
      обработчики цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка)
      передаётся дальше.
      - ```js
        promise
        .then(result => {
          return new Promise((resolve, reject) => { // then возвращает новый промис
            setTimeout(() => resolve(result * 2), 1000);
          });
        })
        .then(result => {alert(result)}); 
        ```

  <br></p>
  </details>

[//]: # (Синтаксис "Promise.resolve")
- <details><summary><b>Синтаксис `Promise.resolve().then()`</b></summary><p>

  - Бывает что асинхронного кода нет, но нужен промис, чтобы построить цепочку.

  - ```js
    //Пример цепочки после успешного завершения
    const promise = new Promise((resolve) => resolve());
    // promise.then ...
    
    //Пример цепочки после неудчаного завершения
    const promise = new Promise((resolve, reject) => reject());
    // promise.catch ...
    ````

  - Для этих задач есть спец. синтаксис, с ним код становится чище:

  - ```js
    const promise1 = Promise.resolve();
    // promise1.then
    
    const promise2 = Promise.reject();
    // promise2.catch ...
    ````  

  <br></p>
  </details>

[//]: # (Сhaining - чейнинг)
- <details><summary><b>Сhaining (чейнинг)</b></summary><p>

  - Возможность строить асинхронные цепочки из промисов.
  - Основная причина, из-за которой существуют и активно используются промисы.
  - 
  - Например, мы хотим по очереди:
    - Загрузить данные посетителя с сервера (асинхронно).
    - Затем отправить запрос о нём на github (асинхронно).
    - Когда это будет готово, вывести его github-аватар на экран (асинхронно).
    - …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.
  - 
  - ```js
      httpGet('/article/promise/user.json') //делаем запрос
      .then(response => {
        console.log(response);
        let user = JSON.parse(response);
        return user;
      })
      // 2. Получить информацию с github
      .then(user => {
        console.log(user);
        let githubUser = httpGet(`https://api.github.com/users/${user.name}`)
        return githubUser;
      })
      // 3. Вывести картинку юзера
      .then(githubUser => {
        console.log(githubUser);
        githubUser = JSON.parse(githubUser);
        img.src = githubUser.avatar_url;
        document.body.appendChild(img);
      });
    ```
  - 
  - Вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.
  - 
  - При чейнинге `.then…then…then`, в каждый следующий `then` переходит результат от предыдущего.<br>
  - Если очередной `then` вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
  - 
  - Цепочки Promise работают напрямую через `event loop` и могут содержать достаточно тяжелые вычисления.<br>
  - Разбивая их на атомарные операции, мы оставляем пространство для выполнения обработчиков пользовательских событий.

  <br></p>
  </details>

[//]: # (Промисификация)
- <details><summary><b>Промисификация</b></summary><p>

  - Это когда берут асинхронную функцию на коллбеках и делают для неё обёртку, возвращающую промис.
  - Использование становится удобнее.
  - Часто используется для сторонних библиотек и legasy-кода, которые написан на колбеках. А хочется работать с ними через промисы.
  - 
  - Такой код
    - ```js
        function loadScript(src, callback) {
          let script = document.createElement('script');
          script.src = src;

          script.onload = () => callback(null, script);
          script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

          document.head.append(script);
        }

        // использование:
        // loadScript('path/script.js', (err, script) => {...})
      ```
  - Можно записать так:
    - ```js
        let loadScriptPromise = function (src) {
          return new Promise((resolve, reject) => {
            loadScript(src, (err, script) => {
              if (err) reject(err)
              else resolve(script);
            });
          })
        }

        // использование:
        // loadScriptPromise('path/script.js').then(...)
      ```

  - Теперь loadScriptPromise хорошо вписывается в код, основанный на промисах.
  - loadScriptPromise передаёт всю работу исходной функции loadScript, предоставляя ей колбэк, по вызову которого происходит resolve/reject промиса.
  - 
  - Чтобы автоматизировать создание таких обёрток можно использовать функцию-помощник — принимает функцию для промисификации f и возвращает функцию-обёртку.
  - Есть готовые модули с гибкой настройкой промисификации, например
  - 
    - [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify)
    - встроенная функция `util.promisify` в Node.js.
  -
  - Промисификация – это отличный подход, особенно, если вы будете использовать async/await, но она не является тотальной заменой любых колбэков. Промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.
  - Поэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка будут проигнорированы.

  <br></p>
  </details>

[//]: # (Promise API)
- <details><summary><b>Promise API</b></summary><p>

  - У класса `Promise` есть статические методы:
  -
  - `Promise.all`
    - [javascript.ru - Promise.all](https://learn.javascript.ru/promise-api#promise-all)
    - запустить множество промисов параллельно и дождаться, пока все они выполнятся
    - Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой
      ошибкой. При этом остальные результаты игнорируются.
    - принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив)
    - возвращает новый промис.
    - новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их
      результатов.
    - порядок элементов результирующего массива точно соответствует порядку исходных промисов. Даже если первый промис
      будет выполняться дольше всех, его результат всё равно будет первым в массиве.
    - Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст
      задачу-промис, и затем обернуть получившийся массив в Promise.all
  - `Promise.allSettled`
    - [javascript.ru - Promise.allSettled](https://learn.javascript.ru/promise-api#promise-allsettled)
    - Альтернатива Promise.all
    - Метод всегда ждёт завершения всех промисов. В массиве результатов будет
      - {status:"fulfilled", value:результат} для успешных завершений,
      - {status:"rejected", reason:ошибка} для ошибок.
  - `Promise.race`
    - [javascript.ru - Promise.race](https://learn.javascript.ru/promise-api#promise-race)
    - Как Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
  - `Promise.any`
    - [javascript.ru - Promise.any](https://learn.javascript.ru/promise-api#promise-any)
    - Как Promise.all, но ждёт только первый **успешно выполнившийся** выполненный промис, из которого берёт результат (
      или ошибку).
    - Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с
      помощью AggregateError – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.
  - `Promise.resolve`/`reject`
    - [javascript.ru - Promise.resolve/reject](https://learn.javascript.ru/promise-api#promise-resolve-reject)
    - Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы
      рассмотрим его чуть позже) делает их, в общем-то, не нужными.
    - Promise.resolve(value) создаёт и возвращает успешно выполненный промис с результатом value.
      - Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.
    - Promise.reject(error) создаёт и возвращает промис, завершённый с ошибкой error.

  <br></p>
  </details>

[//]: # (Асинхронные итераторы, for-await-of, forEach, for и while)
- <details><summary><b>Асинхронные итераторы, for-await-of, forEach, for и while</b></summary><p>

  - Надо относиться очень аккуратно к использованию `forEach`, `for` и `while` в промисах.
  - Скорее всего нужен `Promise.all()` или что-то в этом духе.
  - 
  - Просто использовать цикл for или метод forEach с асинхронными операциями мы не можем. И цикл for и метод forEach ожидают синхронный код.
  - Однако мы можем использовать for await...of, который появился в ES2018, для обхода асинхронных итерируемых сущностей.
  - 
  - Подробнее:
    - [Habr - У нас проблемы с промисами](https://habr.com/ru/company/vk/blog/269465/)
  - 
  - Есть ещё асинхронные итераторы (используется цикл for-await-of) - объединяют возможности итераторов и операторов async и await.
  - 
  - [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
  - [Mentanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
  - [Habr - Как работать с async/await в циклах JavaScript](https://habr.com/ru/post/435084/)

  <br></p>
  </details>

[//]: # (Что нового?)
- <details><summary><b>Что нового?</b></summary><p>

  - ES 2022
    - `await` верхнего уровня в модулях. Раньше await нельзя было использовать вне функций.
      - Гарантия того, что модули не получат доступ к асинхронному импорту, пока они не будут полностью инициализированы;
      - Прозрачная обработка асинхронности: импортёрам не нужно знать, является ли импортируемый модуль асинхронным или нет
      - Позволяет загружать модули условно if(download) { await require('/script.js') }. Или позволит просто указать ссылку до другого ресурса, если с первым произошла ошибка. Также можно использовать тот ресурс, который загрузился быстрее
  - ES 2021
    - метод `Promise.any` — принимает n промисов и возвращает первый успешно завершившийся.
    - объект `AggregateError` — новый тип ошибок. Представить n ошибок в виде одной комбинированной. Например для
      Promise.any(), если все promises завершились в rejected
  - ES 2020
    - динамический импорт — можно импортировать модули в виде промиса
  - ES 2018
    - метод `finally()` у объектов Promise — выполнять коллбэк после `resolve()` / `reject()`. Чтобы корректно завершать
      операции (например, высвобождая ресурсы).
    - цикл `for-await-of` (асинхронная итерация) — создавать циклы, работающие с асинхронным кодом. Вызывать в цикле
      асинхронные функции (возвращающие промисы) или обрабатывать массивы, содержащие промисы.
  - ES 2017
    - `Async/Await`  — асинхронные функции, работают на основе promise
  - ES 2015 (ES6)
    - введены Promises

  <br></p>
  </details>

[//]: # (Заметки)
- <details><summary><b>Заметки</b></summary><p>

  - Как правило, все асинхронные действия должны возвращать промис.
    - Позволяет планировать после него какие-то дополнительные действия по завершении асинхронной части.
    - Даже если эта возможность не нужна прямо сейчас, она может понадобиться в будущем.
  - Можно работать с промиса в обычных функциях, можно в
    стрелочных `.then(script => loadScript("/article/promise-chaining/two.js"))`.
  - Функция-executor в промисе должна вызвать либо `resolve(value)`, либо `reject(error)`. Если кроме этого она возвращает
    значение (т.е. делает какой-то return) - оно буде проигнорировано.
  - Функции-колбэки `resolve(value)` и `reject(error)` принимают только один аргумент: value или error. Или ни одного.
    Все дополнительные аргументы будут проигнорированы.
  - В `reject(error)` можно передать любой аргумент. Но рекомендуется использовать объект `Error` (или унаследованный от
    него).
  - внутри `then` всегда использовать `return` или выдавать ошибку при помощи `throw`.
  - в конец цепочки промисов `.then(...).then(...)` всегда добавлять метод `catch()`: .catch(console.log.bind(console))
  - всегда добавлять обработку ошибок ниже в виде `catch()`,
    - Никогда не использовать для этой цели вторую функцию в методе `then()`
    - Исключение только одно — асинхронные тесты в Mocha, в случаях, когда я намеренно жду ошибку
  - 
  - Про порядок выполнения промисов
    - Пример:
      - ```js
        p.then( function(){
            p.then( function(){
                console.log( "C" );
            } );
            console.log( "A" );
        } );
        p.then( function(){
            console.log( "B" );
        } );
        // A B C
        ```
      - Здесь "C" не может прервать и опередить "B" вследствие самого определения механизма работы обещаний.
    - 
    - Шлюз (gate)
        - В терминологии классического программирования шлюзом (`gate`) называется механизм, который ожидает завершения двух и более параллельных задач. Неважно, в каком порядке они будут завершаться, важно только то, что все они должны быть завершены, чтобы шлюз открылся и пропустил поток команд.
        - В Promise API этот паттерн называется `all([ .. ])`.

  <br></p>
  </details>

[//]: # (Примеры кода)
- <details><summary><b>Примеры кода</b></summary><p>

  - ```js
    //Создаём объект-промис
    let promise = new Promise(function (resolve, reject) {
      // Эта функция будет вызвана автоматически, в ней можно делать любые асинхронные операции,
      // Когда они завершатся — нужно вызвать resolve(результат) при успехе или reject(ошибка) при ошибке
      setTimeout(() => resolve(result), 1000); // переведёт промис в состояние fulfilled с результатом "result", через 1 сек
    })
    
    //Навешиваем обработчик с двумя вариантами реакции - на успех и ошибку
    promise
          .then(
                  // функция-обработчик №1 - запустится при вызове resolve
                  result => console.log("Fulfilled: " + result), // result - аргумент resolve

                  // функция-обработчик №2 - запустится при вызове reject
                  // сработала бы, если б в SetTimeout вместо resolve("result") был вызов reject("error")
                  error => console.log("Rejected: " + error), // error - аргумент reject
          );
    ```

  - ```js
    //Промис в функции
    const loadImg = url => {
      return new Promise((resolve, reject) => {
        const getSomething = new XMLHttpRequest();
        getSomething.open("GET", url);

        getSomething.onload = () => resolve(xhr.responseText); //передаем в resolve ответ
        getSomething.onerror = () => reject(xhr.statusText); //переадем в reject текст ошибки

        getSomething.send();
      });
    }

    loadImg(url)
          .then(
                  function (result) {
                    //some work
                  },
                  function (err) {
                    console.log(err);
                  }
          );
    ```

  - ```js
    //Вызов промиса без объявления переменной
    new Promise((resolve, reject) => {
      setTimeout(() => resolve(1), 1000);
    }).then(function (result) {
      //some work
    });
    ```

  - ```js
    //когда асинхронного кода нет, но нужен промис, чтобы построить цепочку
    //Сразу переводим промис в состояние resolve (c данными value) и передаём данные в then.
   
    //Для этого есть спец. синтаксис 
    Promise.resolve(value)
    .then(result => console.log(value));
    
    //То же самое что
    new Promise(resolve => resolve(value))
    .then(result => console.log(value));
    
    //То же самое что
    new Promise(function (resolve) {
      resolve(value);
    })
    .then(result => console.log(value));
    ```

  - ```js
    //Возвращение промиса из .then - построение цепочки асинхронных действий
    new Promise((resolve, reject) => {
      setTimeout(() => resolve(1), 1000);
    }).then(function (result) {
      alert(result); // 1
    
      return new Promise((resolve, reject) => { // then возвращает новый промис
        setTimeout(() => resolve(result * 2), 1000);
      });
    }).then(function(result) { // (**)
      alert(result); // 2
    });
    ```
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Промисы](https://learn.javascript.ru/promise-basics)
  - [MDN - Промисы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)
  - [MDN - Использование промисов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Using_promises)
  - [Habr - У нас проблемы с промисами](https://habr.com/ru/company/mailru/blog/269465/)
  - [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  - [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://m.habr.com/ru/company/ruvds/blog/340508/)
  - [Hexlet - new Promise (JS: Асинхронное программирование)](https://ru.hexlet.io/courses/js-asynchronous-programming/lessons/new-promise/theory_unit)
  - [Habr - Промисы в ES6: паттерны и анти-паттерны](https://m.habr.com/ru/company/ruvds/blog/339414/)
  - [Habr - Познаем промисы на основе Ecmascript спецификации. Знакомство](https://habr.com/ru/post/478938/)
  - [Medium - Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-javascript-%D1%81-async-await-ba5f47f4436)
  - [Ад обратных вызовов](http://callbackhell.ru/)
  - [WebDev - ES6 #13 Промисы (YouTube)](https://youtu.be/XD1MKx7eIuQ)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Промисы — Async/Await)
<details id="promiseAsync"><summary><b>Промисы — Async/Await</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Специальный синтаксис для работы с промисами.
  - Замена `.then` — позволяет оформлять асинхронный код более привычным способом, как синхронный. Синтаксический сахар
  - 
  - Ключевое слово `async` сообщает JS-интерпретатору что эту функцию, нужно обрабатывать по-особому:
    - такая функция всегда возвращает промис. Если вернёт что-то другое — это значение автоматически обернется в успешно завершившийся промис.
    - когда система достигнет в этой функции ключевого слова `await` — она приостановится.
      - Она считает, что выражение после `await` возвращает промис — ожидает разрешения или отклонения этого промиса перед продолжением.
  - Ключевое слово `await` перед промисом заставит JS дождаться его выполнения, после чего:
    - Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось `throw`.
    - Иначе вернётся результат промиса — то, что возвращает асинхронная функция справа от слова await.
    - Ключевое слово await говорит движку JS приостановить код в этой строке, не блокируя остальной код скрипта за пределами асинхронной функции.

  <br></p>
  </details>

[//]: # (Преимущества)
- <details><summary><b>Преимущества</b></summary><p>

  - код выглядит лучше - можно работать с асинхронными функциями как с синхронными
  - удобнее обрабатывать ошибки
  - удобнее отлаживать

  <br></p>
  </details>

[//]: # (Про ошибки)
- <details><summary><b>Про ошибки</b></summary><p>

  - При использовании промисов нам приходится использовать блок `.catch()` для обработки асинхронных ошибок, и блок `try / catch` для обработки синхронных ошибок.
  - Конструкция async / await позволяет обрабатывать синхронные и асинхронные ошибки с использованием одних и тех же механизмов — выражением `try / catch`.
  - Также cтек ошибки, возвращённый из цепочки промисов, не содержит сведений о точном месте, в котором произошла ошибка. В В отличие от `async / await` этой проблемы нет

  <br></p>
  </details>

[//]: # (Про отладку)
- <details><summary><b>Про отладку</b></summary><p>

  - Если вы пользовались промисами, то вы знаете, что отладка подобных конструкций — это кошмар.
  - Например, если установить nочку останова внутри блока `.then` и использовать команды отладки вроде «step-over», отладчик не перейдёт к следующему `.then`, так как он умеет «перешагивать» лишь через синхронный код.
  - С использованием `async / await` можно переходить по вызовам, в которых используется ключевое слово `await` так, будто это — обычные синхронные операции.
  
  <br></p>
  </details>

[//]: # (Про event loop)
- <details><summary><b>Про event loop</b></summary><p>

  - Сама по себе async-функция обработается по обычным правилам.
  - А вот ключевое слово `await` в ней — поставит код «на паузу».
    - Интерпретатор JS будет ждать, пока промис справа от `await` не выполнится.
  - После чего оно вернёт его результат, и выполнение кода продолжится.
  - Вроде это должно работать как обычный `.then`
    - Это просто «синтаксический сахар» для получения результата промиса, аналог `promise.then`.
    - Хотя await и заставляет JS дожидаться выполнения промиса, это не отнимает ресурсов процессора.
    - Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать
      события и т.п.
  -
  - Ключевое слово `await` говорит движку JS приостановить код в этой строке, не блокируя остальной код скрипта за пределами асинхронной функции.
  - Слово `await` сообщает что
    - мы должны дождаться выполнения асинхронной функции
    - не помещать ее в event loop, а выполнить прямо здесь.
  - 
  - ```js
    // Мы дожидаемся выполнения асинхронной функции getData(), 
    // выполняем прямо здесь (не помещая в event looop) и пишем результат в i-й элемент массива.

    async function fillArray() {
      const arr = [];
      for (var i = 0; i < 10000; i++) {
        arr[i] = await getData(i);
      }
    }
    ```
  -
  - Это значит, что при вызове асинхронной функции fillArray() она попадет в очередь контекстов и будет исполнена.
  - Но следующий контекст будет ждать, пока текущий завершится.
  - Все пользовательские события, таймеры и прочие помещаемые в очередь контексты будут ждать, пока не пройдут десять тысяч запросов к серверу.

  <br></p>
  </details>

[//]: # (Asynс-функция всегда возвращает промис)
- <details><summary><b>Asynс-функция всегда возвращает промис</b></summary><p>

  - ```js
    //Можно не писать return Promise(...) — всё равно вренётся промис
    async function f() { return 1 }
    f().then(alert); // 1
    ```

  - ```js    
    //Можно явно вернуть промис — результат будет тот же
    async function f() {return Promise.resolve(1)}
    f().then(alert); // 1
    ```

  <br></p>
  </details>

[//]: # (Async и Promise.all)
- <details><summary><b>Async и Promise.all</b></summary><p>

  - Await отлично работает в сочетании с `Promise.all`, если необходимо выполнить несколько задач параллельно.
  - `Promise.all` — запустить N промисов параллельно и дождаться, пока все они выполнятся.
  - Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой. При этом остальные результаты игнорируются.

  <br></p>
  </details>

[//]: # (Асинхронные итераторы, for-await-of. ForEach, for и while)
- <details><summary><b>Асинхронные итераторы, for-await-of. ForEach, for и while</b></summary><p>

  - Надо относиться очень аккуратно к использованию `forEach`, `for` и `while` в промисах.
  - Скорее всего нужен `Promise.all()` или что-то в этом духе.
  - 
  - Просто использовать цикл for или метод forEach с асинхронными операциями мы не можем. И цикл for и метод forEach ожидают синхронный код.
  - Однако мы можем использовать for await...of, который появился в ES2018, для обхода асинхронных итерируемых сущностей.
  - 
  - Подробнее:
    - [Habr - У нас проблемы с промисами](https://habr.com/ru/company/vk/blog/269465/)
  - 
  - Есть ещё асинхронные итераторы (используется цикл for-await-of) - объединяют возможности итераторов и операторов async и await.
    - [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
    - [Mentanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
    - [Habr - Как работать с async/await в циклах JavaScript](https://habr.com/ru/post/435084/)

  <br></p>
  </details>

[//]: # (Примеры кода)
- <details><summary><b>Примеры использования</b></summary><p>

  - ```js
    //Использование со стрелочной функцией
    const foo = async() => {console.log(await getData())};
    foo();
    ````

  - ```js
    //Отлавливание ошибок
    const foo = async() => {
      try {
          console.log(await getData())
      } catch(err) {
          console.error(err)    
      }
    };
    foo();
    ````

  - ```js
    //Пример с then
    new Promise((resolve, reject) => {
      setTimeout(() => resolve('some result'), 1000);
        // setTimeout(() => reject(new Error('some error')), 1000);
    }).then(result => {
      console.log(result)  
    }).catch(err => {
       console.error(err)    
    });

    //Он же с async/await, с обработкой ошибок в try...catch
    const foo = async() => {
      try {
        const result = await new Promise((resolve, reject) => {
          setTimeout(() => resolve('some result'), 1000);
          // setTimeout(() => reject(new Error('some error')), 1000);
        });  
        console.log(result);
      } catch(err) {
        console.error(err);
      }
    };
    foo();

    //Он же с async/await, без обработки ошибок
    const foo = async() => {
      const result = await new Promise(resolve => {
        setTimeout(() => resolve('some result'), 1000);
      });
      console.log(result);
    };
    foo();

    //Он же с async/await, с обычной обработкой ошибок 
    const foo = async() => {
      const result = await new Promise((resolve, reject) => {
        setTimeout(() => resolve('some result'), 1000);
        // setTimeout(() => reject(new Error('some error')), 1000);
      });
      console.log(result);
    };
    foo().catch(err => {
        //Эта часть сработает только если промис вёрнет ошибку, иначе игнорируется  
        console.error(err);
      });
    ````

  - ```js
    //A. Вариант с .then
    // 1. Запрашиваем с сервера JSON с данными пользователя
    fetch('/src/user.json')
          // 2. Загружаем данные в формате json
          .then(response => response.json())
          
          // 3. Запрашиваем информацию об этом пользователе с GitHub
          .then(user => fetch(`https://api.github.com/users/${user.name}`))

          // 4. Загружаем ответ в формате json
          .then(response => response.json())

          // 5. Показываем аватар (githubUser.avatar_url) в течение 3 секунд
          .then(githubUser => new Promise(function (resolve, reject) {
            let img = document.createElement('img');
            img.src = githubUser.avatar_url;
            img.className = "promise-avatar-example";
            document.body.append(img);

            // ждём 3 секунды и затем скрываем аватар
            setTimeout(() => {
              img.remove();
              resolve(githubUser); // (**)
            }, 3000);
          }))

          // 6. Выполянем какое-то дейстиве после отображения-скрытия аватара
          .then(githubUser => alert(`Закончили показ ${githubUser.name}`));

    //B. Тот же вариант с .async
    async function showAvatar() {

      // 1. Запрашиваем с сервера JSON с данными пользователя
      let response = await fetch('/src/user.json');
    
      // 2. Загружаем данные в формате json
      let user = await response.json();
    
      // 3. Запрашиваем информацию об этом пользователе с GitHub
      let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
    
      // 4. Загружаем ответ в формате json
      let githubUser = await githubResponse.json();
    
      // 5. Показываем аватар (githubUser.avatar_url)
      let img = document.createElement('img');
      img.src = githubUser.avatar_url;
      img.className = "promise-avatar-example";
      document.body.append(img);
    
      // ждём 3 секунды и затем скрываем аватар
      await new Promise((resolve, reject) => setTimeout(resolve, 3000));
      img.remove();

      // 6. Выполянем какое-то дейстиве после отображения-скрытия аватара
      return githubUser;
    }
    showAvatar();
    ````
  - 
  - 
  - Функция `getAmount()` вызывает две асинхронные функции — `getUser()` и `getBankBalance()`.
    - Можно сделать это через `.then`, но конструкция `async/await` позволяет решить эту задачу проще и элегантнее.
  - ```js
    function getUser(userId) {
      return new Promise(resolve => resolve('Ivan'))
    }
    
    function getBankBalance(user) {
      return new Promise((resolve, rejected) => {
        if (user == 'Ivan') {
          resolve('$1,00')
        } else {
          rejected('unknown user')
        }
      })
    }
    
    // Раньше, с .then
    function getAmount(userId) {
      getUser(userId)
              .then(user => getBankBalance(user))
              .then(money => console.log(money))
    }
    
    // Теперь, с Async/Await
    async function getAmount2(userId) {
      let user = await getUser(userId);
      let money = await getBankBalance(user);
      console.log(money);
    }
    ```
  - Подробнее этот пример рассмотрен здесь: [Habr - Обзор новшеств ECMAScript 2016, 2017, и 2018 с примерами](https://habr.com/ru/company/ruvds/blog/353174/)

  <br></p>
  </details>

[//]: # (Что нового?)
- <details><summary><b>Что нового?</b></summary><p>

  - ES8 (2016) — введены Async/Await
  - ES13 (2022) — оператор `await` можно использовать вне функции (без `async`). Полезно для загрузки модулей динамически или условно.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Async/await](https://learn.javascript.ru/async-await)
  - [MDN - Async/await](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Promises)
  - [Habr - Конструкция async/await в JavaScript](https://habr.com/ru/company/ruvds/blog/414373/)
  - [Habr - Async/Await в javascript. Взгляд со стороны](https://habr.com/ru/post/282477/)
  - [Habr - Асинхронность в JavaScript: Пособие для тех, кто хочет разобраться](https://habr.com/ru/company/wrike/blog/302896/)
  - [Habr - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await](https://m.habr.com/ru/company/ruvds/blog/340508/)
  - [Habr - Поймут даже дети: простое объяснение async/await и промисов в JavaScript](https://habr.com/ru/post/474726/?ysclid=l8aawlijry104453440)
  - [Habr - Разница между асинхронной функцией и функцией, возвращающей промис](https://habr.com/ru/post/475260/)
  - [Дока - Асинхронность в JS ](https://doka.guide/js/async-in-js/?ysclid=l8abi9sfsv463636739)
    [Полное понимание синхронного и асинхронного JavaScript с Async/Await](https://stasonmars.ru/javascript/polnoe-ponimanie-syncronnogo-i-asyncronnogo-javascript-s-async-await/)
  - [Ад обратных вызовов](http://callbackhell.ru/)
  - [WebDev - ES6 #14 Async/Await (YouTube)](https://youtu.be/b17RVAqp5QA)

  - [learn.javascript.ru - Асинхронные итераторы и генераторы](https://learn.javascript.ru/async-iterators-generators)
  - [Mentanit - Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
  - [Habr - Как работать с async/await в циклах JavaScript](https://habr.com/ru/post/435084/)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Web-workers)
<details id="webWorkers"><summary><b>Web-workers</b></summary><p> 

  - Спецификация `Web Workers` — позволяет запускать дополнительные JS-процессы (workers).
  - Способ исполнить код в другом, параллельном потоке.
  - Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.
  - Позволяют задействовать несколько ядер процессора одновременно.
  -
  - Web Workers могут обмениваться сообщениями с основным процессом, но они имеют свои переменные и свой событийный цикл.
  - WW не имеют доступа к DOM, поэтому основное их применение – вычисления.
  - Для долгих или интенсивно потребляющих ресурсы задач — перемещаем их в другой поток, чтобы снять нагрузку с основного UI-потока.
  -
  - Как применять в коде? 
    - проверяем наличие конструктора Worker() в браузере,
    - если он доступен — создаем экземпляр рабочего объекта с URL-адресом сценария в качестве аргумента. 
    - Этот скрипт будет выполняться в отдельном потоке.
  -
  - WW и «парарлеллизм задач»
    - В настоящее время в JS нет никаких поддержки многопоточного выполнения.
    - Однако среда (браузер) может n несколько экземпляров движка JS, каждый из которых выполняется в отдельном потоке. 
    - Это даёт возможность запустить разные части программы в разных потоках. Каждая из этих отдельных потоковых частей программы называется `web-worker`.
    - Позволяет запустить файл JS (т.е. программу) в отдельном потоке, используя асинхронные события для передачи информации между потоками.
    - Эта разновидность параллелизма называется `параллелизмом на уровне задач` — акцентируетс на разбиении программы на части для параллельного выполнения.
  -
  - Для каких целей чаще всего используются WW?
      - Интенсивные математические вычисления.
      - Сортировка больших наборов данных.
      - Операции с данными (сжатие, анализ аудиоданных, обработка изображений на уровне пикселов и т. д.).
      - Передача данных по сети с высоким уровнем трафика.
  - 
  - **Ссылки**
      - [JavaScript Web Workers: руководство для начинающих](https://webdevblog.ru/javascript-web-workers-rukovodstvo-dlya-nachinajushhih/?ysclid=l7id6v4kl6484714219)
      - [MDN - Использование Web Workers](https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Using_web_workers)

<br></p>
</details>

[//]: # (Fetch)
<details id="fetch"><summary><b>Fetch</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>
  
  - Метод реализации асинхронных запросов в нативном JS. 
  - Предоставляется Fetch API
  - Возвращает промис
  - 
  - Пример: `js let promise = fetch(url, [options]) `
  -
  - Без `options` это простой GET-запрос, скачивающий содержимое по адресу url.
  -
  - Результат выполнения промиса — объект встроенного класса Response (как только сервер пришлёт заголовки ответа).
    - На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.
    - Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос

  <br></p>
  </details>

[//]: # (Параметры ответа)
- <details><summary><b>Параметры ответа</b></summary><p>

  - `response.status` – HTTP-код ответа,
  - `response.ok` – true, если статус ответа в диапазоне 200-299.
  - `response.headers` – похожий на Map объект с HTTP-заголовками.
 
  <br></p>
  </details>

[//]: # (Методы для получения тела ответа)
- <details><summary><b>Методы для получения тела ответа</b></summary><p>

  - Для получения тела ответа нам нужно использовать дополнительный вызов метода.
  - Можно выбрать только один метод чтения ответа!
  -
  - `response.text()` – читает ответ и возвращает как обычный текст,
  - `response.json()` – декодирует ответ в формате JSON,
  - `response.formData()` – возвращает ответ как объект FormData (разберём его в следующей главе),
  - `response.blob()` – возвращает объект как Blob (бинарные данные с типом),
  - `response.arrayBuffer()` – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
  - помимо этого, `response.body` – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.
  - 

  <br></p>
  </details>

[//]: # (Опции fetch)
- <details><summary><b>Опции fetch</b></summary><p>

  - `method` – можно задать HTTP-метод (например POST, PUT, DELETE...)
  - `headers` – объект с запрашиваемыми заголовками (не все заголовки разрешены),
  - `body` – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.
  - `headers` — значение этого заголовка обычно ставится автоматически, в зависимости от тела запроса ("Content-Type": "text/plain;charset=UTF-8"...)
  - `referrer`, `referrerPolicy` —  как fetch устанавливает HTTP-заголовок Referer
    - Обычно этот заголовок ставится автоматически и содержит URL-адрес страницы, с которой пришёл запрос. 
    - В большинстве случаев он совсем неважен, в некоторых случаях, с целью большей безопасности, имеет смысл убрать или укоротить его.
  - `mode` — защита от нечаянной отправки запроса на другой источник (cors, same-origin, no-cors)
    - опция может пригодиться, если URL-адрес для fetch приходит от третьей стороны, и нам нужен своего рода «глобальный выключатель» для запросов на другие источники.
    -
    - `cors` – стоит по умолчанию, позволяет делать такие запросы так, как описано в Fetch: запросы на другие сайты,
    - `same-origin` – запросы на другой источник запрещены,
    - `no-cors` – разрешены только простые запросы на другой источник.
  - `credentials` — должен ли fetch отправлять куки и авторизационные заголовки HTTP вместе с запросом.
    - `same-origin` — стоит по умолчанию, не отправлять для запросов на другой источник,
    - `include` — отправлять всегда, но при этом необходим заголовок Access-Control-Allow-Credentials в ответе от сервера, чтобы JavaScript получил доступ к ответу сервера, об этом говорилось в главе Fetch: запросы на другие сайты,
    - `omit` — не отправлять ни при каких обстоятельствах, даже для запросов, сделанных в пределах текущего источника.
  - `cache` — позволяет игнорировать HTTP-кеш или же настроить его использование
    - `default` — fetch будет использовать стандартные правила и заголовки HTTP кеширования,
    - `no-store` — полностью игнорировать HTTP-кеш, этот режим становится режимом по умолчанию, если присутствуют такие заголовки как If-Modified-Since, If-None-Match, If-Unmodified-Since, If-Match, или If-Range,
    - `reload` — не брать результат из HTTP-кеша (даже при его присутствии), но сохранить ответ в кеше (если это дозволено заголовками ответа);
    - `no-cache` — в случае, если существует кешированный ответ – создать условный запрос, в противном же случае – обычный запрос. Сохранить ответ в HTTP-кеше,
    - `force-cache` — использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кеше отсутствует, сделать обычный HTTP-запрос, действовать как обычно,
    - `only-if-cached` — использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кеше отсутствует, то выдаётся ошибка. Это работает, только когда mode установлен в "same-origin".
  - `redirect` — обычно fetch прозрачно следует HTTP-редиректам (301, 302 и т.д.) Это можно поменять при помощи опции redirect
    - `follow` — стоит по умолчанию, следовать HTTP-редиректам,
    - `error` — ошибка в случае HTTP-редиректа,
    - `manual` — не следовать HTTP-редиректу, но установить адрес редиректа в response.url, а response.redirected будет иметь значение true, чтобы мы могли сделать перенаправление на новый адрес вручную.
  - `integrity` — позволяет проверить, соответствует ли ответ известной заранее контрольной сумме.
  - `keepalive` —  указывает на то, что запрос может «пережить» страницу, которая его отправила.
    - Например, мы собираем статистические данные о том, как посетитель ведёт себя на нашей странице (на что он кликает, части страницы, которые он просматривает), для анализа и улучшения интерфейса.
    - Когда посетитель покидает нашу страницу – мы хотим сохранить собранные данные на нашем сервере.
    - Для этого мы можем использовать событие `window.onunload`
    - Обычно, когда документ выгружается, все связанные с ним сетевые запросы прерываются. 
    - Настройка `keepalive` указывает браузеру выполнять запрос в фоновом режиме даже после того, как пользователь покидает страницу. Поэтому эта опция обязательна, чтобы такой запрос удался.
  - `signal` — прерывание запроса (AbortController, чтобы прервать запрос)
  - `window` — можно передать глобальный объект window. В современных приложениях используется крайне редко

  <br></p>
  </details>

[//]: # (Примеры)
- <details><summary><b>Примеры</b></summary><p>

  - Пример 1
    - ```js
      let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
      
      fetch(url)
        .then(response => response.json())
        .then(commits => alert(commits[0].author.login));
      ```
  -
  - Пример 2 — с await
    - Типичный запрос с помощью fetch состоит из двух операторов «await»
    - ```js
      let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
      
      let response = await fetch(url);
      let commits = await response.json(); // читаем ответ в формате JSON

      //Мы можем выбрать только один метод чтения ответа.
      //let text = await response.text(); // прочитать тело ответа как текст

      alert(commits[0].author.login);
      ```

  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Fetch](https://learn.javascript.ru/network)
  
  <br></p>
  </details>
  
<br></p>
</details>

[//]: # (XMLHttpRequest todo: дополнить)
<details id="xmlHttpRequest"><summary><b>XMLHttpRequest *</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы..
  - Его современный аналог — fetch.

  <br></p>
  </details>

[//]: # (Зачем?)
- <details><summary><b>Зачем?</b></summary><p>

  - В современной веб-разработке XMLHttpRequest используется по трём причинам:
    - По историческим причинам: существует много кода, использующего XMLHttpRequest, который нужно поддерживать.
    - Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить количество кода).
    - Потребность в функциональности, которую fetch пока что не может предоставить, к примеру, отслеживание прогресса отправки на сервер.

  <br></p>
  </details>

[//]: # (Два режима работы XMLHttpRequest)
- <details><summary><b>Два режима работы XMLHttpRequest</b></summary><p>

  - Асинхронный
    - чаще всего используется он
    - Пример
      - ```js
          let xhr = new XMLHttpRequest(); // Создаём XMLHttpRequest, у конструктора нет аргументов
          xhr.open(method, URL, [async, user, password]) //инициализация
          xhr.send([body]) //отправка запроса

          //Слушаем события на xhr, чтобы получить ответ
          //Обычно слушают «onload», «onerror», «onprogress»
          xhr.onload = function() {
            alert(`Загружено: ${xhr.status} ${xhr.response}`);
          };

          xhr.onerror = function() { // происходит, только когда запрос совсем не получилось выполнить
            alert(`Ошибка соединения`);
          };

          xhr.onprogress = function(event) { // запускается периодически
            // event.loaded - количество загруженных байт
            // event.lengthComputable = равно true, если сервер присылает заголовок Content-Length
            // event.total - количество байт всего (только если lengthComputable равно true)
            alert(`Загружено ${event.loaded} из ${event.total}`);
          };

        ``` 
  - Синхронный
    - Если в методе open третий параметр async установлен на false, запрос выполняется синхронно.

  <br></p>
  </details>

[//]: # (Результат запроса)
- <details><summary><b>Результат запроса</b></summary><p>

  - После ответа сервера мы можем получить результат запроса в свойствах xhr
  - 
  - `status — код состояния HTTP (число): 200, 404, 403 и так далее, может быть 0 в случае, если ошибка не связана с HTTP.
  - `statusText` — сообщение о состоянии ответа HTTP (строка): обычно OK для 200, Not Found для 404, Forbidden для 403, и так далее.
  - `response` (в старом коде `responseText`) — тело ответа сервера
  - 
  - **timeout**
    - Можно также указать таймаут – промежуток времени, который мы готовы ждать ответ:
    - `xhr.timeout = 10000; // указывается в миллисекундах, т.е. 10 секунд`
    - Если запрос не успевает выполниться в установленное время, то он прерывается, и происходит событие timeout.

  <br></p>
  </details>

[//]: # (Тип ответа)
- <details><summary><b>Тип ответа</b></summary><p>

  - Свойство `xhr.responseType` позволяет указать ожидаемый тип ответа:
  -
  - ""  – строка (по умолчанию),
  - "text" – строка,
  - "arraybuffer" – ArrayBuffer (для бинарных данных, смотрите в ArrayBuffer, бинарные массивы),
  - "blob" – Blob (для бинарных данных, смотрите в Blob),
  - "document" – XML-документ (может использовать XPath и другие XML-методы),
  - "json" – JSON (парсится автоматически).

  <br></p>
  </details>

[//]: # (Состояния запроса)
- <details><summary><b>Состояния запроса</b></summary><p>

  - У XMLHttpRequest есть состояния, которые меняются по мере выполнения запроса. 
  - Текущее состояние можно посмотреть в свойстве `xhr.readyState`.
  - Изменения в состоянии объекта запроса генерируют событие `readystatechange`
  - 
  - Состояния
    - `UNSENT` = 0; // исходное состояние
    - `OPENED` = 1; // вызван метод open
    - `HEADERS_RECEIVED` = 2; // получены заголовки ответа
    - `LOADING` = 3; // ответ в процессе передачи (данные частично получены)
    - `DONE` = 4; // запрос завершён

  <br></p>
  </details>

[//]: # (Отмена запроса)
- <details><summary><b>Отмена запроса</b></summary><p>

  - Если мы передумали делать запрос, можно отменить его вызовом `xhr.abort()`
  - При этом генерируется событие `abort`, а `xhr.status` устанавливается в 0.

  <br></p>
  </details>

[//]: # (HTTP-заголовки)
- <details><summary><b>HTTP-заголовки</b></summary><p>

  - Есть 3 метода для указания своих заголовков в запросе и чтения присланных в ответ.
    - setRequestHeader(name, value) — устанавливает заголовок запроса с именем name и значением value.
    - getResponseHeader(name) — возвращает значение заголовка ответа name (кроме Set-Cookie и Set-Cookie2).
    - getAllResponseHeaders() — возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.

  <br></p>
  </details>

[//]: # (POST, FormData)
- <details><summary><b>POST, FormData</b></summary><p>

  - Чтобы сделать POST-запрос, мы можем использовать встроенный объект FormData.

  <br></p>
  </details>

[//]: # (Прогресс отправки)
- <details><summary><b>Прогресс отправки</b></summary><p>

  - Событие progress срабатывает только на стадии загрузки ответа с сервера.
  - Существует другой объект, без методов, только для отслеживания событий отправки: xhr.upload.
  - Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:
    - `loadstart` – начало загрузки данных.
    - `progress` – генерируется периодически во время отправки на сервер.
    - `abort` – загрузка прервана.
    - `error` – ошибка, не связанная с HTTP.
    - `load` – загрузка успешно завершена.
    - `timeout` – вышло время, отведённое на загрузку (при установленном свойстве timeout).
    - `loadend` – загрузка завершена, вне зависимости от того, как – успешно или нет.

  <br></p>
  </details>

[//]: # (Запросы на другой источник)
- <details><summary><b>Запросы на другой источник</b></summary><p>

  - XMLHttpRequest может осуществлять запросы на другие сайты, используя ту же политику CORS, что и fetch.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - XMLHttpRequest](https://learn.javascript.ru/xmlhttprequest)
  
  <br></p>
  </details>

<br></p>
</details>


---


[//]: # (Классы. ООП в JS todo: доработать)
<details id="classes"><summary><b>Классы. ООП в JS *</b></summary><p>

[//]: # (Определение)
- <details><summary><b>Определение</b></summary><p>

  - В ООП класс — шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов. Инструкция, чертёж по которому можно создать автомобиль (объект).
  - 
  - В JS класс — функция для создания объектов. Определяет св-ва и методы объекта.
  - 
  - `Класс` — определение типа специальной структуры данных, включающей как данные, так и поведение, работающее с этими данными. 
  - Классы определяют, как работает такая структура данных, но сами они не являются конкретными значениями. 
  - Чтобы получить конкретное значение, которое можно использовать в программе, необходимо создать экземпляр класса (при помощи ключевого слова new) один или несколько раз

  <br></p>
  </details>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Введены в ES6 (ECMAScript 2015), одновременно с модулями.
  - В экосистеме JS широко применяются два основных паттерна организации кода (данных и поведения): классы и модули. Эти паттерны не являются взаимоисключающими: во многих программах можно и нужно использовать оба.
  - В JS используется модель «прототипного наследования»: каждый объект наследует поля (свойства) и методы объекта-прототипа.
  - В JS нет таких классов как в Java или Swift, т.е. шаблонов / схем для создания объектов. В прототипном наследовании есть только объекты.
  - Классы в JS - «синтаксический сахар» над механизмом прототипного наследования. Более простой способ создания объектов и организации наследования.

  <br></p>
  </details>

[//]: # (Примеры)
- <details><summary><b>Примеры</b></summary><p>

  - Пример 1
    - ```js
    class Page {
    constructor(text) { //данные
    this.text = text;
    }
    print() {//поведение
    console.log(this.text);
    }
    }

    class Notebook {
    constructor() {
    this.pages = []; //данные
    }
    addPage(text) { // поведение
    var page = new Page(text); //создание экземпляра класса
    this.pages.push(page);
    }
    print() { // поведение
    for (let page of this.pages) {
    page.print();
    }
    }
    }

    var mathNote = new Notebook();  //создание экземпляра класса
    mathNotes.addPage("Arithmetic: + - * / ...");
    mathNotes.addPage("Trigonometry: sin cos tan ...");
    mathNotes.print();
    ```
  - Механизм class позволяет упаковать данные (text и pages) вместе с поведением (например, addPage(..) и print()). Ту же программу можно было построить без определений классов, но, скорее всего, она получилась бы намного менее организованной, хуже читалась, была бы менее понятной и более подверженной ошибкам и на ее сопровождение потребовалось бы слишком много сил.
  -
  - Пример 2
    ```js
      // создаём класс
      class Task {
        // метод «конструктор»
        constructor(isCompleted) {
          this.title = 'Learn JS',
                  this._isCompleted = isCompleted
        }
      
        //  статический метод класса - не наследуется объектами
        static getDefaultData() {
          //...
        }
      
        // метод класса. Наследуется объектами
        completed() {
          this.isCompleted = true
        }
      
        // геттер
        get isCompleted() {
          return (this._isCompleted === true) ? 'Task is completed' : 'Task is not completed';
        }
      }
      
      //добавляем статическое св-во класса - не наследуется объектами
      Task.counter = 0; //лучше объявлять его сразу после создания класса, а не ниже по коду (т.е. до создания кземпляров класса)
      
      //создаём объекты на основе класса (экземпляры класса)
      let task1 = new Task(false);
      let task2 = new Task(true);
    ```
  -

  <br></p>
  </details>

[//]: # (Аксессоры)
- <details><summary><b>Аксессоры</b></summary><p>

  - Это `геттеры` и `сеттеры` — спец. методы класса для установки и чтения его свойств.<br>
  - Чтобы случайно не изменить св-ва классе, которые не должны меняться - стараются напрямую св-ва класса не менять.
  - Используют геттеры и сеттеры.<br>
  - Снаружи ведут себя как свойства:
  -
  - ```js
      //Вызов обычного метода класса
      task.setSomethingData(10);
      
      //Вызов метода-сеттера
      task.somethingData = 10;
    ```

  <br></p>
  </details>

[//]: # (Ключевое слово «extends» и «super»)
- <details><summary><b>Ключевые слова «extends» и «super»</b></summary><p>

  - Ключевое слово `extends` используют для объявления классов или в выражениях класса для создания дочерних классов. 
  - Они получают свойства родительских классов, а также дают возможность добавить новые свойства и изменить заимствованные.
  - 
  - Подробнее: [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#extendsuperkwrds)

  <br></p>
  </details>

[//]: # (Ключевое слово «super»)
- <details><summary><b>Ключевое слово «super»</b></summary><p>
  
  - Ключевое слово `super` вызывает функции родителя объекта, включая его конструктор.<br>
  - Его следует использовать:
    - до ключевого слова `this` в конструкторе;
    - с вызовом `super(arguments)` при передаче аргументов конструктору класса;
    - как вызов дочернего класса `super.X()` для метода X родительского класса.
  -
  - `super(..)` предоставляет очень полезную функциональность относительного полиморфизма — любой метод на одном уровне цепочки может относительно обращаться к одноименному методу на более высоком уровне в цепочке. В частности, таким образом решается проблема странности конструкторов, не принадлежащих своему классу. В конструкторах super() работает именно так, как вы ожидаете.
  - Можно предположить, что связывание super происходит по аналогии со связыванием this —  что super всегда будет связываться на один уровень выше позиции текущего метода в цепочке [[Prototype]].
    - Однако по соображениям быстродействия (связывание this и так обходится достаточно дорого) super не связывается динамически.   Связывание происходит отчасти «статически» в момент объявления. Ничего страшного, правда?
    - Ммм… Возможно. А может, и нет. Если вы, как и большинство разработчиков JS, начинаете с присваивания функций разным объектам (что   происходит от определений class) разными способами, скорее всего, вы даже не очень понимаете, что во всех этих случаях механизм super  каждый раз связывается заново.
    - И в зависимости от того, какие синтаксические решения вы будете использовать при этих присваиваниях, вполне может оказаться, что в  каких-то случаях super будет связываться неправильно (по крайней мере не так, как вы ожидаете). Может оказаться (на момент написания  книги в TC39 еще шло обсуждение этой темы), что вам придется вручную связывать super вызовом toMethod(..) (по аналогии с тем, как вы  вызываете bind(..) для this — см. главу 7).

  - Подробнее: [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#extendsuperkwrds)

  <br></p>
  </details>
  
[//]: # (Наследование)
- <details><summary><b>Наследование</b></summary><p>

  - Есть класс Publication, у него есть набор общих данных и поведения, которые могут понадобиться для любой публикации.
  - Есть классы Book и BlogPost. При их объявлении используется конструкция `extends` — эти классы расширяют общее определение Publication для включения в него дополнительного поведения.
    - Пример: `class BlogPost extends Publication {...}`
  - В конструкторах классов Book и BlogPost есть вызов `super(..)` — активизирует конструктор родительского класса Publication для выполнения его части инициализации. Уже после этого выполняются операции конструктора специфические для Book и BlogPost.
  -
  - Можно не только определить класс для создания экземпляров, но и определить другой класс, наследующий от первого. Второй класс называется «дочерним классом», а первый — «родительским классом»
  - Дочерний класс содержит исходную копию поведения родителя, но он может переопределять любое унаследованное поведение и даже определять новые аспекты поведения.
  - Родителя/предка текущего класса часто называют «суперклассом» => используют ключевое слово `super`
  - При наследовании сами классы (не экземпляры объектов, созданные на их основе) могут использовать относительные обращения к классу, от которого они наследуют. Такие относительные ссылки обычно называются `super`.
  - Наследование подразумевает операцию копирования, а JS не копирует свойства объектов (по умолчанию). Вместо этого JS создает связь между двумя объектами, благодаря которой один объект может делегировать обращения к свойствам/функциям другому объекту. Термин «делегирование» гораздо точнее описывает механизм связывания объектов в JavaScript. Называть это поведение «наследованием на основе прототипов» было плохой идеей — механизмы разные
  - классы в традиционных классово-ориентированных языках фактически выполняют действие копирования из родителя в потомка, а из потомка в экземпляр, тогда как в `[[Prototype]]` действием становится не копирование, а создание ссылки делегирования.
  - class не выполняет статического копирования определений в момент объявления, как это делается в традиционных языках, ориентированных на использование классов. Если вы измените/замените метод (намеренно или случайно) родительского «класса», это отразится на дочернем «классе» и/или экземплярах: они не получат копии в момент объявления, а все еще будут использовать модель делегирования на базе `[[Prototype]]`:
  - Но самая большая проблема конструкции class в ES6 заключается в том, что разнообразные ловушки в каком-то смысле навязывают вам синтаксис, который вроде бы подразумевает (по аналогии с традиционными классами), что после объявления класса он становится статическим определением некой сущности (экземпляра, который будет создан в будущем). Из виду полностью теряется тот факт, что C является объектом, конкретной сущностью, с которой можно взаимодействовать напрямую.
  - В традиционных языках, ориентированных на использование классов, вам не удастся изменить определение класса в будущем, так что паттерн проектирования «класс» не предполагает такой возможности. Но одна из самых выдающихся особенностей языка JS — его динамизм и тот факт, что определение любого объекта (если только он не сделан неизменяемым) является подвижным и изменяемым.

  <br></p>
  </details>

[//]: # (Полиморфизм)
- <details><summary><b>Полиморфизм</b></summary><p>

  - Продолжим предыдущий пример (см. Наследование)
  - Есть класс Publication, у него есть данные (имя автора и название публикации) и метод `print` (выводит их в console.log).
  - Есть классы Book и BlogPost. У них есть свои данные, и свои методы `print`, которые вначале вызывают метод `print` родительского класса Publication, а потом допечатывют в консоль что-то своё.
    - Пример:
      ```
        print() {
          super.print();
          console.log(this.URL);
        }
      ```
  - Тот факт, что унаследованный и переопределенный методы могут иметь одинаковые имена (`print`) и сосуществовать в классе, называется полиморфизмом.

  - Пример целиком
    - ```js 
    class Publication {
    constructor(title,author,pubDate) {
    this.title = title;
    this.author = author;
    this.pubDate = pubDate;
    }
    print() {
    console.log(`
    Title: ${ this.title }
    By: ${ this.author }
    ${ this.pubDate }
    `);
    }
    }

    class Book extends Publication {
    constructor(bookDetails) {
    super(
    bookDetails.title,
    bookDetails.author,
    bookDetails.publishedOn
    );
    this.publisher = bookDetails.publisher;
    this.ISBN = bookDetails.ISBN;
    }
    print() {
    super.print();
    console.log(`
    Publisher: ${ this.publisher }
    ISBN: ${ this.ISBN }
    `);
    }
    }

    class BlogPost extends Publication {
    constructor(title,author,pubDate,URL) {
    super(title,author,pubDate);
    this.URL = URL;
    }
    print() {
    super.print();
    console.log(this.URL);
    }
    }

    var YDKJS = new Book({
    title: "You Don't Know JS",
    author: "Kyle Simpson",
    publishedOn: "June 2014",
    publisher: "O'Reilly",
    ISBN: "123456-789"
    });

    YDKJS.print();
    // Title: You Don't Know JS
    // By: Kyle Simpson
    // June 2014
    // Publisher: O'Reilly
    // ISBN: 123456-789

    var forAgainstLet = new BlogPost(
    "For and against let",
    "Kyle Simpson",
    "October 27, 2014",
    "https://davidwalsh.name/for-and-against-let"
    );

    forAgainstLet.print();
    // Title: For and against let
    // By: Kyle Simpson
    // October 27, 2014
    // https://davidwalsh.name/for-and-against-let
    ```


  - любой метод может обратиться к другому методу (с тем же или другим именем) на более высоком уровне иерархии наследования
  - имя метода может иметь несколько определений на разных уровнях цепочки наследования, и эти определения автоматически выбираются при поиске вызываемых методов. 
  - Пусть полиморфизм не создает у вас обманчивого впечатления, будто дочерний класс связан с родительским. Дочерний класс всего лишь получает копию нужных компонентов от родительского класса. «Наследование» здесь означает «копирование». Ещё раз: это две разные вещи — «иметь связь» (т.е. возможность обратиться к методам родителя) и «иметь копии методов родителя».
  - В результате операции копирования «потомок» начинает существовать отдельно от «родителя». Если вы добавите свойство в «родителя», это никак не повлияет на «потомка», и наоборот.
  - вообще широкая тема, имеет много аспектов
  
    <br></p>
    </details>

[//]: # (Классы в JS)
- <details><summary><b>Классы в JS</b></summary><p>

  - B JS нет классов в классическом ООП-понимании. Это язык с прототипным наследованием
  - Но есть средства в некоторой степени имитирующие поведение классов. «Под капотом» они работают на объектах с прототипным наследованием
  - JS — едва ли не единственный язык, который может с полным правом использовать определение «объектно-ориентированный», потому что он входит в очень короткий список языков, в которых объект может создаваться напрямую, без использования классов.
  - В JS синтаксис похожий на классы, но по своему поведению он сильно отличается от того, к чему вы привыкли с классами из других языков.
  - Например:
    - в языках с настоящими классами (Java) конструктор принадлежит классу. В JS все наоборот — правильнее считать, что «класс» принадлежит конструктору (ссылки на типы Foo.prototype...). Так как в JS связь между родителем и потомком существует только между двумя объектами .prototype в соответствующих конструкторах, сами конструкторы не связаны напрямую, и не существует простого способа относительного обращения из одного к другому
    - Классы подразумевают копирование. При создании экземпляра традиционных классов происходит копирование поведения из класса в экземпляр. При наследовании классов также происходит копирование поведения из родителя в потомка. Может показаться, что полиморфизм (существование разных функций с одинаковыми именами на разных уровнях цепочки наследования) подразумевает наличие относительной связи по ссылке от потомка к родителю, но в действительности он всего лишь является результатом копирования. JS не использует автоматическое копирование между объектами (как обычно подразумевают классы).
  -
  - Поддержка JS-классов браузерами — не более чем «синтаксический сахар». 
  - Эти конструкции преобразуются в те же базовые структуры, которые уже поддерживаются языком. 
  - В результате, даже если пользоваться новым синтаксисом, на более низком уровне всё будет выглядеть как создание конструкторов и манипуляции с прототипами объектов.

  - **Поддержка классов ES6 в JS-движке V8**
    - При подготовке JS-кода к выполнению система производит его синтаксический анализ 
    - Формирует на его основе абстрактное синтаксическое дерево. 
    - При разборе конструкций объявления классов в абстрактное синтаксическое дерево попадают узлы типа ClassLiteral. В подобных узлах хранится пара интересных вещей: 
      - конструктор в виде отдельной функции
      - список свойств класса. Это могут быть методы, геттеры, сеттеры, общедоступные или закрытые поля. Такой узел, кроме того, хранит ссылку на родительский класс, который расширяет класс, для которого сформирован узел, который, опять же, хранит конструктор, список свойств и ссылку на собственный родительский класс.
    - После того, как новый узел ClassLiteral трансформируется в код, он преобразуется в конструкции, состоящие из функций и прототипов.


  - **Ссылки**
    - [learn.javascript.ru - ООП в функциональном стиле](https://learn.javascript.ru/oop)
    - [learn.javascript.ru - ООП в прототипном стиле](https://learn.javascript.ru/prototypes)
    - [Habr - Как работает JS: классы и наследование, транспиляция в Babel и TypeScript](https://habr.com/ru/company/ruvds/blog/415377/)
    - [Web-dev - Классы (YouTube)](https://youtu.be/BASquaxab_w)
  
  <br></p>
  </details>

[//]: # (Экземпляр)
- <details><summary><b>Экземпляр</b></summary><p>

  - «Класс» = чертёж. План создания некоей сущности (например объекта). Чтоб получить что-то с чем ты можешь взаимодействовать — нужно создать на основе класса `экземпляр`. Результат такого построения — объект, обычно называемый экземпляром.

  <br></p>
  </details>

[//]: # (Конструктор)
- <details><summary><b>Конструктор</b></summary><p>

  - Особый метод класса — для конструирования экземпляров классов. Его имя обычно совпадает с именем класса.
  - Конструкторы практически всегда должны вызываться с оператором `new`, чтобы языковое ядро понимало, что вы хотите сконструировать новый экземпляр класса.
  - Т.е. команда `new X` = вызови конструктор класса Х. Т.е. создай объект на основе этого класса X (используя его конструктор).
  - `new` в каком-то смысле «захватывает» любую нормальную функцию и вызывает ее способом, который конструирует объект (в дополнение к тому, что она еще делает). Т.е. функция выполняет свою работу + создаёт объект
  - в JS правильнее всего говорить, что «конструктор» — любая функция, вызываемая с ключевым словом new. 
  - Функции не являются конструкторами, но вызовы функций являются «вызовами конструктора» в том и только том случае, если они используются с new.

  <br></p>
  </details>

[//]: # (Множественное наследование)
- <details><summary><b>Множественное наследование</b></summary><p>
   
  - Некоторые объектно-ориентированные языки позволяют указать более одного «родительского» класса для наследования. Тогда каждое определение родительского класса копируется в дочерний класс.
  - В JS нет встроенного механизма «множественного наследования». 
    - Многие считают, что это хорошо, потому что снижение сложности более чем компенсирует «сокращение» функциональности. 
    - Это не мешает разработчикам пытаться моделировать множественное наследование различными способами.

  <br></p>
  </details>

[//]: # (Примеси)
- <details><summary><b>Примеси</b></summary><p>

  - Объектный механизм JS не выполняет автоматического копирования при наследовании или создании экземпляров.
  - В JS вообще не существует «классов», экземпляры которых можно было бы создавать; есть только объекты. А объекты не копируются в другие объекты, они связываются между собой.
  - Паттерн «примесь» (явный и неявный) часто используется для моделирования поведения копирования классов, но обычно он ведет к уродливому и ненадежному синтаксису, что часто приводит к созданию кода, более сложного для понимания и сопровождения.
  - Все попытки имитации поведения копирования классов, описанные в главе 9 и названные разновидностями примесей, полностью обходят механизм цепочки [[Prototype]]
  - Так как наблюдаемое поведение классов в других языках подразумевает копирование, для начала посмотрим, как разработчики JS имитируют отсутствующее поведение копирования классов в JS: они используют примеси (mixins). Мы рассмотрим два типа примесей, явные и неявные.
  - **Явные**
    - JS не обеспечивает автоматического копирования поведения из родительского объекта/«класса» в дочерний. 
    - Вместо этого можно создать функцию, которая будет выполнять копирование вручную. Такая функция во многих библиотеках/фреймворках часто называется `extend(..)`
    - С технической точки зрения сами функции не дублируются; копируются только ссылки на функции
    - В целом копирование свойства из одного объекта в другой приносит меньше реальной пользы, чем повторное определение свойств (по одному разу для каждого объекта).
    - Будьте осторожны и используйте явные примеси там, где они действительно делают код более понятным. Избегайте этого паттерна, если он усложняет трассировку кода или создает излишние, громоздкие зависимости между объектами.
  - **Неявные**
    - В потомке вызываем методы родителя (parentClass.methodName.call(this)), причём вызываем их в контексте потомка (используем .call(this)). 
    - Вызов происходит при вызове конструктора (самый распространенный случай), либо при вызове метода
    - Хотя этот прием вроде бы использует функциональность повторного связывания this, он содержит ненадежный вызов Something. cool.call(this), который невозможно преобразовать в относительную (и потому более гибкую) ссылку и к которому следует относиться с осторожностью. В общем случае таких конструкций лучше избегать, чтобы код был более понятным и создавал меньше проблем с сопровождением.

  <br></p>
  </details>


[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [WebDev - Классы в JS](https://youtu.be/BASquaxab_w)
  - [LearnJS - Классы](https://learn.javascript.ru/class)
  - [MDN - Классы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)
  - [Habr - JavaScript: полное руководство по классам](https://habr.com/ru/post/518386/)

  <br></p>
  </details>

<br></p>
</details>

[//]: # (Конструктор)
<details id="constructor"><summary><b>Конструктор</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - `Конструктор` — специальная функция, задача которой заполнить пустой объект свойствами и методами. 
  - Функция, которая конфигурирует объект для дальнейшего использования.
  - Это эквивалент типов данных (классов) в ООП языках программирования (C++, C#, Java).
  - 
  - Обычный синтаксис {...} позволяет создать только один объект.
  - Если надо создать N однотипных объектов — можно сделать при помощи функции-конструктора и оператора "new".
  - Основная цель конструкторов – удобный способ многократного создания однотипных объектов.
  - 
  - В других языках программирования можно создавать свои типы данных (классы)
  - В JS такой возможности нет, можно оперировать лишь теми типами данных, которые заложены в язык:
    - примитивами,
    - тривиальными типами null и undefined,
    - сложными типами (Объект, Массив)
    - специальным типом Функция.

  - Функции-конструкторы технически являются обычными функциями. Есть два соглашения:
    - Имя функции-конструктора должно начинаться с большой буквы.
    - Функция-конструктор должна выполняться только с помощью оператора "new".
  -
  - `new` - ключевое слово, которое создает новый пустой объект
  - 
  - `Object()` - функция, в которую передается новый пустой объект
    - конфигурирует объект и добавляет в него стандартные свойства и методы
    - настроенный готовый объект возвращается в переменную, которой он присвоен
  - 
  - Как мы отличаем, что объекты относятся к какому-то типу данных (классу)? 
    - Если 2 объекта имеют одинаковый набор свойств и методов, значит эти объекты относятся к одному типу (классу).
  - 
  - В конструкторе можно создавать не только свойства, но и методы
  - 
  - Свойство функции-конструктора = аналог статического свойства в других языках
  - Метод функции-конструктора = аналог статического метода в других языках

  <br></p>
  </details>

[//]: # (Ключевое слово this)
- <details><summary><b>Ключевое слово this</b></summary><p>

  - Ключевое слово this - это то, что отличает конструктор от обычной функции. 
  - Конструктор использует в своем теле ключевое слово this, чтобы в объект добавить какие-то свойства. 
  - Ключевое слово this в момент запуска функции всегда ссылается на пустой объект, который был создан с помощью оператора new.
  
  <br></p>
  </details>

[//]: # (Работа с примитивами через литерал и конструктор)
- <details><summary><b>Работа с примитивами через литерал и конструктор</b></summary><p>

  - В JS мы можем создать строковое значение двумя способами:
    - используя литерал
      - `let simpleStr = 'My String'` — переменная со строковым значением (литерал)
    - используя конструктор
      - `var objectStr = new String('some String object');` — объект типа String (конструктор)
  -
  - Добавлять новые свойства и методы можно только к объектам, созданным через оператор `new`.
  - Добавить свойство к переменной невозможно.
  - Каждый раз, когда мы обращаемся к примитиву через переменную, под капотом JS временно превращает его значение в объект для того, чтобы можно было взаимодействовать с определенными нативными методами, характерными для этого примитива (например, toString() для строк). Но этот объект не сохраняется в памяти, поэтому и невозможно обратиться ни к одному его кастомному свойству/методу, если такое было добавлено.

  <br></p>
  </details>

[//]: # (new function)
- <details><summary><b>new function()</b></summary><p>

  - `new function() { … }` — можно обернуть в коде создание одного большого объекта с большим кодом. 
  - Конструктор создаётся и тут же вызывается. 
  - Не может быть использован дважды. 
  - Инкапсуляция кода создания большого объекта
  
  <br></p>
  </details>

[//]: # (new.target)
- <details><summary><b>new.target</b></summary><p>

  - Используя специальное свойство `new.target` внутри функции, можно проверить — вызвана ли функция при помощи оператора `new` или без него.
    - Если функция вызвана при помощи `new`, то в `new.target` будет сама функция,в противном случае `undefined`
    - Можно использовать, чтобы отличить обычный вызов от вызова «в режиме конструктора» 
      - Тогда можно обработать этот случай, написать для него свою логику => чтобы функцию можно было вызывать как «с new», так и «без new». 
      - Иногда используется в библиотеках. 
      - Плохая практика.
  
  <br></p>
  </details>

[//]: # (Return из конструктора)
- <details><summary><b>Return из конструктора</b></summary><p>

  - Обычно конструкторы ничего не возвращают явно. 
  - Их задача – записать все необходимое в `this`, который в итоге станет результатом.
  -
  - Если return всё же есть:
    - При вызове return с объектом, будет возвращён объект, а не this .
    - При вызове return с примитивным значением, примитивное значение будет отброшено.
      
  - Т.е. return с объектом возвращает объект, в любом другом случае конструктор вернёт this
    
  <br></p>
  </details>

[//]: # (Конструктор Function)
- <details><summary><b>Конструктор Function()</b></summary><p>

  - Позволяет динамически создавать и компилировать анонимные функции. 
  - Принимает неограниченное кол-во параметров, последний параметр всегда является телом создаваемой функции. 
  - Параметры, которые передаются в начале списка аргументов Function(), являются входными параметрами для генерируемой функции.
  - ```js
      var func = new Function('x', 'y', 'return x + y');
      console.log( func(10, 20) ); // 30
    ```
  -
  - Использовать этот конструктор для создания функций не рекомендуется — он снижает производительность, 
  - А также, являясь эквивалентом функции `eval()`, он открывает потенциальную брешь в безопасности 
    - код, который попадет в тело функции, обязательно выполнится 
    - и если этот код функция получает извне от пользователя, то передав вредоносный код, можно получить нежелательные последствия.
    
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Конструктор, оператор "new"](https://learn.javascript.ru/constructor-new)
  - [JS Advanced 1. Конструкторы и прототипы](https://gist.github.com/ncer/ea537927470b3c0b6bbd7a741e50d9fe)
  
  <br></p>
  </details>

<br></p>
</details>


---


[//]: # (Перебор структур данных. Методы «keys», «values», «entries»)
<details id="keysValuesEntries"><summary><b>Перебор структур данных. Методы «keys», «values», «entries»</b></summary><p>

  - Универсальные методы, существует соглашение использовать их для структур данных.<br>
  - Если мы делаем свою структуру данных, нам также следует их реализовать.
    - `.keys()`
    - `.values()`
    - `.entries()`
  - 
  - Для простых объектов
    - Object.keys(obj)
    - Object.values(obj)
    - Object.entries(obj)
    - Отличие
      - Объект надо указывать в скобках - `Object.keys(objName)` , не `objName.keys()`
      - Возвращает «реальный» массив
  - Для структур Map, Set, Array
    - Не надо ничего указывать в скобках - `mapName.keys()`
    - Возвращает перебираемые объект
  - 
  - **Символьные свойства**
    - Игнорируют символьные свойства!
      - Уточнить - только в простых объектах или также и Map, Set, Array?
    - `Object.getOwnPropertySymbols,` —  метода, возвращающий массив только символьных ключей. 
    - `Reflect.ownKeys(obj)` - метод, возвращает все ключи.
  - 
  - **Ссылки:**
    - [learn.javascript.ru - Object.keys, values, entries](https://learn.javascript.ru/keys-values-entries)

<br><p>
</details>

[//]: # (Итераторы. Перебираемые/итерируемые объекты)
<details id="iterators"><summary><b>Итераторы. Перебираемые/итерируемые объекты</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Тип объектов, содержимое которых можно перебрать в цикле
  -
  - По сути - объект, предназначенный для перебора другого объекта (массива, функции-генератора, списка DOM-узлов, строки..)
  - Итераторы дают возможность сделать «перебираемыми» любые объекты.
  - Для перебора таких объектов добавлен новый синтаксис цикла: `for..of`.

  - В отличие от классических массивов, «перебираемые» объекты могут не иметь «длины» length. 
  - 
  - Начиная с ES6 в языке есть стандартный протокол «Итератор».
  - Итераторы – концепция расширяющая понятие «массив». Пронизывает современный стандарт JS сверху донизу.
  - Практически везде, где нужен перебор, он осуществляется через итераторы.
  

  <br></p>
  </details>

[//]: # (Паттерн «итератор». Структура данных «итератор»)
- <details><summary><b>Паттерн «итератор». Структура данных «итератор»</b></summary><p>
  
  - «Итератор» — это паттерн программирования. Описывает способ потребление данных из источника — порцию за порцией.
  - Паттерн определяет структуру данных — `итератор`. 

  - Характеристики этой структуры:
    - содержит ссылку на нижележащий источник данных,
    - нижележащий источник предоставляет метод `next()` (или аналогичный).
    - вызов `next()` возвращает следующий фрагмент данных (например, при переборе строки — следующий символ).
  
  - Паттерн «итератор» важен, т.к. даёт стандартный способ итеративной обработки данных.
  - Создает более понятный и доступный код, вместо того чтобы каждая структура данных/источник определяла собственный способ обработки своих данных.

  - В программировании итератор — это интерфейс, у которого есть метод `next` и признак `done`
    - загрузил с сервера в память некую коллекцию и перебираю её, перемещаясь с помощью метода next
  -  Но, в JS итератор = штука, которая возвращает {value, done} и имеет метод next 

  <br></p>
  </details>

[//]: # (Как работает)
- <details><summary><b>Как работает</b></summary><p>

  - **Описание 1**
    - `Итератор` — специальный объект, который возвращается «перебираемыми» объектами, когда их перебирают используя «протокол потребления итераторов» (т.е. вызывают их метод `Symbol.iterator`, например в конструкции «for..of»). 
    - Этот специальный объект (итератор) хранит текущее состояние перебора и возвращает значение. 
    - У него должен быть метод `next()`, который при каждом вызове возвращает объект со свойствами 
        - `value` (текущее значение)
        - `done` (продолжаем работу дальше, или это последняя итерация).
  - **Описание 2**
    - Есть «итерируемые значения» (iterables) — значения, перебор содержимого которых может осуществляться при помощи итератора.
      - В ES6 определены базовые типы структур данных/коллекций JS, которые могут использоваться как итерируемые значения
        - строки
        - массивы
        - карты
        - множества
        - т. д.
      - Протокол автоматически создает экземпляр итератора по итерируемому значению и потребляет только этот экземпляр итератора до его завершения. 
      - Это означает, что одно итерируемое значение может потребляться многократно. 
      - При этом каждый раз создается и используется новый экземпляр итератора.
    - Протокол определяет метод `next()`
    - Этот метод возвращает объект — `результат итератора`
    - Объект имеет св-ва `value` (значение, ради которого мы итерируем) и `done` (служебный boolean параметр, если === true, то на этой итерации   останавливаем перебор, иначе продолжаем)
  - **Описание 3**
    - Есть некая сущность A (например строка, или объект), которую мы хотим перебрать используя «протокол потребления итераторов».
    - Сама сущность А может не реализовывать методы для своего перебора.
    - Создаём у А метод `[Symbol.iterator]`.
    - Вызов метода `[Symbol.iterator]` должен возвращать объект B. Этот объект называется «итератором»
    - `Итератор` (объект В) хранит текущее состояние перебора и возвращает значение.
      - У него должен быть метод `next()`, который при каждом вызове возвращает объект со свойствами:
        - `value` – очередное значение
        - `done`  – равно false если есть ещё значения, и true – в конце.
    - Конструкция `for..of` вызывает `Symbol.iterator()` сущности A, получает `итератор` (объект B) и далее вызывает метод `next()` до получения `done: true`.

  <br></p>
  </details>

[//]: # (Варианты работы с протоколом «итератор»)
- <details><summary><b>Варианты работы с протоколом «итератор»</b></summary><p>

  - Т.к. в языке появился протокол «итератор» — появились три варианта работы с ним (потребления)
    - цикл `for..of`
      - ```js
            var iter = /* .. */; // Имеется итератор для некоторого источника данных.
            
            for (let val of iter) {
                console.log(`Iterator value: ${ val }`);
            }
          ``
    - оператор `...` — в варианте распределения (spread) и остатка (rest).
      - распределение в массив — `let result = [...iter]`
      - распределение при вызове функции — `let func = (...iter) => (...)`
    - оператор `...` — в варианте остатка (rest).
      -  если при вызове функции передать в неё 10 параметров, а переменных в скобках объявить только 2, и дописать в конце `...name` - оставшиеся 8   параметров будут собраны в массив name.
      - `let func = ( a, b, ...arrName) => ( console.log(arrName[0]))`
  - 
  - Массивы являются итерируемыми значениями => для поверхностного копирования массива может использоваться потребление итератора с оператором `...`:
    - ```js
            var arrCopy = [ ...arr ];
        ```
  - Также оператор `...` может использоваться для последовательного перебора символов строки:
    - ```js
      var greeting = "Hello world!";
      var chars = [ ...greeting ];
      chars; // [ "H", "e", "l", "l", "o", " ","w", "o", "r", "l", "d", "!" ]
      ```

  <br></p>
  </details>

[//]: # (Три формы итераторов)
- <details><summary><b>Три формы итераторов</b></summary><p>

  - По большей части для всех встроенных итерируемых значений в JS доступны три формы итераторов:
    - `values()`  — только для значений. Выводит в каждой итерации только значение
      - ```js
        // Есть два элемента DOM, `btn1` и `btn2`
        // Создадим Map, а потом используем его для перебора
        var buttonNames = new Map();
        buttonNames.set(btn1,"Button 1");
        buttonNames.set(btn2,"Button 2");
    
        for (let btnName of buttonNames.values()) {
          console.log(btnName);
        }
        // Button 1
        // Button 2
        ``` 
    - `keys()` — только для ключей. Выводит в каждой итерации только ключ (для массива и подобный — это индекс)
      - ```js
        var someObj = new Map();
        someObj.set('name','Ivan');
        someObj.set('surname','Ivanov');
    
        for (let data of someObj.keys()) {
          console.log(data)
        }
    
        //name
        //surname
        ``` 
    - `entries()` — для записей. Выводит в каждой итерации и ключ, и значение
      - ```js
        var arr = [ 10, 20, 30 ];
        for (let [idx,val] of arr.entries()) {
          console.log(`[${ idx }]: ${ val }`);
        }
        // [0]: 10
        // [1]: 20
        // [2]: 30
      ``` 
  
  <br></p>
  </details>

[//]: # (Итерируемый объект и итератор)
- <details><summary><b>Итерируемый объект и итератор</b></summary><p>

  - есть `итерируемый объект` (ИО), его хотим перебрать
  - `итератор` - особый объект, содержится в ИО. Используется для перебора содержимого ИО
  - итератор должен содержать метод `next()`
  - чтобы ИО получил итератор - он (ИО) должен должен содержать функцию, имя которой задается специальным символическим значением `Symbol.iterator`.
  - вызываем эту функцию, она возвращает итератор
  -
  - Итого, есть 2 сущности: **объект ИО** (который надо перебрать) и **объект итератор** (который содержит метод next() для перебора).
    - Это могут быть два разных, не связанных объекта.
    - Может быть отдельный объект-итератор внутри ИО.
    - А можно определить метод `next()` в ИО, и сделать сам ИО итератором. Тогда он является объектом который надо перебрать, и содержит метод для этого перебора.
  
  <br></p>
  </details>

[//]: # (Перебираемые/итерируемые объекты)
- <details id="iterable"><summary><b>Перебираемые (итерируемые) объекты</b></summary><p>

  - **Определения** 
    – объекты, которые реализуют метод `Symbol.iterator`. <br>
    - объекты, который умеют обращаться к элементам коллекции по одному за раз, отслеживая своё текущее положение в этой последовательности.
    - механизм, который позволяет перемещаться (итерироваться) по элементам коллекции в определённом порядке и делает их доступными.
    - Все, что можно перебрать с помощью цикла `for..of`.
  - 
  - **«Встроенные» интерируемые объекты JS**
    - массив
    - строка
    - Map
    - Set
    - TypedArray
    - Generator
    - объект, у которого есть метод `Symbol.iterator` — специальный встроенный Symbol, созданный как раз для этого.
    - 
    - Можно составить свои - нужно добавить в объект метод с именем `Symbol.iterator`.
    - Список DOM-узлов, например, это итерируемый о
  - 
  - **Итератор и псевдомассив**

    - `Итерируемые объекты` — объекты, которые реализуют метод `Symbol.iterator`, как было описано выше.
    - `Псевдомассивы` — объекты, у которых есть индексы и свойство `length` (т.е., они выглядят как массивы).
  - 
  - **Метод Array.from**
  - Принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array. Затем можно использовать методы массивов.
  - 
  - **Ссылки:**
    - [learn.javascript.ru - Перебираемые объекты](https://learn.javascript.ru/iterable)
    - [Цикл For…of в JavaScript](https://medium.com/nuances-of-programming/%D1%86%D0%B8%D0%BA%D0%BB-for-of-%D0%B2-javascript-6e35f353ce34)
    - [MDN - Итераторы и генераторы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Iterators_and_Generators)
    - [Doka - Итератор ](https://doka.guide/js/iterator/)

  <br><p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru](https://learn.javascript.ru/iterator)
  - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=h0IkQhHE8rB3kAjj&t=2784)
  - Симпсон К — «Вы (пока) не знаете JavaScript. Познакомьтесь, JavaScript» (2 изд) стр. 115
  -
  - [learn.javascript.ru - Перебираемые объекты](https://learn.javascript.ru/iterable)
  - [Цикл For…of в JavaScript](https://medium.com/nuances-of-programming/%D1%86%D0%B8%D0%BA%D0%BB-for-of-%D0%B2-javascript-6e35f353ce34)
  - [MDN - Итераторы и генераторы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Iterators_and_Generators)
  - [Doka - Итератор ](https://doka.guide/js/iterator/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Генераторы todo: доработать)
<details id="generators"><summary><b>Генераторы *</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Подход, когда вычисляется только следующий элемент
    - не загрузил коллекцию с сервера, а вычисляю каждое её значение только после вызова метода next
    - это подход, который вычисляет только следующее нужное значение
    - но, в JS генератор = штука, которая возвращает итератор
  - 
  - Функция, которая может остановиться в процессе выполнения и вернуть промежуточный результат.
  - 
  - ```js
    function* generateSequence() {
      yield 1;
      yield 2;
      return 3;
    }
    
    let generator = generateSequence();
    let one = generator.next(); // {value: 1, done: false}
    let two = generator.next(); // {value: 2, done: false}
    let three = generator.next(); // {value: 3, done: true}
    ```
  - 
  - Основным методом генератора является `next()`. 
  - При вызове он запускает выполнение кода до ближайшей инструкции `yield <значение>`
  - Значение может отсутствовать, в этом случае оно = `undefined`.
  - По достижении `yield` выполнение функции приостанавливается, а соответствующее значение – возвращается во внешний код.
  -
  - Результатом метода `next()` всегда является объект с двумя свойствами:
    - `value`: значение из `yield`.
    - `done`: `true`, если выполнение функции завершено, иначе `false`.
  -
  - После выполнения `return` генератор полностью выполнен. Мы можем увидеть это по свойству `done:true`.
  - Новые вызовы `generator.next()` больше не имеют смысла.
  - Впрочем, если они и будут, то не вызовут ошибки, но будут возвращать один и тот же объект: `{done: true}`.

  <br></p>
  </details>

[//]: # (Перебор генераторов)
- <details><summary><b>Перебор генераторов</b></summary><p>

  - Генераторы являются перебираемыми объектами.
  - Возвращаемые ими значения можно перебирать через `for..of`.
  - перебор через for..of игнорирует последнее значение, при котором `done: true`
  - ```js
      function* generateSequence() {
        yield 1;
        yield 2;
        return 3;
      }

      let generator = generateSequence();
      for(let value of generator) {
        alert(value); // 1, затем 2
      }
    ```
  - 
  - Т.к. генераторы являются перебираемыми объектами, мы можем использовать всю связанную с ними функциональность
  - например: оператор расширения `...` в этом выражении `let sequence = [...generateSequence()];`

  <br></p>
  </details>

[//]: # (Композиция генераторов)
- <details><summary><b>Композиция генераторов</b></summary><p>

  - Возможность генераторов, которая позволяет прозрачно «встраивать» генераторы друг в друга.
  - ```js
      function* generateSequence(start, end) {
        for (let i = start; i <= end; i++) yield i;
      }

      function* generatePasswordCodes() {

        // 0..9
        yield* generateSequence(48, 57);

        // A..Z
        yield* generateSequence(65, 90);

        // a..z
        yield* generateSequence(97, 122);

      }

      let str = '';

      for(let code of generatePasswordCodes()) {
        str += String.fromCharCode(code);
      }

      alert(str); // 0..9A..Za..z
    ```

  <br></p>
  </details>

[//]: # (todo: разбираться!)
[//]: # («yield» может передавать значение извне в генератор)
- <details><summary><b>«yield» может передавать значение извне в генератор</b></summary><p>

  - `yield` не только возвращает результат наружу, но и может передавать значение извне в генератор.
  - ```js
      function* gen() {
        // Передаём вопрос во внешний код и ожидаем ответа
        let result = yield "2 + 2 = ?"; // (*)

        alert(result);
      }

      let generator = gen();

      let question = generator.next().value; // <-- yield возвращает значение

      generator.next(4); // --> передаём результат в генератор
    ```

  <br></p>
  </details>

[//]: # (generator.throw)
- <details><summary><b>generator.throw</b></summary><p>

  - В генератор можно передать не только результат, но и инициировать ошибку.
  - ```js
      function* gen() {
        try {
          let result = yield "2 + 2 = ?"; // (1)
          alert("Выполнение программы не дойдёт до этой строки, потому что выше возникнет исключение");
        } catch(e) {
          alert(e); // покажет ошибку
        }
      }

      let generator = gen();
      let question = generator.next().value;
      generator.throw(new Error("Ответ не найден в моей базе данных")); // (2)
    ```
  - 
  - Если мы не хотим перехватывать её, то она, как и любое обычное исключение, «вывалится» из генератора во внешний код.<br>
  - Текущая строка вызывающего кода – это строка с generator.throw, отмечена (2). Таким образом, мы можем отловить её во внешнем коде, как здесь:
  - ```js
      function* generate() {
        let result = yield "2 + 2 = ?"; // Ошибка в этой строке
        }

        let generator = generate();

        let question = generator.next().value;

        try {
        generator.throw(new Error("Ответ не найден в моей базе данных"));
        } catch(e) {
        alert(e); // покажет ошибку
      }
    ```
  - Если же ошибка и там не перехвачена, то дальше – как обычно, она выпадает наружу и, если не перехвачена, «повалит» скрипт.

  <br></p>
  </details>

[//]: # (Применение)
- <details><summary><b>Применение</b></summary><p>

  - В современном JS используются редко.
  - Полезными т.к. способность функции обмениваться данными с вызывающим кодом во время выполнения совершенно уникальна.
  - И, конечно, для создания перебираемых объектов.
  - 
  - Асинхронные генераторы — используются, чтобы читать потоки асинхронно сгенерированных данных (например, постранично загружаемые из сети) в цикле for await ... of.
  - В веб-программировании мы часто работаем с потоками данных, так что это ещё один важный случай использования.

  <br></p>
  </details>

[//]: # (Прочее)
- <details><summary><b>Прочее</b></summary><p>

  - Генераторы — разновидность функций, которые не выполняются до завершения, как обычные функции. Вместо этого генератор может быть приостановлен на середине завершения (с полным сохранением состояния), а позднее продолжить работу с точки приостановки.
  - В основе переходов от приостановки к продолжению работы лежит принцип «кооперативной работы», а не «вытеснения». Это означает, что только сам генератор может приостановить себя, используя ключевое слово `yield`, и только итератор, управляющий генератором, может (при помощи `next(..)`) возобновить выполнение генератора.
  - Дуализм `yield`/`next(..)` — не просто механизм управления; в действительности это механизм двусторонней передачи сообщений. Выражение `yield ..` фактически приостанавливается в ожидании значения, а следующий вызов `next(..)` передает значение (или неявное `undefined`) приостановленному выражению yield. 
  - Главное преимущество генераторов, связанное с управлением асинхронной программной логикой, заключается в том, что код внутри генератора выражает последовательность шагов задачи естественным синхронным/последовательным образом. Фокус в том, что потенциальная асинхронность прячется за ключевым словом `yield`, то есть асинхронность перемещается в код, управляющий итератором генератора.
  - Другими словами, генераторы поддерживают паттерн последовательного синхронного блокирующего кода по отношению к асинхронному коду. Это позволяет нашему мозгу более естественно анализировать код и устраняет один из двух ключевых недостатков асинхронности на базе обратных вызовов.

  <br></p>
  </details>

[//]: # («Итерируемый объект» и «итератор»)
- <details><summary><b>«Итерируемый объект» и «итератор»</b></summary><p>

    - есть `итерируемый объект` (ИО), его хотим перебрать
    - `итератор` - особый объект, содержится в ИО. Используется для перебора содержимого ИО
    - итератор должен содержать метод `next()`
    - чтобы ИО получил итератор - он (ИО) должен должен содержать функцию, имя которой задается специальным символическим значением `Symbol.iterator`.
    - вызываем эту функцию, она возвращает итератор
    -
    - Итого, есть 2 сущности: **объект ИО** (который надо перебрать) и **объект итератор** (который содержит метод next() для перебора).
        - Это могут быть два разных, не связанных объекта.
        - Может быть отдельный объект-итератор внутри ИО.
        - А можно определить метод `next()` в ИО, и сделать сам ИО итератором. Тогда он является объектом который надо перебрать, и содержит метод для этого перебора.
    -
    - Генератор формально не является ИО. При выполнении генератора я получаю итератор. Каждый раз когда я вызываю метод next() такого итератора - генератор производит новое значение. Итератор, который я получаю из генератора, является также ИО

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Генераторы](https://learn.javascript.ru/generators)
  - [WebDev -  #16 Генераторы](https://youtu.be/ejdhriCfF8s)
  - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=h0IkQhHE8rB3kAjj&t=2784)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Функции-генераторы)
<details id="funcGenerators"><summary><b>Функции-генераторы</b> — function*()</summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Могут приостанавливать своё выполнение, возвращать промежуточный результат и возобновляться позже.<br>
  - Код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором»
  - Генератор связан с итераторами. В частности, он является итерируемым объектом.
  - Один генератор может включать в себя другие. Это называется композицией.
  - Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
  - Появились в ES6.
  
  <br></p>
  </details>

[//]: # (Плоский асинхронный код)
- <details><summary><b>Плоский асинхронный код</b></summary><p>

  - Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.
  - Общий принцип такой:
    - Генератор yield'ит не просто значения, а промисы.
    - Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами
      next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в
      генератор следующим next.
    - Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например,
      возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.
  - 
  - Пример
  - ```js
      function * downToOne(n) {
        for (let i = n; i > 0; --i) {
          yield i;
        }
      }

      [...downToOne(5)] // [ 5, 4, 3, 2, 1 ]
    ```
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru](https://learn.javascript.ru/generator)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Асинхронная итерация todo: доработать)
<details id="asyncIteratorsGenerators"><summary><b>Асинхронная итерация *</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно. Например, когда мы загружаем что-то по частям по сети.<br>
  - Асинхронные генераторы делают такой перебор ещё удобнее.
  - 
  - Чтобы сделать объект итерируемым асинхронно:
    - Используется `Symbol.asyncIterator` вместо `Symbol.iterator`.
    - `next()` должен возвращать промис.
    - Чтобы перебрать такой объект, используется цикл` for await (let item of iterable)`
  -
  - Оператор расширения `...` не работает асинхронно

      
  <br></p>
  </details>

[//]: # (Асинхронный итератор)
- <details><summary><b>Асинхронный итератор</b></summary><p>

  - ```js
      let range = {
        from: 1,
        to: 5,

        // for await..of вызывает этот метод один раз в самом начале
        [Symbol.asyncIterator]() { // (1)
          // ...возвращает объект-итератор:
          // далее for await..of работает только с этим объектом,
          // запрашивая у него следующие значения вызовом next()
          return {
            current: this.from,
            last: this.to,

            // next() вызывается на каждой итерации цикла for await..of
            async next() { // (2)
              // должен возвращать значение как объект {done:.., value :...}
              // (автоматически оборачивается в промис с помощью async)

              // можно использовать await внутри для асинхронности:
              await new Promise(resolve => setTimeout(resolve, 1000)); // (3)

              if (this.current <= this.last) {
                return { done: false, value: this.current++ };
              } else {
                return { done: true };
              }
            }
          };
        }
      };

      (async () => {

        for await (let value of range) { // (4)
          alert(value); // 1,2,3,4,5
        }

      })()
    ```
  
  <br></p>
  </details>

[//]: # (Асинхронный генератор)
- <details><summary><b>Асинхронный генератор</b></summary><p>

  -  ```js
        async function* generateSequence(start, end) {

          for (let i = start; i <= end; i++) {

            // ура, можно использовать await!
            await new Promise(resolve => setTimeout(resolve, 1000));

            yield i;
          }

        }

        (async () => {

          let generator = generateSequence(1, 5);
          for await (let value of generator) {
            alert(value); // 1, потом 2, потом 3, потом 4, потом 5
          }

        })();
      ```
  - Одно из отличий асинхронного генератора — его метод `generator.next()` тоже асинхронный и возвращает промисы.
  -
  - Из обычного генератора мы можем получить значения при помощи `result = generator.next()`.
  - Для асинхронного нужно добавить `await`, вот так:
    - `result = await generator.next(); // result = {value: ..., done: true/false}`
    
  <br></p>
  </details>

[//]: # (Зачем?)
- <details><summary><b>Зачем?</b></summary><p>

  1. Например, есть API, который выдаёт данные порциями, как «пагинатор» (пачка данных + ссылка на следующую). 
     - А мы хотим иметь просто объект с данными, которые можно перебирать `for..of`. 
     - Асинхронные генераторы позволяют сделать функцию `fetchCommits(repo)`, которая будет получать коммиты, делая запросы всякий раз, когда это необходимо. И пусть она сама разбирается со всем, что касается нумерации страниц, для нас это будет просто `for await..of`.
  2. В веб-разработке мы часто встречаемся с потоками данных, когда они поступают по частям. 
     - Например, загрузка или выгрузка большого файла. Мы можем использовать асинхронные генераторы для обработки таких данных. 
     - Также заметим, что в некоторых окружениях, например, браузерах, есть и другое API, называемое `Streams` (потоки), который предоставляет специальные интерфейсы для работы с такими потоками данных, их преобразования и передачи из одного потока в другой (например, загрузка из одного источника и сразу отправка в другое место).

  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learn.javascript.ru - Асинхронная итерация](https://learn.javascript.ru/async-iterators-generators)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Асинхронная итерация. Цикл «for-await-of» todo: дополнить)
<details id="cycleForAwaitOf"><summary><b>Асинхронная итерация. Цикл «for-await-of» *</b></summary><p>


- Цикл для перебора асинхронно итерируемых объектов
- Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно.
  - Например, когда мы загружаем что-то по частям по сети

- Ссылки:
  - [Цикл for-await-of](https://learn.javascript.ru/async-iterators-generators)

<br></p>
</details>


---


[//]: # (Обработчики событий. Events handlers todo: дополнить)
<details id="eventsHandlers"><summary><b>Обработчики событий. Events handlers *</b></summary><p>

- Блоки кода (обычно функции), которые позволяют обрабатывать события (щелчок мыши...) и реагировать на них.

- Когда такой блок кода определяют для запуска в ответ на некое событие, говорят "мы регистрируем обработчик событий".
- Иногда обработчики называют прослушивателями событий (event listeners). Термины часто взаимозаменяемы, но вообще: _прослушиватель_ слушает событие, а _обработчик_ — это код, который запускается в ответ на событие.

- **Ссылки**:

  - [learn.javascript.ru](https://learn.javascript.ru/introduction-browser-events)
  - [MDN](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F)
  - [professorweb.ru](https://professorweb.ru/my/javascript/js_theory/level2/2_5.php)

<br></p>
</details>

[//]: # (Декораторы)
<details id="decorators"><summary><b>Декораторы</b></summary><p>

  - Декораторы позволяют добавить метаданные классам и функциям.
  - Тем самым изменить их поведение без изменения их кода.
  - По сути - обычная функция. Оборачивает некую сущность и модифицирует её поведение. Похоже на High Order Components.

  - **Ссылки**
    - [Mentanit - Декораторы в TS](https://metanit.com/web/typescript/6.1.php8)
    - [WebDev - Декораторы в TS](https://youtu.be/1-lWrocbnK8)
    - [Habr - Разбираем декораторы ES2016](https://habr.com/ru/post/277021/)
    - [learn.javascript.ru - Декораторы и переадресация вызова, сall/apply](https://learn.javascript.ru/call-apply-decorators)

<br></p>
</details>

[//]: # (Декоратор Debounce)
<details id="debounce"><summary><b>Декоратор Debounce (Дебаунс)</b></summary><p>

- Ждёт Х милисек, если некое событие не произошло за это время — выполняет действие.
- "Декоратор" который возвращает обертку. Она откладывает вызов исходной функции на определенное время.
- Превращает несколько вызовов функции в течение определенного времени в один вызов.
- Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова.
- Паттерн микрооптимизации кода.
-
- Если дословно переводить — «устранение дребезга».
-
- **Ссылки:**
  - [Legmo - Программирование](../Programming/Programming.md)
  - [learn.javascript.ru - Сделать Debounce](https://learn.javascript.ru/task/debounce)
  - [doka - Сделать Debounce на примере формы поиска](https://doka.guide/js/debounce/)
  - [Habr - Debouncing с помощью React Hooks](https://habr.com/ru/post/492248/)
  - [Habr - Debouncing с помощью React Hooks: хук для функций](https://habr.com/ru/company/domclick/blog/510616/)
  - [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)
  - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=Z9g8L-5_c5aHx3dA&t=3807)

<br></p>
</details>

[//]: # (Декоратор Throttling)
<details id="throttling"><summary><b>Декоратор Throttling (Тротлинг)</b></summary><p>

- Тормозит - выполняй событие не чаще чем Х милисек.
- Позволяет «затормозить» функцию — функция будет выполняться не чаще одного раза в указанный период, даже если она будет вызвана много раз в течение этого периода. Т.е. все промежуточные вызовы будут игнорироваться.
- Декоратор.
- Паттерн микрооптимизации кода.
-
- **Ссылки:**
  - [Habr - Декораторы](https://habr.com/ru/post/60957/)
  - [Habr - Микропаттерны оптимизации в Javascript: декораторы функций debouncing и throttling](https://habr.com/ru/post/60957/)
  - [YouTube - Асинхронность (Академия Яндекса)](https://youtu.be/x0Y3TfkvCgY?si=Z9g8L-5_c5aHx3dA&t=3807)

<br></p>
</details>

[//]: # (Proxy-объекты)
<details id="proxyObjects"><summary><b>Proxy-объекты</b></summary><p>

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Особые объекты, позволяют перехватывать и изменять действия, выполняемые над другими объектами.
  - 
  - В частности, речь идёт о вызове функций, об операциях присваивания, о работе со свойствами, о создании новых объектов, и
  - так далее.
  - Эту технологию используют для блокирования прямого доступа к целевому объекту или целевой функции и организации
  - взаимодействия с объектом или функцией через прокси-объект.
  - 
  - Так выглядит объявление простого прокси-объекта, которому передаётся целевой объект и обработчик: `let proxy = new Proxy(target, handler);`
  
  <br></p>
  </details>)

[//]: # (Стандартное поведение объектов)
- <details><summary><b>Стандартное поведение объектов</b></summary><p>

  - Объявим объект, а затем попробуем обратиться к несуществующему свойству этого объекта.
  - ```
      let obj = {
        c: "car",
        b: "bike"
      };

      document.write(obj.b, ""); //Результат -> "bike"
      document.write(obj.c, ""); //Результат -> "car"
      document.write(obj.l);     //Результат -> "undefined"
    ```
  
  <br></p>
  </details>)

[//]: # (Использование proxy для объекта)
- <details><summary><b>Использование proxy для объекта</b></summary><p>

  - Используем обработчик с перехватчиком get. Обработчик передаст целевой объект и запрошенный ключ перехватчику.
  - ```js
      let handler = {
          get: function(target, name) {
          return name in target ? target[name] : "Key does not exist";
        }
      }

      let obj = {
        c: "car",
        b: "bike"
      };

      let proxyObj = new Proxy(obj, handler);

      document.write(proxyObj.b, ""); //Результат -> "bike"
      document.write(proxyObj.c, ""); //Результат -> "car"
      document.write(proxyObj.l);     //Результат -> "Key does not exist"
    ```
  
  <br></p>
  </details>)

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [Habr — Практика применения прокси-объектов в JavaScript (2018)](https://habr.com/ru/company/ruvds/blog/359060/
  
  <br></p>
  </details>)

<br></p>
</details>

[//]: # (Объект Math. Встроенные математические функции)
<details id="math"><summary><b>Объект Math. Встроенные математические функции</b></summary><p> 

[//]: # (Общее)
- <details><summary><b>Общее</b></summary><p>

  - Объект, хранящий в себе различные математические константы (например число π) и функции типа вычисления квадратного корня. 
  - Обычно используется для генерации случайных чисел или округления значений.
  - Констант и функций в объекте много, поэтому при необходимости их нужно поискать в документации.
  -
  - Пример
    - ```js
      console.log(Math.PI) // 3.141592653589793
      console.log(Math.abs(-118)) // 118

      ```
  
  <br></p>
  </details>

[//]: # (Свойства)
- <details><summary><b>Свойства</b></summary><p>

  - `Math.E` — число Эйлера или Непера, основание натуральных логарифмов, приблизительно равное 2,718.
  - `Math.LN2` — натуральный логарифм из 2, приблизительно равен 0,693.
  - `Math.LN10` — натуральный логарифм из 10, приблизительно равен 2,303.
  - `Math.LOG2E` — двоичный логарифм из E, приблизительно равен 1,443.
  - `Math.LOG10E` — десятичный логарифм из E, приблизительно равен 0,434.
  - `Math.PI` — отношение длины окружности круга к его диаметру, приблизительно равно 3,14159.
  - `Math.SQRT1_2` — квадратный корень из 1/2; или, что тоже самое, 1, делённая на квадратный корень из 2, приблизительно равен 0,707.
  - `Math.SQRT2` — квадратный корень из 2, приблизительно равен 1,414.
  
  <br></p>
  </details>

[//]: # (Методы)
- <details><summary><b>Методы</b></summary><p>

  - `Math.abs(x)` — возвращает абсолютное значение числа.
  - `Math.acos(x)` — возвращает арккосинус числа.
  - `Math.asin(x)` — возвращает арксинус числа.
  - `Math.atan(x)` — возвращает арктангенс числа.
  - `Math.atan2(y, x)` — возвращает арктангенс от частного своих аргументов.
  - `Math.ceil(x)` — возвращает значение числа, округлённое к большему целому.
  - `Math.cos(x)` — возвращает косинус числа.
  - `Math.exp(x)` — возвращает Ex, где x — аргумент, а E — число Эйлера (2,718…), основание натурального логарифма.
  - `Math.floor(x)` — возвращает значение числа, округлённое к меньшему целому.
  - `Math.log(x)` — возвращает натуральный логарифм числа (loge, также известен как ln).
  - `Math.max([x[, y[, …]]])` — возвращает наибольшее число из своих аргументов.
  - `Math.min([x[, y[, …]]])` — возвращает наименьшее число из своих аргументов.
  - `Math.pow(a, n)` — возвращает a в n-й степени, то есть an.
  - `Math.random()` — возвращает псевдослучайное число в диапазоне от 0 до 1.
  - `Math.round(x)` — возвращает значение числа, округлённое до ближайшего целого.
  - `Math.sin(x)` — возвращает синус числа.
  - `Math.sqrt(x)` — возвращает положительный квадратный корень числа.
  - `Math.tan(x)` — возвращает тангенс числа.
  - `Math.toSource()` — возвращает строку "Math". Non-standard
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Методы экспериментальные</b></summary><p>

  - `Math.acosh(x)` — возвращает гиперболический арккосинус числа.
  - `Math.asinh(x)` — возвращает гиперболический арксинус числа.
  - `Math.atanh(x)` — возвращает гиперболический арктангенс числа.
  - `Math.cbrt(x)` — возвращает кубический корень числа.
  - `Math.clz32(x)` — возвращает количество ведущих нулей 32-битного целого числа.
  - `Math.cosh(x)` — возвращает гиперболический косинус числа.
  - `Math.expm1(x)` — возвращает exp(x), из которого вычли единицу.
  - `Math.fround(x)` — возвращает ближайшее число с плавающей запятой одинарной точности, представляющие это число.
  - `Math.imul(x)` — возвращает результат умножения 32-битных целых чисел.
  - `Math.log1p(x)` — возвращает натуральный логарифм числа 1 + x (loge, также известен как ln).
  - `Math.log10(x)` — возвращает десятичный логарифм числа.
  - `Math.log2(x)` — возвращает двоичный логарифм числа.
  - `Math.sinh(x)` — возвращает гиперболический синус числа.
  - `Math.tanh(x)` — возвращает гиперболический тангенс числа.
  - `Math.hypot([x[, y[, …]]])` — возвращает квадратный корень из суммы квадратов своих аргументов.
  - `Math.sign(x)` — возвращает знак числа, указывающий, является ли число положительным, отрицательным или нулём.
  - `Math.trunc(x)` — возвращает целую часть числа, убирая дробные цифры.
  
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>
  
  - [MDN — Math](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math)
  - [Дока - Объект Math](https://doka.guide/js/math/)
  
  <br></p>
  </details>

<br></p>
</details>

[//]: # (Хранение данных в браузере: Cookie, socalStorage, sessionStorage todo: пусто)
<details id="dataStorage"><summary><b>Хранение данных в браузере: Cookie, socalStorage, sessionStorage **</b></summary><p>

  - см. [Legmo notes - Сеть. Хранение данных в браузере: Cookie, socalStorage, sessionStorage](../Network/Network.md#dataStorage)

  - **Ссылки:**
    - [learn.javascript.ru - Cookie](https://learn.javascript.ru/cookie)
    - [learn.javascript.ru - LocalStorage, sessionStorage](https://learn.javascript.ru/localstorage)
    - [IT-Kamasutra - Ликбез из тачиллы. #3 Авторизация с помощью Cookie](https://youtu.be/MFhbPi5UtCU)
    - [IT-Kamasutra - Ликбез из тачиллы. #2 Cookie Куки - введение](https://youtu.be/KcAKrtr4qyg)

      <br></p>

</details>

[//]: # (Анаморфизмы и катаморфизмы)
<details id="iterators"><summary><b>Анаморфизмы и катаморфизмы</b></summary><p>

  - **Анаморфизмы**
    - `Анаморфизмы`. Функции, с помощью которых объекты разворачиваются в более сложные структуры, содержащие объекты того же типа. 
    - Например  преобразование целого числа в ряд чисел.
    - ```js
        // Преобразование целого числа в ряд чисел:
        function downToOne(n) {
          const list = [];

          for (let i = n; i > 0; --i) {
            list.push(i);
          }

          return list;
        }

        downToOne(5) // [ 5, 4, 3, 2, 1 ]
      ```
  - **Катаморфизмы**
    - Противоположность анаморфизмов: сворачивают объекты с более сложной структурой в простые.
    - Например преобразует несколько чисел в одно.
    - ```js
        // Преобразование ряда чисел в одно
        function product(list) {
          let product = 1;

          for (const n of list) {
            product = product * n;
          }

          return product;
        }

        product(downToOne(5)) // 120
      ```
  - **Ссылки**
    - [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/#amrphcatmrph)

<br></p>
</details>

[//]: # (Каррирование)
<details id="nullishCoalescing"><summary><b>Каррирование</b></summary><p>

Техника для работы с функциями.<br>
Трансформация функций таким образом, чтобы они принимали аргументы не как `f(a, b, c)`, а как `f(a)(b)(c)`.

Позволяет использовать одну и ту же функцию и в обычном виде, и в виде `частично применённой функции`.<br>
Т.е. с зафиксированным значением одного или нескольких аргументов.<br>
Например, вместо `function log(date, importance, message) {}` получаем частный случай `debugNow("message")`, в котором `date` всегда равен текущему времени, а `importance = INFO`<br>
Т.е. универсальная функция `log(date, importance, message)` после каррирования возвращает нам частично применённую функцию, когда вызывается с одним аргументом, как `log(date`) или двумя аргументами, как `log(date, importance)`.

Для каррирования необходима функция с фиксированным количеством аргументов.<br>
Функцию, которая использует остаточные параметры, типа f(...args), так каррировать не получится.

По определению, каррирование должно превращать `sum(a, b, c)` в `sum(a)(b)(c)`.<br>
Но большинство реализаций каррирования в JavaScript более продвинуты: они также оставляют вариант вызова функции с несколькими аргументами.
<br>
<br>

**Пример**
```js
function curry(f) { // curry(f) выполняет каррирование
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// использование
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
```
Более продвинутые реализации каррирования, как например _.curry из библиотеки lodash, возвращают обёртку, которая позволяет запустить функцию как обычным образом, так и частично.

```js
function sum(a, b) {
  return a + b;
}

let curriedSum = _.curry(sum); // используем _.curry из lodash

alert( curriedSum(1, 2) ); // 3, можно вызывать как обычно
alert( curriedSum(1)(2) ); // 3, а можно частично
```
<br>
<br>

- Трансформация функций таким образом, чтобы они принимали аргументы не как `f(a, b, c)`, а как `f(a)(b)(c)`.
  - Позволяет создавать частично применённые функции — т.е. способ вызова функции, у которой какие-то аргументы зафиксированы, и их не надо вводить
  - Каррирование не вызывает функцию. Оно просто трансформирует её.
- Это продвинутая техника для работы с функциями.
- Используется не только в JavaScript, но и в других языках.


- **Ссылки**
  - [learn.javascript.ru - Каррирование (`??`)](https://learn.javascript.ru/currying-partials)

<br></p>
</details>

[//]: # (Thunk)
<details id="thunk"><summary><b>Thunk</b></summary><p>

- В общей теории обработки данных существует старая, появившаяся еще до JS концепция `преобразователей` (thunk).
- Узкоспециализированным выражением преобразователя в JS является функция, которая без каких-либо параметров подключается для вызова другой функции.
- Иначе говоря, вызов функции (со всеми необходимыми параметрами) «заворачивается» в определение функции, которое создает промежуточное звено для выполнения внутренней функции.
- Внешняя функция-обертка и называется `преобразователем`. Позднее при выполнении преобразователя в конечном итоге будет вызвана исходная функция.
-
- Пример:
  ```js
    function foo(x,y) {
        return x + y;
    }
    function fooThunk() {
        return foo( 3, 4 );
    }
  
    console.log( fooThunk() );  // 7
  ```


<br></p>
</details>

[//]: # (Ошибки)
<details id="errorsObject"><summary><b>Ошибки</b></summary><p>

***

[//]: # (throw)
<details><summary><b>throw</b></summary><p>

Мы можем также генерировать собственные ошибки, используя оператор `throw`.<br>
Аргументом `throw` может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса `Error`.
```js
throw new Error('something went wrong')
```
<br><p>
</details>

[//]: # (try..catch..finally)
<details><summary><b>try..catch..finally</b></summary><p>

Конструкция `try..catch` позволяет обрабатывать ошибки во время исполнения кода.
```js
try {
  // исполняем код
} catch(err) {
  // если случилась ошибка, прыгаем сюда
  // err - это объект ошибки
} finally {
  // выполняется всегда после try/catch, независимо от того есть ошибка и
}
```
Секций `catch` или `finally` может не быть — т.е. конструкции `try..catch` и `try..finally` также корректны.<br>
Если объект ошибки не нужен, мы можем пропустить его, используя `catch{}` вместо `catch(err) {}`.
<br><p>
</details>

[//]: # (Проброс исключения)
<details><summary><b>Проброс исключения</b></summary><p>

`Catch` должен обрабатывать только те ошибки, которые ему известны, и «пробрасывать» все остальные.<br>
Т.е. передавать их дальше, чтоб их отловил следующий обработчик ошибок (который «знает» этот тип ошибок). В крайнем случае — их поймает глобальный верхнеуровневый обработчик ошибок.

Проброс исключения – это очень важный приём обработки ошибок: блок catch обычно ожидает и знает, как обработать определённый тип ошибок, поэтому он должен пробрасывать дальше ошибки, о которых он не знает.

```js
try {
  // ...
} 
catch(e) {
  if (e.name == "SyntaxError") { // «знакомая» ошибка, обрабатываем
    alert( "JSON Error: " + e.message );
  } else {
    throw e; // проброс остальных ошибко(*)
  }
}
```
<br><p>
</details>

[//]: # (Глобальный обработчик ошибок. Window.onerror)
<details><summary><b>Глобальный обработчик ошибок. Window.onerror</b></summary><p>

Даже если у нас нет `try..catch`, большинство сред позволяют настроить «глобальный» обработчик ошибок, чтобы ловить ошибки, которые «выпадают наружу».<br>
В браузере это `window.onerror`.
```js
window.onerror = function(message, url, line, col, error) {
  // ...
};
```
Роль глобального обработчика `window.onerror` обычно заключается не в восстановлении выполнения скрипта – это скорее всего невозможно в случае программной ошибки, а в отправке сообщения об ошибке разработчикам.

Существуют веб-сервисы, которые предоставляют логирование ошибок для таких случаев.<br>
Например [errorception.com](https://errorception.com) или [muscula.com](http://www.muscula.com).

Они работают так:
- Мы регистрируемся в сервисе и получаем небольшой JS-скрипт (или URL скрипта) от них для вставки на страницы.
- Этот JS-скрипт ставит свою функцию window.onerror.
- Когда возникает ошибка, она выполняется и отправляет сетевой запрос с информацией о ней в сервис.
- Мы можем войти в веб-интерфейс сервиса и увидеть ошибки.
  <br><p>
</details>

[//]: # (Объект Error. Стэк ошибки)
<details><summary><b>Объект Error. Стэк ошибки</b></summary><p>

7 встроенных видов ошибок, также можно создать свои собственные.

Конструктор `Error` создаёт объект ошибки.<br>
Экземпляры объекта Error выбрасываются при возникновении ошибок во время выполнения.

Встроенные ошибки генерируются самим движком JS, пользовательские — создаются с помощью конструктора Error.<br>
Ошибки можно ловить в конструкции `try...catch`.

Вызов конструктора `new Error()` возвращает объект ошибки со следующими свойствами:

- `name` — имя типа (класса) ошибки.
- `message` — человекопонятное описание ошибки для встроенных типов (SyntaxError, TypeError и так далее) и переданное в
  конструктор значение для общего типа Error.

```js
const commonError = new Error('Общая ошибка. Проверьте код')
console.log(commonError.message) // 'Общая ошибка. Проверьте код'
console.log(commonError.name) // 'Error'

```
Объекты ошибок содержат следующие свойства:
- message – понятное человеку сообщение.
- name – строка с именем ошибки (имя конструктора ошибки).
- stack (нестандартное, но хорошо поддерживается) – стек на момент ошибки. Показывает последовательность операций, приведшую к неправильной работе программы. В частности, это позволяет понять — в каком именно файле содержится сбойный код, и увидеть, какая последовательность вызовов функций привела к ошибке.

Пример стэка ошибки
```
Error: please improve your code
 at Object.<anonymous> (/Users/gisderdube/Documents/_projects/hacking.nosync/error-handling/src/general.js:1:79)
 at Module._compile (internal/modules/cjs/loader.js:689:30)
 at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)
 at Module.load (internal/modules/cjs/loader.js:599:32)
 at tryModuleLoad (internal/modules/cjs/loader.js:538:12)
 at Function.Module._load (internal/modules/cjs/loader.js:530:3)
 at Function.Module.runMain (internal/modules/cjs/loader.js:742:12)
 at startup (internal/bootstrap/node.js:266:19)
 at bootstrapNodeJSCore (internal/bootstrap/node.js:596:3)
```
Здесь, в верхней части, находится сообщение об ошибке, затем следует указание на тот участок кода, выполнение которого вызвало ошибку, потом описывается то место, откуда был вызван этот сбойный участок. Это продолжается до самого «дальнего» по отношению к ошибке фрагмента кода.

<br><p>
</details>

[//]: # (Встроенные ошибки движка JS)
<details><summary><b>Встроенные ошибки движка JS</b></summary><p>

  - помимо общей обертки Error( .. ), существует несколько оберток для конкретных разновидностей ошибок:
  - SyntaxError — сбои в программе, которые не позволяют начать выполнение.
  - TypeError — аномалии, возникающие в ходе выполнения программы.
  - ReferenceError —
  - 
  - `SyntaxError` — опечатки. Неверные названия методов, лишние/отсутствующие точки с запятой или скобки и т.д.
  - `ReferenceError` — попытка обратиться к несуществующей переменной
  - `TypeError` — попытка обратиться к несуществующему свойству. Недопустимый тип переменной или параметра.
  - `RangeError` — для значений, которые выходят за диапазон допустимого. Слишком большая длина массива и т.д.
  - `URIError` — при неправильном использовании обработки URI. Передача неверных параметров в `encodeURI()`
    или `decodeURI()`
  - `EvalError` — ошибка в глобальной функции `eval()`
  - `nternalError (не стандарт)` — ошибка в движке JS. Не является стандартом, почти не используется.
  - `AggregateError` — представить несколько ошибок в виде одной комбинированной. Например, Promise.any(), когда все
    promises завершились в rejected. ЕS12(2021)
  - 
  - JS поддерживает несколько типов ошибок, но существует другая, менее известная классификация ошибок на две категории: 
    - «ранние ошибки» (выдаются компилятором и не перехватываются программой) 
    - «ошибки времени выполнения~> (для try .. catch). 
  - Разумеется, все синтаксические ошибки относятся к категории ранних, прерывающих работу программы перед ее выполнением.

  <br><p>
  </details>

[//]: # (Прочее)
<details><summary><b>Прочее</b></summary><p>

- Мы можем наследовать свои классы ошибок от `Error` и других встроенных классов ошибок, но нужно позаботиться о свойстве `name` и не забыть вызвать `super`.
- Мы можем использовать оператор `instanceof` для проверки типа ошибок. Этот оператор проверяет, принадлежит ли объект к определённому классу. Это также работает с наследованием. Но иногда у нас объект ошибки, возникшей в сторонней библиотеке, и нет простого способа получить класс. Тогда для проверки типа ошибки можно использовать свойство `name`.
- [Обёртывание исключений](https://learn.javascript.ru/custom-errors#obyortyvanie-isklyucheniy) является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как err.cause в примерах выше, но это не обязательно.
  <br><p>
</details>

**Ссылки:**

- [doka.guide - Error](https://doka.guide/js/errors/)
- [learn.javascript.ru — Обработка ошибок, "try..catch"](https://learn.javascript.ru/try-catch)
- [learn.javascript.ru — Пользовательские ошибки, расширение Error](https://learn.javascript.ru/custom-errors)
- [Habr — Руководство по обработке ошибок в JavaScript](https://habr.com/ru/company/ruvds/blog/431078/)
- [MDN - Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)
- [Habr - Error](https://habr.com/ru/company/ruvds/blog/431078/)
- [Mentanit - Error](https://metanit.com/web/javascript/16.3.php)
- [Отладка JavaScript в PhpStorm](https://vpawd.ru/articles/javascript_debugging_in_phpstorm?utm_source=pocket_mylist)

***

<br><p>
</details>


---

<br>
<br>

## Приёмы и соглашения ##

[//]: # (_переменная)
<details><summary><b>_переменная</b></summary><p> 

Общеприянтое соглашение - если название переменной начинается с _ , её не надо менять или читать снаружи объекта.<br>
Это просто соглашение об именовании, которое напоминает разработчику о том, что переменная (свойство) или метод являются
либо private, либо protected, и к ним нельзя получить доступ из-за пределов класса.

Чтоб делать это - используй специальные методы: 
  * сеттеры (set... - присвоить) 
  * геттеры (get... - получить)
  
  **Ссылки**

- [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)

  <br><p>
</details>

[//]: # (ПЕРЕМЕННАЯ)
<details><summary><b>ПЕРЕМЕННАЯ</b></summary><p> 
      
  Общеприянтое соглашение - если название переменной написано ЗАГЛАВНЫМИ, её не надо менять. Это константа.<br>
  
  **Ссылки**   

- [learn.js](https://learn.javascript.ru/variables)
- [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)
   
  <br><p>
</details>

[//]: # (Переменная)
<details><summary><b>Переменная</b></summary><p> 

Общеприянтое соглашение - если название переменной начинается с заглавной, значит это не переменная а класс ООП.<br>
У класса есть методы и всё такое...

**Ссылки**

- [9 сбивающих с толку соглашений об именовании](http://www.codeharmony.ru/materials/69)

<br><p>
</details>

[//]: # (вызов function с двумя парами скобок)
<details><summary><b>function()()</b></summary><p>

Зачем при вызове функции ставят две двойные скобки?

Функция getFunc() возвращает другую функцию (та что в переменной func).<br>
Вторые скобки нужны чтобы вызвать функцию, которую вернула getFunc().<br>
Если скобки опустить, то return внешней функции вернет Вам не результат а саму функцию.

Пример:

  ```
        var a = 1;
        function getFunc() {
          var a = 2;
          var func = function() { alert(a); };
          return func;
        }
        getFunc()(); // 2, из LexicalEnvironment функции getFunc
  ```

<br></p>
</details>

[//]: # (true && expression)
<details><summary><b>true && expression</b></summary><p>

`true && expression` — всегда вычисляется как expression,

`false && expression` — всегда вычисляется как false.

<br></p>
</details>

[//]: # (Побочные значения операторов и выражений)
<details><summary><b>Побочные значения операторов и выражений</b></summary><p>

  - Выражение `а + 3` само по себе не имеет побочного эффекта (как, например, изменение `а`).
  - У выражения есть результат (в данном случае 5), и этот результат присваивается `Ь` в команде `Ь = а + 3`.
  -
  - Оператор присваивания возвращает присвоенного значение. А само присваивание — его побочный эффект.
  - Поэтому возможен такой пример:
    - ```js
	  function vowels (str) {
	  	var matches;

	  	// Выражение (matches = str.match( /[aeiou]/g)) вернёт результат присваивания — заполненный массив (приводится к true). 
	  	// Или же matches останется undefine, что приводится к false 
	  	if ( str && (matches = str.match( /[aeiou]/g ))) {
	  		return matches;
	  	}
	  }
	  ```

<br></p>
</details>

[//]: # (Комментарии в стиле HTML)
<details><summary><b>Комментарии в стиле HTML</b></summary><p>

 `\<!--` и `-->` (комментарии в стиле HTML) в спецификации определяются как действительные однострочные комментарии-разделители в JS исключительно из-за устаревшего способа подключения js-скриптов в HTML. Никогда не используйте их.

<br></p>
</details>

<br>
<br>

## Отладка. Качество кода ##

[//]: # (Console.log)
<details><summary><b>Console.log</b></summary><p>

Браузер добавляет глобальную переменную с именем «console» к каждой загруженной веб-странице. Объект содержит много
методов, которые возволят писать на консоль и показывать информацию, проходящую через скрипты.

- Есть такая вещь как «управляющие объекты» (см. ниже) — переменные, которые определяются автоматически или иным образом создаются и передаются JS средой (браузер и т.д.)
- Пример управляющего объекта — объект `console` и его различные функции (`log()`, `error()` и т. д.).
- Объект `console` предоставляется средой размещения специально для того, чтобы ваш код мог взаимодействовать с ним для выполнения различных операций вывода, связанных с разработкой.

**Console.dir(object)**<br>
Позволяет смотреть в консоли свойства заданного javascript объекта.<br>
Также когда нужно как-то указать в логах на DOM-узел - лучшего всего использовать методы console.dir() или
console.dirxml(). Они могут перечислить свойства элемента или вывести HTML кода элемента.

При помощи метода console.dir() можно вывести список всех свойств объекта. Выглядит аналогично тому, что Вы бы увидели
во вкладке DOM.

**Группировка**<br>
  Иногда бывает полезно сгруппировать логи для упрощения работы с ними. 
  - console.group()
  - console.groupCollapsed()
  - console.groupEnd()
  ```
    console.group("Overlord");
    console.log("Overlord stuff");
     
    console.group("Lord");
    console.log("Overlord stuff");
     
    console.group("Minion");
    console.log("Minion stuff");
    console.groupEnd();
     
    console.groupCollapsed("Servant");
    console.log("Servant stuff");
  ```
  
  **Раскраска**<br>
  Методы подобные log, но отличающихся внешне: 
  - console.info()
  - console.warn() 
  - console.error()
  
  **Шаблонные строки**<br> 
  console.log(\`Значение переменной = ${var_name}\`)
  
  **Профилирование и замеры**<br>
  Консоль позволяет точно замерять время, используя метод console.time() и console.timeEnd(). Расположите вызов первого из них перед кодом, время исполнения которого хотите замерить, а второго — после.
  ```
  console.time("Execution time took");
  // Some code to execute
  console.timeEnd("Execution time took");
  ```
  Таймеры связаны между собой метками (передаются первым аргументом и могут быть любой строкой), так что Вы можете запустить несколько таймеров одновременно. Когда сработает console.timeEnd(), будет выведено сообщение с меткой и прошедшим временем в миллисекундах.
  
  Помимо замера времени можно профилировать Ваш код и вывести стек профилирования, который подробно показывает, где и сколько времени потратил браузер.
  ```
  console.profile();
  // Some code to execute
  console.profileEnd();
  ```
  
  **Assert**
  Полезно при работе с unit-тестами.
  
  Assert'ы позволяют обеспечивать соблюдение правил в коде и быть уверенным, что результаты выполнения этого кода соответствуют ожиданиям. Метод console.assert() позволяет проводить элементарное тестирование кода: если что-то пойдет не так, будет выброшено исключение. Первым аргументом может быть все, что угодно: функция, проверка на равенство или проверка существования объекта.
  ```
  var a = 1, b = "1";
  console.assert(a === b, "A doesn't equal B");
  ```
  Метод assert принимает условие, которое является обязательным к выполнению (в данном случае простая строгая проверка на равенство) и, вторым аргументом, сообщение, которое будет выведено в консоль вместе с выброшенным исключением, если первое условие не будет выполнено.
  
  **Console.trace()**<br>
  Вывод стека вызовов до текущего момента. Скажет, какие функции есть в стеке, и какие аргументы были переданы каждой. 
  
 
  **Ещё есть** 
  - console.clear - очищает консоль
  - console.count - выводит, сколько раз данный код был выполнен.
  - console.dirxml - выводит XML код элемента
  - console.exception - выводит ошибку и результат trace() для места, откуда она была вызвана
  - console.table - выводит таблицу ([Подробнее](http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/))
  - console.timeStamp - выводит текущий timestamp с текстом, который был передан в name.
  
  **Ссылки:**

- [Habr - Используем console на полную](https://habr.com/ru/post/114483/)
- [Habr - FireBug* Console API](https://habr.com/ru/post/188066/)
- [learn.javascript.ru - строки-шаблоны](https://learn.javascript.ru/es-string)
- [MDN - console.dir](https://developer.mozilla.org/ru/docs/Web/API/console/dir)
- [MDN - console.trace](https://habr.com/ru/post/141042/)
- [Про console.table (en)](http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/)

  <br></p>

***

`Console` — это объект для доступа к средствам отладки браузера (debugging console браузера).<br>
Работа с ним отличается в разных браузерах, но эти методы и свойства по факту поддерживаются всеми браузерами.

Доступ к `Console` можно получить через свойство глобального объекта:
- Window в браузере, т.е. `Window.console`. Для простоты на него ссылаются как `console`.
- WorkerGlobalScope — в workers это специальный способ доступа через свойство console. Он

- Разные типы сообщений
  - `console.log()`
  - `console.error()`
  - `console.info()`
  - `console.debug()` = console.log ()
  - `console.warn()`
- Группировка логов
  - `console.group('name')`, `console.groupEnd('name')`, `console.groupCollapsed()`
- Очистка консоли
  - `console.clear()`
- Трассировка стека
  - `console.trace()`
  - посмотреть как работал стек движка в процессе работы программы
  - При отладке глубоко вложенных объектов или функций может потребоваться распечатать трассировку стека кода.
  - Вызовите console.trace() из нужной функции в верхней части стека вызовов, чтобы увидеть место в коде, где был совершен вызов
- Счётчик вызовов
  - `console.count()`
- Таймер в консоли
  - `console.time()`
  - `console.timeEnd()`
- Работа с логическими выражениями
  - `console.assert()`
  - выводить что-то в лог, только если условие === `false` и вывести это в лог. Замена `If`
  - Функция принимает в качестве аргумента выражение, а также сообщение либо объект.
- Профилирование
  - `console.profile()`
  - профилирование — сбор характеристик работоспособности программы. Чтобы оценить, насколько эффективно она работает, выявить ее «слабые» участки.
- Метка времени
  - `console.timeStamp()`
  - выводит промежуточные отсчёты времени для таймера с указанной меткой.
  - помогает соотнести точку в вашем коде с другими записанными событиями.
- Чтение размера буфера
  - `console.memory`
  - Показывает размер буфера память браузера
  - Полезно, когда статистика производительности не совсем прозрачна и нет времени рассматривать графики.
- Отобразить объект в виде таблицы
  - `console.table()`
  - вывода табличного представления объекта с помеченными строками для каждого свойства
  - принимает в аргументе массив объектов, выводит таблицу, с которой можно взаимодействовать.
- Есть всякие нестандартные штуки, которые поддерживаются не всеми браузерами
  - `console.dir()`
    - console.log() выводит объект в строковом представлении,
    - console.dir() распознает его как объект и печатает свойства в виде расширяемого списка.
  - `console.dirxml()`
  - ...


**CSS-стиль консоли**

Если хотите разнообразить визуальные возможности ведения журнала, используйте `%c` перед строкой и передайте стили CSS в качестве второго аргумента.
```js
console.log('%c Some text', 'color: green')
```

**Ссылки**

- [tproger.ru - 10 консольных команд для упрощения отладки JavaScript-кода](https://tproger.ru/translations/javascript-debug-tricks/)
- [MDN - Console](https://developer.mozilla.org/ru/docs/Web/API/Console)
- [Продвинутые советы и хитрости console.log](https://proglib.io/p/prodvinutye-sovety-i-hitrosti-console-log-2021-06-29)
- [Habr - Используем console на полную](https://habr.com/ru/post/114483/)
- [Отладка JavaScript в PhpStorm](https://vpawd.ru/articles/javascript_debugging_in_phpstorm?utm_source=pocket_mylist)
- []()
- []()

<br></p>
</details>

[//]: # (Как оптимизировать JS-часть сайта?)
<details><summary><b>Как оптимизировать JS-часть сайта?</b></summary><p>

- Проверьте зависимости проекта. Избавьтесь от всего ненужного.
- Разделите код на небольшие фрагменты вместо того, чтобы складывать его в один большой файл.
- Откладывайте, в тех ситуациях, когда это возможно, загрузку JS-скриптов. При обработке текущего маршрута пользователю можно выдавать только тот код, который необходим для нормальной работы, и ничего лишнего.
- Используйте инструменты разработчика и средства вроде DeviceTiming для того, чтобы находить узкие места своих проектов.
- Используйте средства вроде Optimize.js для того, чтобы помочь парсерам определиться с тем, какие фрагменты кода им нужно обработать как можно скорее.
-
- Также, среди основных факторов, снижающих быстродействие JS:
    - выделение памяти,
    - уборка мусора
    - обращения к областям видимости.

<br></p>
</details>

[//]: # (Качество кода todo: доработать)
<details id="codeCleaning"><summary><b>Качество кода *</b></summary><p>


[//]: # (Абстрактные идеи)
- <details><summary><b>Абстрактные идеи</b></summary><p>

  - Кроме создания кода как функционального, так и эффективного, вы также должны стремиться к тому, чтобы ваш код был максимально простым для анализа и сопровождения.
  - Имена важны
  - Разумные, понятные, значимые комментарии. Желательно на английском
  - Избегать длинных «простыней». Дробить код (осмысленно). Вверху — абстрактный уровень (что в целом происходит). Захотел посмотреть конкретную реализацию — зашёл в код конкретной функции/модуля/метода...
  - Осмысленно работать с областью видимости. Не объявлять переменные в глобальной области видимости без крайней необходимости.
  - Будьте последовательны. Например, в использовании запятых или в стиле именования переменных — camelCase | cebab-case| shake_case | ...
    
  <br></p>
  </details>

[//]: # (Общие рекомендации)
- <details><summary><b>Общие рекомендации</b></summary><p>

  - Форматирование кода направлено на передачу информации, а передача информации является первоочередной задачей профессионального разработчика.
  - Фигурные скобки в одном стиле
  - Кавычки в одном стиле
  - Точка с запятой - ставить
  - Длина строки - 120 символов
  - Отступы горизонтальные - не нарушать структуру
  - Отступы вертикальные - не более 9 строк кода подряд без вертикального отступа.
  - Имя любой сущности должно отвечать на 3 вопроса - "Почему она существует?", "Какие функции выполняет?", "Как она используется?"
  - Имя переменной – существительное.
  - Имя функции – глагол или начинается с глагола.
  - Уровней вложенности должно быть немного.
  - Вначале код, под ним функции
  - Большие функции дробить на мелкие
  - Функции = Комментарии
  - Разумные комментарии - не "Что делает?", а "Как устроено?", "Какие параметры принимает?", "Почему выбрано это решение?".
  - Принцип единственной обязанности
  - Разделение команд и запросов - не смешивать функции, выполняющие запросы (например, получить имя) и функции выполняющие команды (например, привести имя к нижнему регистру)
  - Слабое *связывание* - это хорошо, сильное - плохо. 
    - Сильное связывание = сильная зависимость разных частей программы друг от друга.
  - Высокий ровень *связности* - хорошо (не путать с сильным связыванием). Низкий - плохо. 
    - Высокий - сбор конструкций, объединённых общей идеей, в одном месте.
  - Изоляция кода - выделять фрагменты кода в отдельные блоки, основываясь на их предназначении. В качестве таких блоков обычно выступают функции.
  - Разбивка кода на модули - функции, которые используются похожим образом или выполняют похожие действия, можно сгруппировать в одном модуле (или, если хотите, в отдельном классе).
  - Признак слаженности команды - читая код, ты не можешь понять, написал его ты, или коллега
    
  <br></p>
  </details>

[//]: # (Конкретика)
- <details><summary><b>Конкретика</b></summary><p>

  - Вместо `==` использовать `===`  (**спорно**)
  - Избегать "магических чисел"
  - Имя переменной должно раскрывать её сущность
  - Чем меньше у функции аргументов — тем лучше (**спорно**). 
    - Например, её будет легче тестировать. 
    - С другой стороны: если у функции N параметров, по первой строчке её объявления сразу видно - что нужно ей передать. 
    - Но, больше 5-6 параметров - перебор. Если функции нужно более 5-6 парамтеров - стоит подумать об использовании объекта с параметрами.
  - Используйте аргументы по умолчанию, отдавая им предпочтение перед условными конструкциями
  - Используйте Object.assign для установки свойств объектов по умолчанию
  - Не используйте флаги в качестве параметров (isOpen и т.д.). Их использование означает, что функция выполняет больше действий, чем следует.
  - Не загрязняйте глобальную область видимости
  - Не называть логические переменные так, чтобы в их именах присутствовало бы отрицание (notAdmin -> isAdmin)
  - Избегайте логических конструкций везде, где возможно. Вместо них используйте полиморфизм и наследование
  - ES-классы стоит предпочесть обычным функциям-конструкторам
  - Организуйте методы так, чтобы их можно было бы объединять в цепочки - в конце каждой из функций класса нужно возвращать this
  - Удаляйте неиспользуемый код
  - Если описывая, что должна делать функция, вы используете союз «и» - эта функция слишком сложна
  - Функция должна решать одну задачу
  - Большие функции стоит перерабатывать в классы. Если функция решает много задач, сильно связаных друг с другом, в которых используются одни и те же данные - имеет смысл переделать её в объект с методами
  - Если имя функции отвечает на некий вопрос - она должна возвращать значение, а не менять состояние данных.
  - Если имя функция "что-то делает" - она должна менять данные и не должна ничего возвращать
  - Жёстко заданные ID в функциях - признак сильного связывания
  - Несколько сильно завиясщих друг от друга функций, по сути = одна большая, просто разделённая на части. Избегай этого
  - Если возникла необходимость модифицировать класс из-за изменений другого класса - это признак сильного связывания
  - Если несколько функций используют одни и те же переменные - они должны быть сгруппированы. Хороший повод объединить их в объект.
  - Одна и та же строка кода не должна повторяться дважды. Повторяющийся код — это надёжный признак низкого уровня связности. Плохо.
  - Одни и те же данные не должны храниться в более чем одной переменной. Если определяете переменные с одинаковыми данными в разных местах программы - используйте класс.
  - Если вы передаёте ссылку на один HTML-элемент в несколько функций - можно сделать ссылку частью экземпляра некоего класса.
  - Не стоит собирать в одном классе сущности, не имеющие друг к другу никакого отношения.
  - Если свойства не используются несколькими методами класса, это может быть признаком низкого уровня связности. Плохо.
  - Если методы нельзя использовать в различных ситуациях (или метод вообще не используется) — признак плохой связности. Плохо.
  - Возвращать что-либо из функций нужно с помощью ключевого слова return.
  - Для экспорта самых важных сущностей, объявленных в модуле, используйте возможности экспорта по умолчанию. Для второстепенных сущностей можно применить именованный экспорт.
  - Используйте деструктурирование
  - Задавайте стандартные значения параметров функций
  - Не передавайте функциям ненужные данные
  - Ограничивайте размер файла. 100 строк - хорошо. 200-300 - приемлемо. Более 400 - не надо
  - Вложенность кода не должна превышать четырёх уровней.
  - Имена массивов. Массивы обычно содержат в себе наборы каких-то значений. В результате к имени переменной, хранящей массив, имеет смысл добавлять букву s. (student*s*)
  - Имен алогических значений - имеет смысл начинать с is или has.
  - Имена параметров функций, передаваемых стандартным методам массивов - лучше называть с учётом данных, которые в них оказываются
  - Использование коллбэков ухудшает читабельность кода. Особенно это касается вложенных коллбэков. Где возможно - используйте конструкцию async/await
  - Подчищать за собой console.log. Лишние выводы захламляют консоль. Использование отладочного кода может негативно сказаться на производительности. Но, некоторые логи имеет смысл оставлять. Например — команды, выводящие сообщения об ошибках и предупреждения.
  - Классы не должны быть длиннее 100 строк кода.
  - Методы и функции не должны быть длиннее 5 строк кода.
  - Методам следует передавать не более 4 параметров.
  - Контроллеры могут инициализировать лишь один объект.
      
  <br></p>
  </details>

[//]: # (Книги)
- <details><summary><b>Книги</b></summary><p>

  - Макконелл С - Совершенный код
    
  <br></p>
  </details>

[//]: # (Руководства по стилю)
- <details><summary><b>Руководства по стилю</b></summary><p>

  - [Google JavaScript Style Guide (en)](https://google.github.io/styleguide/jsguide.html)
  - [jQuery JavaScript Style Guide (en)](http://contribute.jquery.org/style-guide/js/)
  - [Airbnb JavaScript Style Guide (en)](https://github.com/airbnb/javascript)
  - [Airbnb JavaScript Style Guide (ru)](https://github.com/leonidlebedev/javascript-airbnb)
  - [Idiomatic.JS (en)](https://github.com/rwaldron/idiomatic.js)
  - [Idiomatic.JS (ru)](https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU)
  - [Dojo Style Guide (en)](https://dojotoolkit.org/reference-guide/1.10/developer/styleguide.html)
  - [JSLint style (en)](https://www.jslint.com/help.html)
  
  <br></p>
  </details>

[//]: # (Автоматизированные средства проверки. Линтеры)
- <details><summary><b>Автоматизированные средства проверки (линтеры)</b></summary><p>

  - [JSLint](http://www.jslint.com/)
  - [JSHint ](http://www.jshint.com/) - вариант JSLint с б*о*льшим количеством настроек
  - [Legmo notes — Качество кода](https://github.com/Legmo/notes/blob/master/Pages/JS/CodeQuality.md)
    
  <br></p>
  </details>

[//]: # (Ссылки)
- <details><summary><b>Ссылки</b></summary><p>

  - [learnjavascript - Как писать неподдерживаемый код?](https://learn.javascript.ru/write-unmain-code)
  - [learnjavascript - Советы по стилю кода](https://learn.javascript.ru/coding-style)
  - [Habr - Рекомендации по написанию чистого кода на JavaScript](https://habr.com/ru/company/ruvds/blog/454520/)
  - [Habr - JavaScript: путь к ясности кода](https://habr.com/ru/company/ruvds/blog/342404/)
  - [Habr - 7 рекомендаций по оформлению кода на JavaScript](https://habr.com/ru/company/ruvds/blog/418631/)
  - [Habr - Как писать чистый и красивый код](https://habr.com/ru/company/ruvds/blog/347610/)
  - [Habr - Пишем чистый и масштабируемый JavaScript-код: 12 советов](https://habr.com/ru/company/ruvds/blog/452562/)
  - [YouTube - Доклад Сэнди Метц о 4 правилах написания чистого кода в объектно-ориентированных языках (en)](https://www.youtube.com/watch?v=npOGOmkxuio)
  - [Legmo notes — Качество кода](https://github.com/Legmo/notes/blob/master/Pages/JS/CodeQuality.md)
  
  <br></p>
  </details>

<br></p>
</details>

<br> 
<br>

## Источники ##

[//]: # (Ресурсы по JS)
<details><summary><h3>Ресурсы по JS</h3></summary><p>

- [MDN - Повторное введение в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript)
- [tproger.ru - Шпаргалка по современному JavaScript](https://tproger.ru/translations/javascript-cheatsheet/)
- [Habr - Подводные камни JavaScript](https://habr.com/ru/post/159313)
- 
- [learn.javascript.ru](https://learn.javascript.ru)
- [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript)
- [MDN - Основы JS](https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/JavaScript_basics)
- [Kyle Simpson - Вы не знаете JS (серия из 6 книг, открытый доступ)](https://github.com/azat-io/you-dont-know-js-ru) (в 2022 вышло 2-е издание)
- [doka.guide](https://doka.guide/js)
- 
- [metanit.com](https://metanit.com/web/javascript/)
- [Schoolsw3](https://www.schoolsw3.com/js)
- [ITchief](https://itchief.ru/javascript/)
- [code.mu - Учебник JS: основной](https://code.mu/ru/javascript/book/prime/)
- [code.mu - Учебник JS: высший](https://code.mu/ru/javascript/book/supreme/)
- [code.mu - Учебник JS: ООП](https://code.mu/ru/javascript/book/oop/)
- [code.mu - Справочник JavaScript](https://code.mu/ru/javascript/manual/)
- [code.mu - Практика JS](https://code.mu/ru/javascript/book/practice/)
- [webref.ru - Знакомство с JavaScript (2015-2019)](https://webref.ru/dev/learn-javascript)
- [professorweb.ru - Учебник JavaScript](https://professorweb.ru/my/javascript/js_theory/level1/javascript_index.php)
- [golvinov — Введение в программирование](https://golvinov.gitbook.io/js/)
- [golvinov — Введение в JavaScript](https://golvinov.gitbook.io/js/vvedenie-v-javascript)

**Видео**

- [IT-Kamasutra - JS в деталях (48 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DN2nTU8Q10SvAn4k8NpMJvh)
- [IT-Kamasutra - Уроки JavaScript с нуля (ну ваще с нуля) (429 видео)](https://www.youtube.com/playlist?list=PLcvhF2Wqh7DPD5sRK3lw4bjBsKdgY2bPi)
- [WebDev - JavaScript (15 видео)](https://www.youtube.com/playlist?list=PLNkWIWHIRwMHKLotIS_d-wyj00pg0AnUg)
- [WebDev - ES6 (19 видео)](https://www.youtube.com/playlist?list=PLNkWIWHIRwMGLJXugVvdK7i8UagGQNaXD)
- [code.mu - Видео-уроки JS](https://code.mu/ru/javascript/video/lesson)

**Есть отдельные статьи**

- [Habr.com](https://habr.com/ru/search/?q=javascript)
- [medium.com](https://medium.com/)
- [proglib.io](https://proglib.io/search?q=Javascript)
- [webformyself.com](https://webformyself.com/category/javascriptajax-2/javascriptajax/)

**Прочее**

- [Hexlet - Бесплатный курс JS](https://ru.hexlet.io/courses/js-basics)
- [Официальная спецификация - актуальная (en)](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
- [Официальная спецификация - черновик и предложения (en)](https://tc39.github.io/ecma262)

<br></p>
</details>

<br> 
<br>

*[Legmo, 2019-2022](https://github.com/Legmo/notes/)*