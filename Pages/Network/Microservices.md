<h1>Микросервисная архитектура</h1>

**Определения**

- Архитектура на основе свободно сопряжённых сервисов с ограниченными контекстами.
- Подход к созданию приложения, подразумевает отказ от единой, монолитной структуры.<br>
  Не исполняем все ограниченные контексты приложения на сервере (с помощью внутрипроцессных взаимодействий).<br>
  Используем несколько небольших приложений — каждое соответствует какому-то ограниченному контексту.<br>
  И эти приложения работают на разных серверах, взаимодействуют друг с другом по сети (например через HTTP).
- Вариант структурного стиля сервис-ориентированной архитектуры (SOA)

2011-2012 гг<br>
По сути — способ реализации горизонтального масштабирования проекта.

**Ограниченный контекст**

- понятие явных границ вокруг какого-то бизнес-контекста.
- Например, в рамках электронной коммерции мы оперируем понятиями «темы» (themes), «поставщики платёжных услуг» (payment
  providers), «заказы», «отгрузка», «магазин приложений». Всё это ограниченные контексты, а значит — кандидаты в
  микросервисы.

**Размер микросервиса**
Сервис должен быть «настолько большим, чтобы умещаться в руке» — чтоб один человек мог полностью разобраться в его
устройстве и работе.<b>
В Amazon используется подход с «командами на две пиццы» (two pizzas team): в команде микросервиса должно быть столько
людей, чтобы их можно было накормить двумя пиццами.

**Преимущества**

- Частичное развёртывание. Микросервисы позволяют по мере необходимости обновлять приложение по частям.
- Доступность. У микросервисов доступность выше: даже если один из них сбоит, это не приводит к сбою всего приложения.
- Сохранение модульности. Сохранять модульность и инкапсуляцию проще. Микросервисы гарантируют отсутствие общих
  состояний (shared state) между модулями.
- Мультиплатформенность/гетерогенность. Микросервисы позволяют использовать разные технологии и языки, в соответствии с
  вашими задачами.
- Независимая эволюция подсистем

**Особенности**

- Непрерывное развёртывание
- Возможность и нацеленность на постоянное ускорение работы
- Усложнившийся мониторинг => Сильная devops-культура
- Продукты, а не проекты. Раньше был такой подход: команда создаёт какую-то функциональность, а затем передаёт её на
  сопровождение другой команде. В случае с микросервисами команда должна отвечать за свой продукт в течение всего его
  жизненного цикла, включая разработку, сопровождение и вывод из эксплуатации.
- Децентрализованное управление
- Автоматизация инфраструктуры
- Архитектура с эволюционным развитием

**Фронтенд/бэкенд**<br>
Раскидываем кодовые базы фронтенда и бэкенда, оставив UI приложения одним целым, чтобы они потом взаимодействовали по
HTTP. Микросервисы будут отделены друг от друга, что дополнительно разделит фронтенд и бэкенд. Зато UI можно
поддерживать целиком, легко сохраняя его связность. Такую структуру рекомендует использовать Рейчел Майерс, и, насколько
я понимаю, это единственный способ. В таком случае у нас есть два варианта взаимодействия между фронтендом и бэкендом:

- Много маленьких асинхронных HTTP-запросов вместо одного большого, что исключит возможность блокировки (этот подход
  предпочитает Чед Фаулер).
- Один большой запрос к специализированным сервисам (шлюзу/агрегатору/кешу), которые собирают данные со всей
  микросервисной экосистемы. Это уменьшает сложность UI.

**Недостатки**
- Сетевые задержки
  - если в модулях, выполняющих несколько функций, взаимодействие локально, то микросервисная архитектура накладывает требование атомизации модулей и взаимодействия их по сети;
- Форматы сообщений
  - отсутствие стандартизации и необходимость согласования форматов обмена фактически для каждой пары взаимодействующих микросервисов приводит как к потенциальным ошибкам, так и сложностям отладки.
- ...

**Ссылки**

- [Habr - Архитектура микросервисов (2017)](https://habr.com/ru/company/vk/blog/320962/)
- [Habr - Микросервисы (2015)](https://habr.com/ru/post/249183/)
- []()

<br> 
<br> 

*[Legmo, 2019-2023](https://github.com/Legmo/notes/)*
